\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage[nolist]{acronym}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
    
\newcommand{\todo}[1]{\textcolor{violet}{{\bfseries [[TODO: #1]]}}}
\newcommand{\tool}[1]{\textsc{#1}}

\begin{acronym}
\acro{QA}{Quality Assurance}
\acro{SUT}{System Under Test}
\acrodefplural{SUT}{Systems Under Test}
\acroindefinite{SUT}{an}{a}
\acro{LDCOF}{Local Density Cluster-Based Outlier Factor}
\acroindefinite{LDCOF}{an}{a}
\acro{DTW}{Dynamic Time Warping}
\acro{BMB}{BenchMark Bot}
\acro{ROS}{Robot Operating System}
\acro{NREC}{National Robotics Engineering Center}
\acro{FDR}{False Detection Rate}
\acro{UAS}{Unmanned Autonomous Systems}
\end{acronym}


    
\begin{document}

\title{The Effects of Timing Delays on ROS Systems\\
\thanks{Identify applicable funding agency here. If none, delete this.}
}

\author{\IEEEauthorblockN{Deborah S. Katz}
\IEEEauthorblockA{\textit{Computer Science Department} \\
\textit{Carnegie Mellon University}\\
Pittsburgh, PA, USA\\
dskatz@cs.cmu.edu}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
\and
\IEEEauthorblockN{3\textsuperscript{rd} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}

}

\maketitle

\begin{abstract}
Robotics and other cyber-physical systems interact with the real world.
Events in the real world can be unpredictable and sometimes cause delays.
Interacting with the real world sometimes involves the software waiting for
external events.
The architecture of some robotics and cyber-physical systems allows these
systems to absorb many delays without disrupting intended behavior, while
some delays, especially those that occur in critical sections of execution,
are too much for these systems to absorb. 
Furthermore, system monitoring is a set of techniques that can help to understand
when and whether systems are behaving as intended.
These techniques can add unacceptable levels of overhead in many 
circumstances.
However, the overhead of system monitoring techniques may be absorbed into normal execution for some robotics and cyber-physical systems.

This paper analyzes the circumstances under which artificially-inserted 
timing delays have an observable effect on robotics systems.




\end{abstract}

\begin{IEEEkeywords}
robotics, cyber-physical systems, software monitoring, software quality
\end{IEEEkeywords}

\section{Introduction}
Robotics and cyber-physical systems are particularly prone to variability in operating conditions because of their interaction with the real world and the unpredictable conditions therein. Some of these delays show up as timing delays in execution or communication within the system. However, many of these systems have architectures that have the ability to absorb some timing delays, as they are constructed to wait for physical events.

In addition, software monitoring techniques can cause execution delays. These techniques may be useful to evaluate whether software is behaving as intended, but in many legacy pieces of software, they cause unacceptable overhead. I hypothesize that the same properties that allow robotics and cyber-physical systems to absorb timing delays that occur due to real-world unpredictability allow these systems to absorb some of the delays that would be caused by program monitoring.

It is desirable to get a more precise understanding of the amount of delay that these systems can absorb, to determine to what extent they can tolerate software monitoring. 
\todo{I definitely had a better explanation for this reasoning before. Use that instead.}

\cite{TimperleyArdu2018}

\section{Background and Motivation}
\label{sec:background}
\todo{Fill in background}

\section{Approach}
\label{sec:approach}
\todo{Fill in approach}

This section sets out the approach to determining the extent to which artificial timing delays interfere with the behavior of robotics systems.
The details of the experiments as performed here are given in the following
section, \ref{sec:timing-methodology}.

For a given robot, I establish a set of commands, I call a mission. \todo{Damnit, this is still too detailed for approach, right?}

We want to establish a baseline for how a robot behaves without any artificially-inserted delays. To do so, we take a robot and run it on a set of commands (mission) many times.
This establishes the nominal baseline.
We use the nominal baseline to establish the baseline values for each metric.
We count the number of nominal runs that exhibit crashing behaviors, to establish a baseline for how often the software crashes, even when not artificially disrupted.

\todo{The approach section is unfinished and still intertwined with the methodology section}

\subsection{Methodology}
\label{sec:timing-methodology}
\todo{As usual, I've conflated approach and methodology. Separate these back out.}

To evaluate the extent to which timing delays deform the observable execution of a robotic system I execute the following experiments:

I run each robot over a series of missions. Each mission is represented as a series of destinations in three dimensional space (two dimensional space for robots that move in only two dimensions), with the final destination being a return to the origin point.

For each combination of robot and mission, I run several \emph{nominal} executions to establish a baseline for what robot behavior should look like in these executions. These are run in simulation on unmodified code, with no artificially-inserted delays.

For the \emph{experimental} executions, I add controlled artificial delays to the execution of the robot code.
The location, number, and length of these delays are experimental parameters to the experiments.
\subsubsection{Method of Inserting Delays}
\label{sec:timing-methodology-delays}

\paragraph{\tool{ArduCopter}} 
For the \tool{ArduCopter} experiments, the artificial delays are introduced before return statements in the code.
I identified the program point immediately before 
each return statement in all \tool{.cpp} files in the 
\tool{ArduPilot/ArduCopter} source code directory.
For each of these program points, there was the possibility of inserting an 
artificial delay.
The choice of whether to insert a delay was determined probabilistically, with a weighted coin flip. 
Different modified versions of the code were created, each of which had 
(a) a fixed coin flip weight and 
(b) fixed delay amount added at each delay location. 
The weights for the weighted coin flip ranged from 0.1 to 1.0, with 1.0
meaning a delay was inserted before every return statement, 
and the length of each delay ranged from 0.001953125 seconds to 8 seconds, 
with delay lengths chosen as powers of 2.

\paragraph{\tool{ROS}-based Systems}
For the \tool{\ac{ROS}} experiments, the artificial delays are introduced at communications 
barriers on ROS topics, taking advantage of the architecture of \tool{ROS}-based systems. 


\todo{TODO: insert discussion of how we're introducing delays at ROS topics and what this means in the ROS architecture}
To give a simplified overview of the architecture of ROS-based systems,
these systems consist of various nodes which communicate with each other by 
sending messages over a bus.
\todo{Add a diagram?} 
A publish-subscribe system determines which nodes receive which messages. 
A node can publish messages to a \emph{topic}.
To receive those messages, another node subscribes to the same \emph{topic}.
Generally, each topic only accepts messages of one type.
\tool{\ac{ROS}} makes it easy to query a running system to find out information
such as (a) the topics in that system; (b) the type of messages published to each
topic; (c) the node or nodes that publish to a particular topic; and (d) the node
or nodes that subscribe to the particular topic.
This information makes it easy to infer certain properties about the relationships
among nodes and the purposes of particular messages.
We use this information to choose the topics to which we add artificial delays.
\todo{Add more specifics about examples of topics we delay.}

Once we set a \tool{topic} or \tool{topics} to delay on a particular \tool{\ac{ROS}}
system for a particular set of experiments, we insert delays on these topics by
intercepting messages using topic renaming. \todo{Elaborate on how to use topic renaming for delay insertion}. 
Delays ranged in length from \todo{X} to \todo{Y} and were inserted for every message 
in a topic. \todo{If I decide to do this probabilistically too, insert discussion of 
probabilistic choices.}

\subsection{Metrics}
\label{sec:timing-methodology-metrics}
To evaluate the research questions, I make use of the following metrics.

\begin{itemize}

\item Whether each execution executes each waypoint and returns home
\item Euclidean distance metrics: these metrics are based on the position in 3d space of the deformed execution versus the nominal executions.
\begin{itemize}

\item the Euclidean distance between the final position of the robot in the representative nominal and each deformed execution
\item given aligned time series between the representative nominal execution and each deformed execution, the greatest and the average Euclidean difference between each position on the path
\item based on the closest distance from each waypoint
\begin{itemize}

\item the sum of closest distances from each waypoint
\item the average of the closest distances from each waypoint
\item the greatest closest distance from each waypoint
\end{itemize}


\end{itemize}
\item Timeliness metrics
\begin{itemize}

\item The amount of time before completion (either successfully or unsuccessfully)
\item Total amount of time taken to reach each waypoint (`reach' defined as when the system issues the instruction to go to the next waypoint)
\end{itemize}

\end{itemize}


To determine a representative nominal execution, I take the medoid of the time series representing the 3-dimensional positions of the robot in all nominal executions of a particular mission (without artificial delays).

\subsection{Research Questions}
\label{sec:timing-research-questions}
I evaluate the following research questions.
\begin{description}
\item[\textbf{RQ1:}] To what extent do the presence of timing delays in robot systems have an effect on observable behavior as defined by a set of performance metrics?
\item[\textbf{RQ2:}] Are certain kinds of robotics components more robust or resilient to timing delays?
\item[\textbf{RQ3:}]  Are certain robotics systems more robust or resilient to timing delays?
\item[\textbf{RQ4:}] Under what circumstances do timing delays lead to system crashes?
\end{description}

\paragraph{Effects on Observable Behavior}
\label{sec:timing-methodology-RQ-observable}

To evaluate RQ1, To what extent do the presence of timing delays in robot systems have an effect on observable behavior as defined by a set of performance metrics, I look at the metrics enumerated in Section~\ref{sec:timing-methodology-metrics}.

The clearest and most obvious effects on observable execution are crashes, both software crashes and crashes in physical space.
I evaluate these deviations separately in RQ4 (Section~\ref{sec:timing-methodology-RQ-crash}).

\paragraph{Different Effects on Different Components}

To evaluate RQ2, Are certain kinds of robotics components more robust or resilient to timing delays, 
I conduct separate experiments in which I insert delays that affect different 
components. 
For example, on \tool{ROS} systems, different experiments have delays on different 
\tool{rostopics}. 
A \tool{rostopic} conveys messages to the nodes that subscribe to it. 
When I delay the messages on a particular \tool{rostopic}, those delays affect the 
nodes that subscribe to that topic. 
By delaying different topics separately, I can evaluate the different effects on the subscriber nodes. 
In \tool{ArduPilot}, I achieve a similar effect by conducting separate experiments with timing delays inserted into a single source file of the \tool{ArduCopter} code at a time.

\paragraph{•}

\paragraph{When Delays Cause Software Crashes}
\label{sec:timing-methodology-RQ-crash}

\section*{Acknowledgments}

\todo{add acknowledgements}


\bibliographystyle{IEEEtran}
\bibliography{dsk_ref}
\end{document}
