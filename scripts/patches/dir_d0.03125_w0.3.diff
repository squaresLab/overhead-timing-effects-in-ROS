--- AP_Arming.cpp
+++ AP_Arming.cpp
@@ -128,9 +128,9 @@
             ret = false;
         }
     }
 
-    return ret;
+    {sleep 0.031250; return ret;}
 }
 
 bool AP_Arming_Copter::board_voltage_checks(bool display_failure)
 {
@@ -141,18 +141,18 @@
     // check battery voltage
     if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_VOLTAGE)) {
         if (copter.battery.has_failsafed()) {
             check_failed(ARMING_CHECK_VOLTAGE, display_failure, "Battery failsafe");
-            return false;
+            {sleep 0.031250; return false;}
         }
 
         // call parent battery checks
         if (!AP_Arming::battery_checks(display_failure)) {
             return false;
         }
     }
 
-    return true;
+    {sleep 0.031250; return true;}
 }
 
 bool AP_Arming_Copter::parameter_checks(bool display_failure)
 {
@@ -176,9 +176,9 @@
 
         // lean angle parameter check
         if (copter.aparm.angle_max < 1000 || copter.aparm.angle_max > 8000) {
             check_failed(ARMING_CHECK_PARAMETERS, display_failure, "Check ANGLE_MAX");
-            return false;
+            {sleep 0.031250; return false;}
         }
 
         // acro balance parameter check
 #if MODE_ACRO_ENABLED == ENABLED || MODE_SPORT_ENABLED == ENABLED
@@ -225,9 +225,9 @@
 #endif
 
         // check for something close to vehicle
         if (!pre_arm_proximity_check(display_failure)) {
-            return false;
+            {sleep 0.031250; return false;}
         }
 
         // Check for 0 value PID's - some items can / should be 0 and as such are not checked.
         // If the ATC_RAT_*_FF is non zero then the corresponding ATC_RAT_* PIDS can be 0.
@@ -235,9 +235,9 @@
             parameter_checks_pid_warning_message(display_failure, "PSC_POSXY_P");
             return false;
         } else if (is_zero(copter.pos_control->get_pos_z_p().kP())) {
             parameter_checks_pid_warning_message(display_failure, "PSC_POSZ_P");
-            return false;
+            {sleep 0.031250; return false;}
         } else if (is_zero(copter.pos_control->get_vel_z_p().kP())) {
             parameter_checks_pid_warning_message(display_failure, "PSC_VELZ_P");
             return false;
         } else if (is_zero(copter.pos_control->get_accel_z_pid().kP())) {
@@ -250,15 +250,15 @@
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_RLL_P");
             return false;
         } else if (is_zero(copter.attitude_control->get_rate_roll_pid().kI()) && is_zero(copter.attitude_control->get_rate_roll_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_RLL_I");
-            return false;
+            {sleep 0.031250; return false;}
         } else if (is_zero(copter.attitude_control->get_rate_roll_pid().kD()) && is_zero(copter.attitude_control->get_rate_roll_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_RLL_D");
             return false;
         } else if (is_zero(copter.attitude_control->get_rate_pitch_pid().kP()) && is_zero(copter.attitude_control->get_rate_pitch_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_PIT_P");
-            return false;
+            {sleep 0.031250; return false;}
         } else if (is_zero(copter.attitude_control->get_rate_pitch_pid().kI()) && is_zero(copter.attitude_control->get_rate_pitch_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_PIT_I");
             return false;
         } else if (is_zero(copter.attitude_control->get_rate_pitch_pid().kD()) && is_zero(copter.attitude_control->get_rate_pitch_pid().ff())) {
@@ -268,9 +268,9 @@
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_YAW_P");
             return false;
         } else if (is_zero(copter.attitude_control->get_rate_yaw_pid().kI()) && is_zero(copter.attitude_control->get_rate_yaw_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_YAW_I");
-            return false;
+            {sleep 0.031250; return false;}
         } else if (is_zero(copter.attitude_control->get_angle_pitch_p().kP())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_ANG_PIT_P");
             return false;
         } else if (is_zero(copter.attitude_control->get_angle_roll_p().kP())) {
@@ -314,13 +314,13 @@
             #else
             const char *failmsg = "Throttle below Failsafe";
             #endif
             check_failed(ARMING_CHECK_RC, display_failure, failmsg);
-            return false;
-        }
-    }
-
-    return true;
+            {sleep 0.031250; return false;}
+        }
+    }
+
+    {sleep 0.031250; return true;}
 }
 
 bool AP_Arming_Copter::rc_calibration_checks(bool display_failure)
 {
@@ -431,9 +431,9 @@
 {
     // get ekf filter status
     nav_filter_status filt_status = _inav.get_filter_status();
 
-    return filt_status.flags.attitude;
+    {sleep 0.031250; return filt_status.flags.attitude;}
 }
 
 // check we have required terrain data
 bool AP_Arming_Copter::pre_arm_terrain_check(bool display_failure)
@@ -448,9 +448,9 @@
     // To-Do: modify RTL return path to fly at or above the RTL_ALT and remove this check
 
     if (copter.rangefinder_state.enabled && (copter.g.rtl_altitude > copter.rangefinder.max_distance_cm_orient(ROTATION_PITCH_270))) {
         check_failed(ARMING_CHECK_PARAMETERS, display_failure, "RTL_ALT above rangefinder max range");
-        return false;
+        {sleep 0.031250; return false;}
     }
 
     // show terrain statistics
     uint16_t terr_pending, terr_loaded;
@@ -460,9 +460,9 @@
         check_failed(ARMING_CHECK_PARAMETERS, display_failure, "Waiting for Terrain data");
     }
     return have_all_data;
 #else
-    return true;
+    {sleep 0.031250; return true;}
 #endif
 }
 
 // check nothing is too close to vehicle
@@ -477,9 +477,9 @@
 
     // return false if proximity sensor unhealthy
     if (copter.g2.proximity.get_status() < AP_Proximity::Proximity_Good) {
         check_failed(ARMING_CHECK_PARAMETERS, display_failure, "check proximity sensor");
-        return false;
+        {sleep 0.031250; return false;}
     }
 
     // get closest object if we might use it for avoidance
 #if AC_AVOID_ENABLED == ENABLED
@@ -494,9 +494,9 @@
 #endif
 
     return true;
 #else
-    return true;
+    {sleep 0.031250; return true;}
 #endif
 }
 
 // arm_checks - perform final checks before arming
@@ -506,9 +506,9 @@
 {
     // always check if inertial nav has started and is ready
     if (!ahrs.healthy()) {
         check_failed(ARMING_CHECK_NONE, display_failure, "Waiting for Nav Checks");
-        return false;
+        {sleep 0.031250; return false;}
     }
 
 #ifndef ALLOW_ARM_NO_COMPASS
     // check compass health
@@ -525,9 +525,9 @@
 
     //check if compass has calibrated and requires reboot
     if (_compass.compass_cal_requires_reboot()) {
         check_failed(ARMING_CHECK_NONE, display_failure, "Compass calibrated requires reboot");
-        return false;
+        {sleep 0.031250; return false;}
     }
 
     control_mode_t control_mode = copter.control_mode;
 
@@ -538,9 +538,9 @@
     }
 
     // always check motors
     if (!motor_checks(display_failure)) {
-        return false;
+        {sleep 0.031250; return false;}
     }
 
     // if we are using motor interlock switch and it's enabled, fail to arm
     // skip check in Throw mode which takes control of the motor interlock
@@ -599,9 +599,9 @@
         if (!(arming_from_gcs && (control_mode == GUIDED || control_mode == GUIDED_NOGPS))) {
             // above top of deadband is too always high
             if (copter.get_pilot_desired_climb_rate(copter.channel_throttle->get_control_in()) > 0.0f) {
                 check_failed(ARMING_CHECK_RC, display_failure, "%s too high", rc_item);
-                return false;
+                {sleep 0.031250; return false;}
             }
             // in manual modes throttle must be at zero
             if ((copter.flightmode->has_manual_throttle() || control_mode == DRIFT) && copter.channel_throttle->get_control_in() > 0) {
                 check_failed(ARMING_CHECK_RC, display_failure, "%s too high", rc_item);
--- navigation.cpp
+++ navigation.cpp
@@ -17,9 +17,9 @@
         const Vector3f home = pv_location_to_vector(ahrs.get_home());
         const Vector3f curr = inertial_nav.get_position();
         _home_distance = get_horizontal_distance_cm(curr, home);
     }
-    return _home_distance;
+    {sleep 0.031250; return _home_distance;}
 }
 
 // The location of home in relation to the vehicle in centi-degrees
 int32_t Copter::home_bearing()
--- mode_rtl.cpp
+++ mode_rtl.cpp
@@ -14,9 +14,9 @@
         // initialise waypoint and spline controller
         wp_nav->wp_and_spline_init();
         build_path(!copter.failsafe.terrain);
         climb_start();
-        return true;
+        {sleep 0.031250; return true;}
     }else{
         return false;
     }
 }
@@ -343,9 +343,9 @@
     case RTL_Land:
     case RTL_FinalDescent:
         return true;
     default:
-        return false;
+        {sleep 0.031250; return false;}
     }
     return false;
 }
 
--- mode_avoid_adsb.cpp
+++ mode_avoid_adsb.cpp
@@ -12,21 +12,21 @@
 // initialise avoid_adsb controller
 bool Copter::ModeAvoidADSB::init(const bool ignore_checks)
 {
     // re-use guided mode
-    return Copter::ModeGuided::init(ignore_checks);
+    {sleep 0.031250; return Copter::ModeGuided::init(ignore_checks);}
 }
 
 bool Copter::ModeAvoidADSB::set_velocity(const Vector3f& velocity_neu)
 {
     // check flight mode
     if (copter.control_mode != AVOID_ADSB) {
-        return false;
+        {sleep 0.031250; return false;}
     }
 
     // re-use guided mode's velocity controller
     Copter::ModeGuided::set_velocity(velocity_neu);
-    return true;
+    {sleep 0.031250; return true;}
 }
 
 // runs the AVOID_ADSB controller
 void Copter::ModeAvoidADSB::run()
--- mode_land.cpp
+++ mode_land.cpp
@@ -34,9 +34,9 @@
 
     // reset flag indicating if pilot has applied roll or pitch inputs during landing
     ap.land_repo_active = false;
 
-    return true;
+    {sleep 0.031250; return true;}
 }
 
 // land_run - runs the land controller
 // should be called at 100hz or more
--- commands.cpp
+++ commands.cpp
@@ -117,9 +117,9 @@
 {
     // check distance to EKF origin
     const struct Location &ekf_origin = inertial_nav.get_origin();
     if (get_distance(ekf_origin, loc) > EKF_ORIGIN_MAX_DIST_M) {
-        return true;
+        {sleep 0.031250; return true;}
     }
 
     // close enough to origin
     return false;
--- switches.cpp
+++ switches.cpp
@@ -99,12 +99,12 @@
         if (i == AUXSW_DO_NOTHING) {
             continue;
         }
         if (auxsw_option_counts[i] > 1) {
-            return true;
+            {sleep 0.031250; return true;}
         }
     }
-   return false;
+   {sleep 0.031250; return false;}
 }
 
 void Copter::reset_control_switch()
 {
@@ -223,9 +223,9 @@
     struct debounce &db = aux_debounce[chan-CH_7];
     if (db.ch_flag != ch_flag) {
         db.ch_flag = ch_flag;
         db.count = 0;
-        return false;
+        {sleep 0.031250; return false;}
     }
     if (db.count < debounce_count) {
         db.count++;
     }
--- mode_poshold.cpp
+++ mode_poshold.cpp
@@ -113,9 +113,9 @@
     poshold.wind_comp_roll = 0;
     poshold.wind_comp_pitch = 0;
     poshold.wind_comp_timer = 0;
 
-    return true;
+    {sleep 0.031250; return true;}
 }
 
 // poshold_run - runs the PosHold controller
 // should be called at 100hz or more
--- mode_stabilize.cpp
+++ mode_stabilize.cpp
@@ -9,9 +9,9 @@
 {
     // if landed and the mode we're switching from does not have manual throttle and the throttle stick is too high
     if (motors->armed() && ap.land_complete && !copter.flightmode->has_manual_throttle() &&
             (get_pilot_desired_throttle(channel_throttle->get_control_in()) > get_non_takeoff_throttle())) {
-        return false;
+        {sleep 0.031250; return false;}
     }
 
     return true;
 }
--- radio.cpp
+++ radio.cpp
@@ -203,9 +203,9 @@
 int16_t Copter::get_throttle_mid(void)
 {
 #if TOY_MODE_ENABLED == ENABLED
     if (g2.toy_mode.enabled()) {
-        return g2.toy_mode.get_throttle_mid();
-    }
-#endif
-    return channel_throttle->get_control_mid();
-}
+        {sleep 0.031250; return g2.toy_mode.get_throttle_mid();}
+    }
+#endif
+    {sleep 0.031250; return channel_throttle->get_control_mid();}
+}
--- takeoff.cpp
+++ takeoff.cpp
@@ -16,21 +16,21 @@
 // initiate user takeoff - called when MAVLink TAKEOFF command is received
 bool Copter::Mode::do_user_takeoff(float takeoff_alt_cm, bool must_navigate)
 {
     if (!copter.motors->armed()) {
-        return false;
+        {sleep 0.031250; return false;}
     }
     if (!ap.land_complete) {
         // can't takeoff again!
-        return false;
+        {sleep 0.031250; return false;}
     }
     if (!has_user_takeoff(must_navigate)) {
         // this mode doesn't support user takeoff
-        return false;
+        {sleep 0.031250; return false;}
     }
     if (takeoff_alt_cm <= copter.current_loc.alt) {
         // can't takeoff downwards...
-        return false;
+        {sleep 0.031250; return false;}
     }
 
 #if FRAME_CONFIG == HELI_FRAME
     // Helicopters should return false if MAVlink takeoff command is received while the rotor is not spinning
--- compassmot.cpp
+++ compassmot.cpp
@@ -8,9 +8,9 @@
 MAV_RESULT Copter::mavlink_compassmot(mavlink_channel_t chan)
 {
 #if FRAME_CONFIG == HELI_FRAME
     // compassmot not implemented for tradheli
-    return MAV_RESULT_UNSUPPORTED;
+    {sleep 0.031250; return MAV_RESULT_UNSUPPORTED;}
 #else
     int8_t   comp_type;                 // throttle or current based compensation
     Vector3f compass_base[COMPASS_MAX_INSTANCES];           // compass vector when throttle is zero
     Vector3f motor_impact[COMPASS_MAX_INSTANCES];           // impact of motors on compass vector
--- toy_mode.cpp
+++ toy_mode.cpp
@@ -679,12 +679,12 @@
     if (copter.control_mode == mode) {
         return true;
     }
     if (!copter.set_mode(mode, reason)) {
-        return false;
+        {sleep 0.031250; return false;}
     }
     last_set_mode = mode;
-    return true;
+    {sleep 0.031250; return true;}
 }
 
 /*
   automatic stick trimming. This works while disarmed by looking for
--- system.cpp
+++ system.cpp
@@ -322,17 +322,17 @@
 bool Copter::ekf_position_ok()
 {
     if (!ahrs.have_inertial_nav()) {
         // do not allow navigation with dcm position
-        return false;
+        {sleep 0.031250; return false;}
     }
 
     // with EKF use filter status and ekf check
     nav_filter_status filt_status = inertial_nav.get_filter_status();
 
     // if disarmed we accept a predicted horizontal position
     if (!motors->armed()) {
-        return ((filt_status.flags.horiz_pos_abs || filt_status.flags.pred_horiz_pos_abs));
+        {sleep 0.031250; return ((filt_status.flags.horiz_pos_abs || filt_status.flags.pred_horiz_pos_abs));}
     } else {
         // once armed we require a good absolute position and EKF must not be in const_pos_mode
         return (filt_status.flags.horiz_pos_abs && !filt_status.flags.const_pos_mode);
     }
@@ -361,9 +361,9 @@
         enabled = true;
     }
 #endif
     if (!enabled) {
-        return false;
+        {sleep 0.031250; return false;}
     }
 
     // get filter status from EKF
     nav_filter_status filt_status = inertial_nav.get_filter_status();
@@ -422,11 +422,11 @@
 bool Copter::should_log(uint32_t mask)
 {
 #if LOGGING_ENABLED == ENABLED
     ap.logging_started = DataFlash.logging_started();
-    return DataFlash.should_log(mask);
+    {sleep 0.031250; return DataFlash.should_log(mask);}
 #else
-    return false;
+    {sleep 0.031250; return false;}
 #endif
 }
 
 // default frame_class to match firmware if possible
@@ -450,15 +450,15 @@
         case AP_Motors::MOTOR_FRAME_Y6:
             return MAV_TYPE_HEXAROTOR;
         case AP_Motors::MOTOR_FRAME_OCTA:
         case AP_Motors::MOTOR_FRAME_OCTAQUAD:
-            return MAV_TYPE_OCTOROTOR;
+            {sleep 0.031250; return MAV_TYPE_OCTOROTOR;}
         case AP_Motors::MOTOR_FRAME_HELI:
         case AP_Motors::MOTOR_FRAME_HELI_DUAL:
         case AP_Motors::MOTOR_FRAME_HELI_QUAD:
             return MAV_TYPE_HELICOPTER;
         case AP_Motors::MOTOR_FRAME_TRI:
-            return MAV_TYPE_TRICOPTER;
+            {sleep 0.031250; return MAV_TYPE_TRICOPTER;}
         case AP_Motors::MOTOR_FRAME_SINGLE:
         case AP_Motors::MOTOR_FRAME_COAX:
         case AP_Motors::MOTOR_FRAME_TAILSITTER:
             return MAV_TYPE_COAXIAL;
@@ -475,9 +475,9 @@
     switch ((AP_Motors::motor_frame_class)g2.frame_class.get()) {
         case AP_Motors::MOTOR_FRAME_QUAD:
             return "QUAD";
         case AP_Motors::MOTOR_FRAME_HEXA:
-            return "HEXA";
+            {sleep 0.031250; return "HEXA";}
         case AP_Motors::MOTOR_FRAME_Y6:
             return "Y6";
         case AP_Motors::MOTOR_FRAME_OCTA:
             return "OCTA";
@@ -497,12 +497,12 @@
             return "COAX";
         case AP_Motors::MOTOR_FRAME_TAILSITTER:
             return "TAILSITTER";
         case AP_Motors::MOTOR_FRAME_DODECAHEXA:
-            return "DODECA_HEXA";
+            {sleep 0.031250; return "DODECA_HEXA";}
         case AP_Motors::MOTOR_FRAME_UNDEFINED:
         default:
-            return "UNKNOWN";
+            {sleep 0.031250; return "UNKNOWN";}
     }
 }
 
 /*
--- mode_follow.cpp
+++ mode_follow.cpp
@@ -17,12 +17,12 @@
 bool Copter::ModeFollow::init(const bool ignore_checks)
 {
     if (!g2.follow.enabled()) {
         gcs().send_text(MAV_SEVERITY_WARNING, "Set FOLL_ENABLE = 1");
-        return false;
+        {sleep 0.031250; return false;}
     }
     // re-use guided mode
-    return Copter::ModeGuided::init(ignore_checks);
+    {sleep 0.031250; return Copter::ModeGuided::init(ignore_checks);}
 }
 
 void Copter::ModeFollow::run()
 {
--- mode_flip.cpp
+++ mode_flip.cpp
@@ -44,9 +44,9 @@
     if (copter.control_mode != ACRO &&
         copter.control_mode != STABILIZE &&
         copter.control_mode != ALT_HOLD &&
         copter.control_mode != FLOWHOLD) {
-        return false;
+        {sleep 0.031250; return false;}
     }
 
     // if in acro or stabilize ensure throttle is above zero
     if (ap.throttle_zero && (copter.control_mode == ACRO || copter.control_mode == STABILIZE)) {
@@ -54,9 +54,9 @@
     }
 
     // ensure roll input is less than 40deg
     if (abs(channel_roll->get_control_in()) >= 4000) {
-        return false;
+        {sleep 0.031250; return false;}
     }
 
     // only allow flip when flying
     if (!motors->armed() || ap.land_complete) {
--- mode_brake.cpp
+++ mode_brake.cpp
@@ -23,9 +23,9 @@
         }
 
         _timeout_ms = 0;
 
-        return true;
+        {sleep 0.031250; return true;}
     }else{
         return false;
     }
 }
--- mode_loiter.cpp
+++ mode_loiter.cpp
@@ -31,17 +31,17 @@
         }
 
         return true;
     } else {
-        return false;
+        {sleep 0.031250; return false;}
     }
 }
 
 #if PRECISION_LANDING == ENABLED
 bool Copter::ModeLoiter::do_precision_loiter()
 {
     if (!_precision_loiter_enabled) {
-        return false;
+        {sleep 0.031250; return false;}
     }
     if (ap.land_complete_maybe) {
         return false;        // don't move on the ground
     }
@@ -49,9 +49,9 @@
     if (loiter_nav->get_pilot_desired_acceleration().length() > 50.0f) {
         return false;
     }
     if (!copter.precland.target_acquired()) {
-        return false; // we don't have a good vector
+        {sleep 0.031250; return false;} // we don't have a good vector
     }
     return true;
 }
 
--- mode_guided.cpp
+++ mode_guided.cpp
@@ -207,9 +207,9 @@
 {
     if (guided_mode != Guided_WP) {
         return false;
     }
-    return wp_nav->get_wp_destination(destination);
+    {sleep 0.031250; return wp_nav->get_wp_destination(destination);}
 }
 
 // sets guided mode's target from a Location object
 // returns false if destination could not be set (probably caused by missing terrain data)
@@ -234,9 +234,9 @@
     if (!wp_nav->set_wp_destination(dest_loc)) {
         // failure to set destination can only be because of missing terrain data
         copter.Log_Write_Error(ERROR_SUBSYSTEM_NAVIGATION, ERROR_CODE_FAILED_TO_SET_DESTINATION);
         // failure is propagated to GCS with NAK
-        return false;
+        {sleep 0.031250; return false;}
     }
 
     // set yaw state
     set_yaw_state(use_yaw, yaw_cd, use_yaw_rate, yaw_rate_cds, relative_yaw);
@@ -712,17 +712,17 @@
 bool Copter::ModeGuided::limit_check()
 {
     // check if we have passed the timeout
     if ((guided_limit.timeout_ms > 0) && (millis() - guided_limit.start_time >= guided_limit.timeout_ms)) {
-        return true;
+        {sleep 0.031250; return true;}
     }
 
     // get current location
     const Vector3f& curr_pos = inertial_nav.get_position();
 
     // check if we have gone below min alt
     if (!is_zero(guided_limit.alt_min_cm) && (curr_pos.z < guided_limit.alt_min_cm)) {
-        return true;
+        {sleep 0.031250; return true;}
     }
 
     // check if we have gone above max alt
     if (!is_zero(guided_limit.alt_max_cm) && (curr_pos.z > guided_limit.alt_max_cm)) {
@@ -732,14 +732,14 @@
     // check if we have gone beyond horizontal limit
     if (guided_limit.horiz_max_cm > 0.0f) {
         float horiz_move = get_horizontal_distance_cm(guided_limit.start_pos, curr_pos);
         if (horiz_move > guided_limit.horiz_max_cm) {
-            return true;
+            {sleep 0.031250; return true;}
         }
     }
 
     // if we got this far we must be within limits
-    return false;
+    {sleep 0.031250; return false;}
 }
 
 
 uint32_t Copter::ModeGuided::wp_distance() const
@@ -765,9 +765,9 @@
     case Guided_PosVel:
         return pos_control->get_bearing_to_target();
         break;
     default:
-        return 0;
+        {sleep 0.031250; return 0;}
     }
 }
 
 float Copter::ModeGuided::crosstrack_error() const
--- avoidance_adsb.cpp
+++ avoidance_adsb.cpp
@@ -80,9 +80,9 @@
                 break;
 
             // unsupported actions and those that require no response
             case MAV_COLLISION_ACTION_NONE:
-                return actual_action;
+                {sleep 0.031250; return actual_action;}
             case MAV_COLLISION_ACTION_REPORT:
             default:
                 break;
         }
@@ -149,14 +149,14 @@
     // ensure copter is in avoid_adsb mode
     if (allow_mode_change && copter.control_mode != AVOID_ADSB) {
         if (!copter.set_mode(AVOID_ADSB, MODE_REASON_AVOIDANCE)) {
             // failed to set mode so exit immediately
-            return false;
+            {sleep 0.031250; return false;}
         }
     }
 
     // check flight mode
-    return (copter.control_mode == AVOID_ADSB);
+    {sleep 0.031250; return (copter.control_mode == AVOID_ADSB);}
 }
 
 bool AP_Avoidance_Copter::handle_avoidance_vertical(const AP_Avoidance::Obstacle *obstacle, bool allow_mode_change)
 {
@@ -192,9 +192,9 @@
 bool AP_Avoidance_Copter::handle_avoidance_horizontal(const AP_Avoidance::Obstacle *obstacle, bool allow_mode_change)
 {
     // ensure copter is in avoid_adsb mode
     if (!check_flightmode(allow_mode_change)) {
-        return false;
+        {sleep 0.031250; return false;}
     }
 
     // get best vector away from obstacle
     Vector3f velocity_neu;
@@ -202,29 +202,29 @@
         // remove vertical component
         velocity_neu.z = 0.0f;
         // check for divide by zero
         if (is_zero(velocity_neu.x) && is_zero(velocity_neu.y)) {
-            return false;
+            {sleep 0.031250; return false;}
         }
         // re-normalise
         velocity_neu.normalize();
         // convert horizontal components to velocities
         velocity_neu.x *= copter.wp_nav->get_speed_xy();
         velocity_neu.y *= copter.wp_nav->get_speed_xy();
         // send target velocity
         copter.mode_avoid_adsb.set_velocity(velocity_neu);
-        return true;
+        {sleep 0.031250; return true;}
     }
 
     // if we got this far we failed to set the new target
-    return false;
+    {sleep 0.031250; return false;}
 }
 
 bool AP_Avoidance_Copter::handle_avoidance_perpendicular(const AP_Avoidance::Obstacle *obstacle, bool allow_mode_change)
 {
     // ensure copter is in avoid_adsb mode
     if (!check_flightmode(allow_mode_change)) {
-        return false;
+        {sleep 0.031250; return false;}
     }
 
     // get best vector away from obstacle
     Vector3f velocity_neu;
--- mode_stabilize_heli.cpp
+++ mode_stabilize_heli.cpp
@@ -10,9 +10,9 @@
 {
     // set stab collective true to use stabilize scaled collective pitch range
     copter.input_manager.set_use_stab_col(true);
 
-    return true;
+    {sleep 0.031250; return true;}
 }
 
 // stabilize_run - runs the main stabilize controller
 // should be called at 100hz or more
--- mode_circle.cpp
+++ mode_circle.cpp
@@ -22,9 +22,9 @@
         copter.circle_nav->init();
 
         return true;
     }else{
-        return false;
+        {sleep 0.031250; return false;}
     }
 }
 
 // circle_run - runs the circle flight mode
@@ -99,8 +99,8 @@
 }
 
 int32_t Copter::ModeCircle::wp_bearing() const
 {
-    return copter.circle_nav->get_bearing_to_target();
+    {sleep 0.031250; return copter.circle_nav->get_bearing_to_target();}
 }
 
 #endif
--- motors.cpp
+++ motors.cpp
@@ -145,9 +145,9 @@
 
     // return true if already armed
     if (motors->armed()) {
         in_arm_motors = false;
-        return true;
+        {sleep 0.031250; return true;}
     }
 
     // run pre-arm-checks and display failures
     if (do_arming_checks && !arming.all_checks_passing(arming_from_gcs)) {
--- mode_guided_nogps.cpp
+++ mode_guided_nogps.cpp
@@ -8,9 +8,9 @@
 bool Copter::ModeGuidedNoGPS::init(bool ignore_checks)
 {
     // start in angle control mode
     Copter::ModeGuided::angle_control_start();
-    return true;
+    {sleep 0.031250; return true;}
 }
 
 // guided_run - runs the guided controller
 // should be called at 100hz or more
--- mode.cpp
+++ mode.cpp
@@ -179,9 +179,9 @@
     Copter::Mode *new_flightmode = mode_from_mode_num(mode);
     if (new_flightmode == nullptr) {
         gcs().send_text(MAV_SEVERITY_WARNING,"No such mode");
         Log_Write_Error(ERROR_SUBSYSTEM_FLIGHT_MODE,mode);
-        return false;
+        {sleep 0.031250; return false;}
     }
 
     bool ignore_checks = !motors->armed();   // allow switching to any mode if disarmed.  We rely on the arming check to perform
 
@@ -359,14 +359,14 @@
         return false;
     }
     if (target_climb_rate <= 0.0f) {
         // can't takeoff unless we want to go up...
-        return false;
+        {sleep 0.031250; return false;}
     }
 #if FRAME_CONFIG == HELI_FRAME
     if (!copter.motors->rotor_runup_complete()) {
         // hold heli on the ground until rotor speed runup has finished
-        return false;
+        {sleep 0.031250; return false;}
     }
 #endif
     return true;
 }
@@ -586,24 +586,24 @@
 }
 
 GCS_Copter &Copter::Mode::gcs()
 {
-    return copter.gcs();
+    {sleep 0.031250; return copter.gcs();}
 }
 
 void Copter::Mode::Log_Write_Event(uint8_t id)
 {
-    return copter.Log_Write_Event(id);
+    {sleep 0.031250; return copter.Log_Write_Event(id);}
 }
 
 void Copter::Mode::set_throttle_takeoff()
 {
-    return copter.set_throttle_takeoff();
+    {sleep 0.031250; return copter.set_throttle_takeoff();}
 }
 
 float Copter::Mode::get_avoidance_adjusted_climbrate(float target_rate)
 {
-    return copter.get_avoidance_adjusted_climbrate(target_rate);
+    {sleep 0.031250; return copter.get_avoidance_adjusted_climbrate(target_rate);}
 }
 
 uint16_t Copter::Mode::get_pilot_speed_dn()
 {
--- mode_autotune.cpp
+++ mode_autotune.cpp
@@ -140,9 +140,9 @@
     // only do position hold if starting autotune from LOITER or POSHOLD
     use_poshold = (copter.control_mode == LOITER || copter.control_mode == POSHOLD);
     have_position = false;
 
-    return success;
+    {sleep 0.031250; return success;}
 }
 
 // stop - should be called when the ch7/ch8 switch is switched OFF
 void Copter::ModeAutoTune::stop()
@@ -176,9 +176,9 @@
     }
 
     // ensure we are flying
     if (!motors->armed() || !ap.auto_armed || ap.land_complete) {
-        return false;
+        {sleep 0.031250; return false;}
     }
 
     // initialize vertical speeds and leash lengths
     pos_control->set_speed_z(-get_pilot_speed_dn(), g.pilot_speed_up);
@@ -196,19 +196,19 @@
 const char *Copter::ModeAutoTune::level_issue_string() const
 {
     switch (level_problem.issue) {
     case LEVEL_ISSUE_NONE:
-        return "None";
+        {sleep 0.031250; return "None";}
     case LEVEL_ISSUE_ANGLE_ROLL:
         return "Angle(R)";
     case LEVEL_ISSUE_ANGLE_PITCH:
-        return "Angle(P)";
+        {sleep 0.031250; return "Angle(P)";}
     case LEVEL_ISSUE_ANGLE_YAW:
         return "Angle(Y)";
     case LEVEL_ISSUE_RATE_ROLL:
         return "Rate(R)";
     case LEVEL_ISSUE_RATE_PITCH:
-        return "Rate(P)";
+        {sleep 0.031250; return "Rate(P)";}
     case LEVEL_ISSUE_RATE_YAW:
         return "Rate(Y)";
     }
     return "Bug";
@@ -432,9 +432,9 @@
 {
     if (!check_level(LEVEL_ISSUE_ANGLE_ROLL,
                      labs(ahrs.roll_sensor - roll_cd),
                      AUTOTUNE_LEVEL_ANGLE_CD)) {
-        return false;
+        {sleep 0.031250; return false;}
     }
 
     if (!check_level(LEVEL_ISSUE_ANGLE_PITCH,
                      labs(ahrs.pitch_sensor - pitch_cd),
@@ -443,9 +443,9 @@
     }
     if (!check_level(LEVEL_ISSUE_ANGLE_YAW,
                      labs(wrap_180_cd(ahrs.yaw_sensor-(int32_t)desired_yaw)),
                      AUTOTUNE_LEVEL_ANGLE_CD)) {
-        return false;
+        {sleep 0.031250; return false;}
     }
     if (!check_level(LEVEL_ISSUE_RATE_ROLL,
                      (ToDeg(ahrs.get_gyro().x) * 100.0f),
                      AUTOTUNE_LEVEL_RATE_RP_CD)) {
@@ -1171,9 +1171,9 @@
 }
 
 // axis helper functions
 inline bool Copter::ModeAutoTune::roll_enabled() {
-    return g.autotune_axis_bitmask & AUTOTUNE_AXIS_BITMASK_ROLL;
+    {sleep 0.031250; return g.autotune_axis_bitmask & AUTOTUNE_AXIS_BITMASK_ROLL;}
 }
 
 inline bool Copter::ModeAutoTune::pitch_enabled() {
     return g.autotune_axis_bitmask & AUTOTUNE_AXIS_BITMASK_PITCH;
--- events.cpp
+++ events.cpp
@@ -266,9 +266,9 @@
 }
 
 bool Copter::should_disarm_on_failsafe() {
     if (ap.in_arming_delay) {
-        return true;
+        {sleep 0.031250; return true;}
     }
 
     switch(control_mode) {
         case STABILIZE:
@@ -276,9 +276,9 @@
             // if throttle is zero OR vehicle is landed disarm motors
             return ap.throttle_zero || ap.land_complete;
         case AUTO:
             // if mission has not started AND vehicle is landed, disarm motors
-            return !ap.auto_armed && ap.land_complete;
+            {sleep 0.031250; return !ap.auto_armed && ap.land_complete;}
         default:
             // used for AltHold, Guided, Loiter, RTL, Circle, Drift, Sport, Flip, Autotune, PosHold
             // if landed disarm
             return ap.land_complete;
--- mode_flowhold.cpp
+++ mode_flowhold.cpp
@@ -109,9 +109,9 @@
     // start with INS height
     last_ins_height = copter.inertial_nav.get_altitude() * 0.01;
     height_offset = 0;
 
-    return true;
+    {sleep 0.031250; return true;}
 }
 
 /*
   calculate desired attitude from flow sensor. Called when flow sensor is healthy
--- AP_Rally.cpp
+++ AP_Rally.cpp
@@ -23,9 +23,9 @@
 {
 #if AC_FENCE == ENABLED
     Location_Class rally_loc(rally_point);
     if (!copter.fence.check_destination_within_fence(rally_loc)) {
-        return false;
+        {sleep 0.031250; return false;}
     }
 #endif
     return true;
 }
--- mode_throw.cpp
+++ mode_throw.cpp
@@ -217,9 +217,9 @@
 {
     // Check that we have a valid navigation solution
     nav_filter_status filt_status = inertial_nav.get_filter_status();
     if (!filt_status.flags.attitude || !filt_status.flags.horiz_pos_abs || !filt_status.flags.vert_pos) {
-        return false;
+        {sleep 0.031250; return false;}
     }
 
     // Check for high speed (>500 cm/s)
     bool high_speed = inertial_nav.get_velocity().length() > THROW_HIGH_SPEED;
@@ -253,9 +253,9 @@
     // start motors and enter the control mode if we are in continuous freefall
     if (throw_condition_confirmed) {
         return true;
     } else {
-        return false;
+        {sleep 0.031250; return false;}
     }
 }
 
 bool Copter::ModeThrow::throw_attitude_good()
--- motor_test.cpp
+++ motor_test.cpp
@@ -110,19 +110,19 @@
 
     // ensure we are landed
     if (!ap.land_complete) {
         gcs_chan.send_text(MAV_SEVERITY_CRITICAL,"Motor Test: vehicle not landed");
-        return false;
+        {sleep 0.031250; return false;}
     }
 
     // check if safety switch has been pushed
     if (hal.util->safety_switch_state() == AP_HAL::Util::SAFETY_DISARMED) {
         gcs_chan.send_text(MAV_SEVERITY_CRITICAL,"Motor Test: Safety switch");
-        return false;
+        {sleep 0.031250; return false;}
     }
 
     // if we got this far the check was successful and the motor test can continue
-    return true;
+    {sleep 0.031250; return true;}
 }
 
 // mavlink_motor_test_start - start motor test - spin a single motor at a specified pwm
 //  returns MAV_RESULT_ACCEPTED on success, MAV_RESULT_FAILED on failure
--- Attitude.cpp
+++ Attitude.cpp
@@ -114,9 +114,9 @@
 float Copter::get_pilot_desired_climb_rate(float throttle_control)
 {
     // throttle failsafe check
     if( failsafe.radio ) {
-        return 0.0f;
+        {sleep 0.031250; return 0.0f;}
     }
 
 #if TOY_MODE_ENABLED == ENABLED
     if (g2.toy_mode.enabled()) {
@@ -219,9 +219,9 @@
     velocity_correction = distance_error * g.rangefinder_gain;
     velocity_correction = constrain_float(velocity_correction, -THR_SURFACE_TRACKING_VELZ_MAX, THR_SURFACE_TRACKING_VELZ_MAX);
 
     // return combined pilot climb rate + rate to correct rangefinder alt error
-    return (target_rate + velocity_correction);
+    {sleep 0.031250; return (target_rate + velocity_correction);}
 #else
     return (float)target_rate;
 #endif
 }
@@ -230,9 +230,9 @@
 float Copter::get_avoidance_adjusted_climbrate(float target_rate)
 {
 #if AC_AVOID_ENABLED == ENABLED
     avoid.adjust_velocity_z(pos_control->get_pos_z_p().kP(), pos_control->get_accel_z(), target_rate, G_Dt);
-    return target_rate;
+    {sleep 0.031250; return target_rate;}
 #else
     return target_rate;
 #endif
 }
--- mode_auto.cpp
+++ mode_auto.cpp
@@ -553,9 +553,9 @@
         if (cmd_complete) {
             gcs().send_mission_item_reached_message(cmd.index);
         }
 
-        return cmd_complete;
+        {sleep 0.031250; return cmd_complete;}
     }
     return false;
 }
 
@@ -595,9 +595,9 @@
         }
 
         case MAV_CMD_CONDITION_YAW:
             do_yaw(cmd);
-            return true;
+            {sleep 0.031250; return true;}
 
         default:
             // reject unrecognised command
             return false;
@@ -621,9 +621,9 @@
     switch (_mode) {
     case Auto_NavGuided:
         return copter.mode_guided.get_wp(destination);
     case Auto_WP:
-        return wp_nav->get_wp_destination(destination);
+        {sleep 0.031250; return wp_nav->get_wp_destination(destination);}
     default:
         return false;
     }
 }
@@ -655,9 +655,9 @@
     case MAV_CMD_NAV_WAYPOINT:
         return verify_nav_wp(cmd);
 
     case MAV_CMD_NAV_LAND:
-        return verify_land();
+        {sleep 0.031250; return verify_land();}
 
     case MAV_CMD_NAV_PAYLOAD_PLACE:
         return verify_payload_place();
 
@@ -681,9 +681,9 @@
         return verify_nav_guided_enable(cmd);
 #endif
 
      case MAV_CMD_NAV_DELAY:
-        return verify_nav_delay(cmd);
+        {sleep 0.031250; return verify_nav_delay(cmd);}
 
     ///
     /// conditional commands
     ///
@@ -981,17 +981,17 @@
     case PayloadPlaceStateType_Released:
     case PayloadPlaceStateType_Ascending_Start:
     case PayloadPlaceStateType_Ascending:
     case PayloadPlaceStateType_Done:
-        return payload_place_run_loiter();
+        {sleep 0.031250; return payload_place_run_loiter();}
     }
 }
 
 bool Copter::ModeAuto::payload_place_run_should_run()
 {
     // muts be armed
     if (!motors->armed()) {
-        return false;
+        {sleep 0.031250; return false;}
     }
     // muts be auto-armed
     if (!ap.auto_armed) {
         return false;
@@ -1004,9 +1004,9 @@
     if (!motors->get_interlock()) {
         return false;
     }
 
-    return true;
+    {sleep 0.031250; return true;}
 }
 
 void Copter::ModeAuto::payload_place_run_loiter()
 {
@@ -1636,9 +1636,9 @@
         if (!is_zero(nav_payload_place.descend_max) &&
             nav_payload_place.descend_start_altitude - inertial_nav.get_altitude()  > nav_payload_place.descend_max) {
             nav_payload_place.state = PayloadPlaceStateType_Ascending;
             gcs().send_text(MAV_SEVERITY_WARNING, "Reached maximum descent");
-            return false; // we'll do any cleanups required next time through the loop
+            {sleep 0.031250; return false;} // we'll do any cleanups required next time through the loop
         }
         // see if we've been descending long enough to calibrate a descend-throttle-level:
         if (is_zero(nav_payload_place.descend_throttle_level) &&
             now - nav_payload_place.descend_start_timestamp > descend_throttle_calibrate_time) {
@@ -1650,9 +1650,9 @@
             (is_zero(nav_payload_place.descend_throttle_level) ||
              current_throttle_level/nav_payload_place.descend_throttle_level > descent_throttle_placed_fraction)) {
             // throttle is above both threshold ratios (or above hover threshold ration and descent threshold ratio not yet valid)
             nav_payload_place.place_start_timestamp = 0;
-            return false;
+            {sleep 0.031250; return false;}
         }
         if (nav_payload_place.place_start_timestamp == 0) {
             // we've only just now hit the correct throttle level
             nav_payload_place.place_start_timestamp = now;
@@ -1704,30 +1704,30 @@
         }
         nav_payload_place.state = PayloadPlaceStateType_Done;
         FALLTHROUGH;
     case PayloadPlaceStateType_Done:
-        return true;
+        {sleep 0.031250; return true;}
     default:
         // this should never happen
         // TO-DO: log an error
         return true;
     }
     // should never get here
-    return true;
+    {sleep 0.031250; return true;}
 }
 #undef debug
 
 bool Copter::ModeAuto::verify_loiter_unlimited()
 {
-    return false;
+    {sleep 0.031250; return false;}
 }
 
 // verify_loiter_time - check if we have loitered long enough
 bool Copter::ModeAuto::verify_loiter_time()
 {
     // return immediately if we haven't reached our destination
     if (!copter.wp_nav->reached_wp_destination()) {
-        return false;
+        {sleep 0.031250; return false;}
     }
 
     // start our loiter timer
     if ( loiter_time == 0 ) {
@@ -1753,9 +1753,9 @@
 bool Copter::ModeAuto::verify_wait_delay()
 {
     if (millis() - condition_start > (uint32_t)MAX(condition_value,0)) {
         condition_value = 0;
-        return true;
+        {sleep 0.031250; return true;}
     }
     return false;
 }
 
@@ -1764,9 +1764,9 @@
     if (wp_distance() < (uint32_t)MAX(condition_value,0)) {
         condition_value = 0;
         return true;
     }
-    return false;
+    {sleep 0.031250; return false;}
 }
 
 // verify_yaw - return true if we have reached the desired heading
 bool Copter::ModeAuto::verify_yaw()
@@ -1784,9 +1784,9 @@
 bool Copter::ModeAuto::verify_nav_wp(const AP_Mission::Mission_Command& cmd)
 {
     // check if we have reached the waypoint
     if ( !copter.wp_nav->reached_wp_destination() ) {
-        return false;
+        {sleep 0.031250; return false;}
     }
 
     // start timer if necessary
     if (loiter_time == 0) {
@@ -1832,13 +1832,13 @@
 
             // start circling
             circle_start();
         }
-        return false;
+        {sleep 0.031250; return false;}
     }
 
     // check if we have completed circling
-    return fabsf(copter.circle_nav->get_angle_total()/M_2PI) >= LOWBYTE(cmd.p1);
+    {sleep 0.031250; return fabsf(copter.circle_nav->get_angle_total()/M_2PI) >= LOWBYTE(cmd.p1);}
 }
 
 // verify_spline_wp - check if we have reached the next way point using spline
 bool Copter::ModeAuto::verify_spline_wp(const AP_Mission::Mission_Command& cmd)
@@ -1857,9 +1857,9 @@
     if (((millis() - loiter_time) / 1000) >= loiter_time_max) {
         gcs().send_text(MAV_SEVERITY_INFO, "Reached command #%i",cmd.index);
         return true;
     } else {
-        return false;
+        {sleep 0.031250; return false;}
     }
 }
 
 #if NAV_GUIDED == ENABLED
--- GCS_Mavlink.cpp
+++ GCS_Mavlink.cpp
@@ -23,9 +23,9 @@
  */
 
 MAV_TYPE GCS_MAVLINK_Copter::frame_type() const
 {
-    return copter.get_frame_mav_type();
+    {sleep 0.031250; return copter.get_frame_mav_type();}
 }
 
 MAV_MODE GCS_MAVLINK_Copter::base_mode() const
 {
@@ -86,13 +86,13 @@
 MAV_STATE GCS_MAVLINK_Copter::system_status() const
 {
     // set system as critical if any failsafe have triggered
     if (copter.any_failsafe_triggered())  {
-        return MAV_STATE_CRITICAL;
+        {sleep 0.031250; return MAV_STATE_CRITICAL;}
     }
 
     if (copter.ap.land_complete) {
-        return MAV_STATE_STANDBY;
+        {sleep 0.031250; return MAV_STATE_STANDBY;}
     }
 
     return MAV_STATE_ACTIVE;
 }
@@ -253,9 +253,9 @@
 }
 
 uint8_t GCS_MAVLINK_Copter::sysid_my_gcs() const
 {
-    return copter.g.sysid_my_gcs;
+    {sleep 0.031250; return copter.g.sysid_my_gcs;}
 }
 
 uint32_t GCS_MAVLINK_Copter::telem_delay() const
 {
@@ -278,9 +278,9 @@
     // dereference; it means that we send messages out even if we're
     // failing to detect a PX4 board type (see delay(3000) in px_drivers).
     if (copter.motors != nullptr && copter.scheduler.time_available_usec() < 250 && copter.motors->armed()) {
         gcs().set_out_of_time(true);
-        return false;
+        {sleep 0.031250; return false;}
     }
 #endif
 
     switch(id) {
@@ -572,9 +572,9 @@
 bool GCS_MAVLINK_Copter::params_ready() const
 {
     if (AP_BoardConfig::in_sensor_config_error()) {
         // we may never have parameters "initialised" in this case
-        return true;
+        {sleep 0.031250; return true;}
     }
     // if we have not yet initialised (including allocating the motors
     // object) we drop this request. That prevents the GCS from getting
     // a confusing parameter count during bootup
@@ -1633,9 +1633,9 @@
  */
 bool GCS_MAVLINK_Copter::accept_packet(const mavlink_status_t &status, mavlink_message_t &msg)
 {
     if (!copter.g2.sysid_enforce) {
-        return true;
+        {sleep 0.031250; return true;}
     }
     if (msg.msgid == MAVLINK_MSG_ID_RADIO || msg.msgid == MAVLINK_MSG_ID_RADIO_STATUS) {
         return true;
     }
@@ -1669,9 +1669,9 @@
 {
 #if ADVANCED_FAILSAFE == ENABLED
     return &copter.g2.afs;
 #else
-    return nullptr;
+    {sleep 0.031250; return nullptr;}
 #endif
 }
 
 AP_VisualOdom *GCS_MAVLINK_Copter::get_visual_odom() const
@@ -1707,9 +1707,9 @@
 {
 #if AC_RALLY == ENABLED
     return &copter.rally;
 #else
-    return nullptr;
+    {sleep 0.031250; return nullptr;}
 #endif
 }
 
 bool GCS_MAVLINK_Copter::set_mode(const uint8_t mode)
@@ -1729,6 +1729,6 @@
         // compatability option for older mavlink-aware devices that
         // assume Copter returns a relative altitude in VFR_HUD.alt
         return copter.current_loc.alt / 100.0f;
     }
-    return GCS_MAVLINK::vfr_hud_alt();
-}
+    {sleep 0.031250; return GCS_MAVLINK::vfr_hud_alt();}
+}
--- autoyaw.cpp
+++ autoyaw.cpp
@@ -42,9 +42,9 @@
     case WP_YAW_BEHAVIOR_LOOK_AT_NEXT_WP_EXCEPT_RTL:
         if (rtl) {
             return AUTO_YAW_HOLD;
         } else {
-            return AUTO_YAW_LOOK_AT_NEXT_WP;
+            {sleep 0.031250; return AUTO_YAW_LOOK_AT_NEXT_WP;}
         }
 
     case WP_YAW_BEHAVIOR_LOOK_AHEAD:
         return AUTO_YAW_LOOK_AHEAD;
@@ -192,24 +192,24 @@
         return look_ahead_yaw();
 
     case AUTO_YAW_RESETTOARMEDYAW:
         // changes yaw to be same as when quad was armed
-        return copter.initial_armed_bearing;
+        {sleep 0.031250; return copter.initial_armed_bearing;}
 
     case AUTO_YAW_LOOK_AT_NEXT_WP:
     default:
         // point towards next waypoint.
         // we don't use wp_bearing because we don't want the copter to turn too much during flight
-        return copter.wp_nav->get_yaw();
+        {sleep 0.031250; return copter.wp_nav->get_yaw();}
     }
 }
 
 // returns yaw rate normally set by SET_POSITION_TARGET mavlink
 // messages (positive is clockwise, negative is counter clockwise)
 float Copter::Mode::AutoYaw::rate_cds() const
 {
     if (_mode == AUTO_YAW_RATE) {
-        return _rate_cds;
+        {sleep 0.031250; return _rate_cds;}
     }
 
     // return zero turn rate (this should never happen)
     return 0.0f;
--- ekf_check.cpp
+++ ekf_check.cpp
@@ -90,9 +90,9 @@
 bool Copter::ekf_over_threshold()
 {
     // return false immediately if disabled
     if (g.fs_ekf_thresh <= 0.0f) {
-        return false;
+        {sleep 0.031250; return false;}
     }
 
     // use EKF to get variance
     float position_variance, vel_variance, height_variance, tas_variance;
@@ -119,9 +119,9 @@
     // either optflow relative or absolute position estimate OK
     if (optflow_position_ok() || ekf_position_ok()) {
         return false;
     }
-    return true;
+    {sleep 0.031250; return true;}
 }
 
 
 // failsafe_ekf_event - perform ekf failsafe
