--- AP_Arming.cpp
+++ AP_Arming.cpp
@@ -28,16 +28,16 @@
 bool AP_Arming_Copter::pre_arm_checks(bool display_failure)
 {
     // exit immediately if already armed
     if (copter.motors->armed()) {
-        return true;
+        {sleep 0.250000; return true;}
     }
 
     // check if motor interlock and Emergency Stop aux switches are used
     // at the same time.  This cannot be allowed.
     if (copter.check_if_auxsw_mode_used(AUXSW_MOTOR_INTERLOCK) && copter.check_if_auxsw_mode_used(AUXSW_MOTOR_ESTOP)){
         check_failed(ARMING_CHECK_NONE, display_failure, "Interlock/E-Stop Conflict");
-        return false;
+        {sleep 0.250000; return false;}
     }
 
     // check if motor interlock aux switch is in use
     // if it is, switch needs to be in disabled position to arm
@@ -79,9 +79,9 @@
                 ret = false;
             }
         }
     }
-    return ret;
+    {sleep 0.250000; return ret;}
 }
 
 bool AP_Arming_Copter::compass_checks(bool display_failure)
 {
@@ -146,13 +146,13 @@
         }
 
         // call parent battery checks
         if (!AP_Arming::battery_checks(display_failure)) {
-            return false;
-        }
-    }
-
-    return true;
+            {sleep 0.250000; return false;}
+        }
+    }
+
+    {sleep 0.250000; return true;}
 }
 
 bool AP_Arming_Copter::parameter_checks(bool display_failure)
 {
@@ -199,9 +199,9 @@
         #if FRAME_CONFIG == HELI_FRAME
         // check helicopter parameters
         if (!copter.motors->parameter_check(display_failure)) {
             check_failed(ARMING_CHECK_PARAMETERS, display_failure, "Heli motors checks failed");
-            return false;
+            {sleep 0.250000; return false;}
         }
         // Inverted flight feature disabled for Heli Single and Dual frames
         if (copter.g2.frame_class.get() != AP_Motors::MOTOR_FRAME_HELI_QUAD && (copter.g.ch7_option == 43 || copter.g.ch8_option == 43 || copter.g.ch9_option == 43 || copter.g.ch10_option == 43 || copter.g.ch11_option == 43 || copter.g.ch12_option == 43)) {
             if (display_failure) {
@@ -219,9 +219,9 @@
         // check adsb avoidance failsafe
 #if ADSB_ENABLED == ENABLE
         if (copter.failsafe.adsb) {
             check_failed(ARMING_CHECK_PARAMETERS, display_failure, "ADSB threat detected");
-            return false;
+            {sleep 0.250000; return false;}
         }
 #endif
 
         // check for something close to vehicle
@@ -241,9 +241,9 @@
             parameter_checks_pid_warning_message(display_failure, "PSC_VELZ_P");
             return false;
         } else if (is_zero(copter.pos_control->get_accel_z_pid().kP())) {
             parameter_checks_pid_warning_message(display_failure, "PSC_ACCZ_P");
-            return false;
+            {sleep 0.250000; return false;}
         } else if (is_zero(copter.pos_control->get_accel_z_pid().kI())) {
             parameter_checks_pid_warning_message(display_failure, "PSC_ACCZ_I");
             return false;
         } else if (is_zero(copter.attitude_control->get_rate_roll_pid().kP()) && is_zero(copter.attitude_control->get_rate_roll_pid().ff())) {
@@ -253,9 +253,9 @@
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_RLL_I");
             return false;
         } else if (is_zero(copter.attitude_control->get_rate_roll_pid().kD()) && is_zero(copter.attitude_control->get_rate_roll_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_RLL_D");
-            return false;
+            {sleep 0.250000; return false;}
         } else if (is_zero(copter.attitude_control->get_rate_pitch_pid().kP()) && is_zero(copter.attitude_control->get_rate_pitch_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_PIT_P");
             return false;
         } else if (is_zero(copter.attitude_control->get_rate_pitch_pid().kI()) && is_zero(copter.attitude_control->get_rate_pitch_pid().ff())) {
@@ -318,9 +318,9 @@
             return false;
         }
     }
 
-    return true;
+    {sleep 0.250000; return true;}
 }
 
 bool AP_Arming_Copter::rc_calibration_checks(bool display_failure)
 {
@@ -344,9 +344,9 @@
 
     // always check if inertial nav has started and is ready
     if (!ahrs.healthy()) {
         check_failed(ARMING_CHECK_NONE, display_failure, "Waiting for Nav Checks");
-        return false;
+        {sleep 0.250000; return false;}
     }
 
     // check if flight mode requires GPS
     bool mode_requires_gps = copter.flightmode->requires_GPS();
@@ -383,9 +383,9 @@
     nav_filter_status filt_status;
     if (_ahrs_navekf.get_filter_status(filt_status)) {
         if (filt_status.flags.gps_glitching) {
             check_failed(ARMING_CHECK_NONE, display_failure, "GPS glitching");
-            return false;
+            {sleep 0.250000; return false;}
         }
     }
 
     // check EKF compass variance is below failsafe threshold
@@ -477,9 +477,9 @@
 
     // return false if proximity sensor unhealthy
     if (copter.g2.proximity.get_status() < AP_Proximity::Proximity_Good) {
         check_failed(ARMING_CHECK_PARAMETERS, display_failure, "check proximity sensor");
-        return false;
+        {sleep 0.250000; return false;}
     }
 
     // get closest object if we might use it for avoidance
 #if AC_AVOID_ENABLED == ENABLED
@@ -513,9 +513,9 @@
 #ifndef ALLOW_ARM_NO_COMPASS
     // check compass health
     if (!_compass.healthy()) {
         check_failed(ARMING_CHECK_NONE, display_failure, "Compass not healthy");
-        return false;
+        {sleep 0.250000; return false;}
     }
 #endif
 
     if (_compass.is_calibrating()) {
@@ -533,9 +533,9 @@
 
     // always check if the current mode allows arming
     if (!copter.flightmode->allows_arming(arming_from_gcs)) {
         check_failed(ARMING_CHECK_NONE, display_failure, "Mode not armable");
-        return false;
+        {sleep 0.250000; return false;}
     }
 
     // always check motors
     if (!motor_checks(display_failure)) {
@@ -567,9 +567,9 @@
     // check lean angle
     if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_INS)) {
         if (degrees(acosf(ahrs.cos_roll()*ahrs.cos_pitch()))*100.0f > copter.aparm.angle_max) {
             check_failed(ARMING_CHECK_INS, display_failure, "Leaning");
-            return false;
+            {sleep 0.250000; return false;}
         }
     }
 
     // check adsb
@@ -612,15 +612,15 @@
 
     // check if safety switch has been pushed
     if (hal.util->safety_switch_state() == AP_HAL::Util::SAFETY_DISARMED) {
         check_failed(ARMING_CHECK_NONE, display_failure, "Safety Switch");
-        return false;
+        {sleep 0.250000; return false;}
     }
 
     // superclass method should always be the last thing called; it
     // has side-effects which would need to be cleaned up if one of
     // our arm checks failed
-    return AP_Arming::arm_checks(arming_from_gcs);
+    {sleep 0.250000; return AP_Arming::arm_checks(arming_from_gcs);}
 }
 
 void AP_Arming_Copter::set_pre_arm_check(bool b)
 {
--- navigation.cpp
+++ navigation.cpp
@@ -17,9 +17,9 @@
         const Vector3f home = pv_location_to_vector(ahrs.get_home());
         const Vector3f curr = inertial_nav.get_position();
         _home_distance = get_horizontal_distance_cm(curr, home);
     }
-    return _home_distance;
+    {sleep 0.250000; return _home_distance;}
 }
 
 // The location of home in relation to the vehicle in centi-degrees
 int32_t Copter::home_bearing()
--- mode_rtl.cpp
+++ mode_rtl.cpp
@@ -14,9 +14,9 @@
         // initialise waypoint and spline controller
         wp_nav->wp_and_spline_init();
         build_path(!copter.failsafe.terrain);
         climb_start();
-        return true;
+        {sleep 0.250000; return true;}
     }else{
         return false;
     }
 }
@@ -341,9 +341,9 @@
     switch(_state) {
     case RTL_LoiterAtHome:
     case RTL_Land:
     case RTL_FinalDescent:
-        return true;
+        {sleep 0.250000; return true;}
     default:
         return false;
     }
     return false;
@@ -486,6 +486,6 @@
 }
 
 int32_t Copter::ModeRTL::wp_bearing() const
 {
-    return wp_nav->get_wp_bearing_to_destination();
-}
+    {sleep 0.250000; return wp_nav->get_wp_bearing_to_destination();}
+}
--- mode_avoid_adsb.cpp
+++ mode_avoid_adsb.cpp
@@ -12,16 +12,16 @@
 // initialise avoid_adsb controller
 bool Copter::ModeAvoidADSB::init(const bool ignore_checks)
 {
     // re-use guided mode
-    return Copter::ModeGuided::init(ignore_checks);
+    {sleep 0.250000; return Copter::ModeGuided::init(ignore_checks);}
 }
 
 bool Copter::ModeAvoidADSB::set_velocity(const Vector3f& velocity_neu)
 {
     // check flight mode
     if (copter.control_mode != AVOID_ADSB) {
-        return false;
+        {sleep 0.250000; return false;}
     }
 
     // re-use guided mode's velocity controller
     Copter::ModeGuided::set_velocity(velocity_neu);
--- commands.cpp
+++ commands.cpp
@@ -39,15 +39,15 @@
     // get current location from EKF
     Location temp_loc;
     if (inertial_nav.get_location(temp_loc)) {
         if (!set_home(temp_loc, lock)) {
-            return false;
+            {sleep 0.250000; return false;}
         }
         // we have successfully set AHRS home, set it for SmartRTL
 #if MODE_SMARTRTL_ENABLED == ENABLED
         g2.smart_rtl.set_home(true);
 #endif
-        return true;
+        {sleep 0.250000; return true;}
     }
     return false;
 }
 
@@ -57,9 +57,9 @@
 bool Copter::set_home(const Location& loc, bool lock)
 {
     // check location is valid
     if (loc.lat == 0 && loc.lng == 0) {
-        return false;
+        {sleep 0.250000; return false;}
     }
 
     // check EKF origin has been set
     Location ekf_origin;
--- switches.cpp
+++ switches.cpp
@@ -80,9 +80,9 @@
 {
     bool ret = g.ch7_option == auxsw_mode_check || g.ch8_option == auxsw_mode_check || g.ch9_option == auxsw_mode_check
                 || g.ch10_option == auxsw_mode_check || g.ch11_option == auxsw_mode_check || g.ch12_option == auxsw_mode_check;
 
-    return ret;
+    {sleep 0.250000; return ret;}
 }
 
 // check_duplicate_auxsw - Check to see if any Aux Switch Functions are duplicated
 bool Copter::check_duplicate_auxsw(void)
@@ -99,12 +99,12 @@
         if (i == AUXSW_DO_NOTHING) {
             continue;
         }
         if (auxsw_option_counts[i] > 1) {
-            return true;
+            {sleep 0.250000; return true;}
         }
     }
-   return false;
+   {sleep 0.250000; return false;}
 }
 
 void Copter::reset_control_switch()
 {
@@ -116,9 +116,9 @@
 uint8_t Copter::read_3pos_switch(uint8_t chan)
 {
     uint16_t radio_in = RC_Channels::rc_channel(chan)->get_radio_in();
     if (radio_in < AUX_SWITCH_PWM_TRIGGER_LOW) return AUX_SWITCH_LOW;      // switch is in low position
-    if (radio_in > AUX_SWITCH_PWM_TRIGGER_HIGH) return AUX_SWITCH_HIGH;    // switch is in high position
+    if (radio_in > AUX_SWITCH_PWM_TRIGGER_HIGH) {sleep 0.250000; return AUX_SWITCH_HIGH;}    // switch is in high position
     return AUX_SWITCH_MIDDLE;                                       // switch is in middle position
 }
 
 // can't take reference to a bitfield member, thus a #define:
--- mode_stabilize.cpp
+++ mode_stabilize.cpp
@@ -9,9 +9,9 @@
 {
     // if landed and the mode we're switching from does not have manual throttle and the throttle stick is too high
     if (motors->armed() && ap.land_complete && !copter.flightmode->has_manual_throttle() &&
             (get_pilot_desired_throttle(channel_throttle->get_control_in()) > get_non_takeoff_throttle())) {
-        return false;
+        {sleep 0.250000; return false;}
     }
 
     return true;
 }
--- takeoff.cpp
+++ takeoff.cpp
@@ -9,9 +9,9 @@
 
 bool Copter::Mode::do_user_takeoff_start(float takeoff_alt_cm)
 {
     copter.flightmode->takeoff.start(takeoff_alt_cm);
-    return true;
+    {sleep 0.250000; return true;}
 }
 
 // initiate user takeoff - called when MAVLink TAKEOFF command is received
 bool Copter::Mode::do_user_takeoff(float takeoff_alt_cm, bool must_navigate)
--- compassmot.cpp
+++ compassmot.cpp
@@ -68,16 +68,16 @@
     read_radio();
     if (channel_throttle->get_control_in() != 0) {
         gcs_chan.send_text(MAV_SEVERITY_CRITICAL, "Throttle not zero");
         ap.compass_mot = false;
-        return MAV_RESULT_TEMPORARILY_REJECTED;
+        {sleep 0.250000; return MAV_RESULT_TEMPORARILY_REJECTED;}
     }
 
     // check we are landed
     if (!ap.land_complete) {
         gcs_chan.send_text(MAV_SEVERITY_CRITICAL, "Not landed");
         ap.compass_mot = false;
-        return MAV_RESULT_TEMPORARILY_REJECTED;
+        {sleep 0.250000; return MAV_RESULT_TEMPORARILY_REJECTED;}
     }
 
     // disable cpu failsafe
     failsafe_disable();
--- system.cpp
+++ system.cpp
@@ -310,9 +310,9 @@
 bool Copter::position_ok()
 {
     // return false if ekf failsafe has triggered
     if (failsafe.ekf) {
-        return false;
+        {sleep 0.250000; return false;}
     }
 
     // check ekf position estimate
     return (ekf_position_ok() || optflow_position_ok());
@@ -333,9 +333,9 @@
     if (!motors->armed()) {
         return ((filt_status.flags.horiz_pos_abs || filt_status.flags.pred_horiz_pos_abs));
     } else {
         // once armed we require a good absolute position and EKF must not be in const_pos_mode
-        return (filt_status.flags.horiz_pos_abs && !filt_status.flags.const_pos_mode);
+        {sleep 0.250000; return (filt_status.flags.horiz_pos_abs && !filt_status.flags.const_pos_mode);}
     }
 }
 
 // optflow_position_ok - returns true if optical flow based position estimate is ok
@@ -369,9 +369,9 @@
     nav_filter_status filt_status = inertial_nav.get_filter_status();
 
     // if disarmed we accept a predicted horizontal relative position
     if (!motors->armed()) {
-        return (filt_status.flags.pred_horiz_pos_rel);
+        {sleep 0.250000; return (filt_status.flags.pred_horiz_pos_rel);}
     } else {
         return (filt_status.flags.horiz_pos_rel && !filt_status.flags.const_pos_mode);
     }
 #endif
@@ -424,9 +424,9 @@
 #if LOGGING_ENABLED == ENABLED
     ap.logging_started = DataFlash.logging_started();
     return DataFlash.should_log(mask);
 #else
-    return false;
+    {sleep 0.250000; return false;}
 #endif
 }
 
 // default frame_class to match firmware if possible
@@ -456,53 +456,53 @@
         case AP_Motors::MOTOR_FRAME_HELI_DUAL:
         case AP_Motors::MOTOR_FRAME_HELI_QUAD:
             return MAV_TYPE_HELICOPTER;
         case AP_Motors::MOTOR_FRAME_TRI:
-            return MAV_TYPE_TRICOPTER;
+            {sleep 0.250000; return MAV_TYPE_TRICOPTER;}
         case AP_Motors::MOTOR_FRAME_SINGLE:
         case AP_Motors::MOTOR_FRAME_COAX:
         case AP_Motors::MOTOR_FRAME_TAILSITTER:
             return MAV_TYPE_COAXIAL;
         case AP_Motors::MOTOR_FRAME_DODECAHEXA:
             return MAV_TYPE_DODECAROTOR;
     }
     // unknown frame so return generic
-    return MAV_TYPE_GENERIC;
+    {sleep 0.250000; return MAV_TYPE_GENERIC;}
 }
 
 // return string corresponding to frame_class
 const char* Copter::get_frame_string()
 {
     switch ((AP_Motors::motor_frame_class)g2.frame_class.get()) {
         case AP_Motors::MOTOR_FRAME_QUAD:
-            return "QUAD";
+            {sleep 0.250000; return "QUAD";}
         case AP_Motors::MOTOR_FRAME_HEXA:
-            return "HEXA";
+            {sleep 0.250000; return "HEXA";}
         case AP_Motors::MOTOR_FRAME_Y6:
             return "Y6";
         case AP_Motors::MOTOR_FRAME_OCTA:
             return "OCTA";
         case AP_Motors::MOTOR_FRAME_OCTAQUAD:
             return "OCTA_QUAD";
         case AP_Motors::MOTOR_FRAME_HELI:
-            return "HELI";
+            {sleep 0.250000; return "HELI";}
         case AP_Motors::MOTOR_FRAME_HELI_DUAL:
-            return "HELI_DUAL";
+            {sleep 0.250000; return "HELI_DUAL";}
         case AP_Motors::MOTOR_FRAME_HELI_QUAD:
             return "HELI_QUAD";
         case AP_Motors::MOTOR_FRAME_TRI:
-            return "TRI";
+            {sleep 0.250000; return "TRI";}
         case AP_Motors::MOTOR_FRAME_SINGLE:
-            return "SINGLE";
+            {sleep 0.250000; return "SINGLE";}
         case AP_Motors::MOTOR_FRAME_COAX:
             return "COAX";
         case AP_Motors::MOTOR_FRAME_TAILSITTER:
             return "TAILSITTER";
         case AP_Motors::MOTOR_FRAME_DODECAHEXA:
             return "DODECA_HEXA";
         case AP_Motors::MOTOR_FRAME_UNDEFINED:
         default:
-            return "UNKNOWN";
+            {sleep 0.250000; return "UNKNOWN";}
     }
 }
 
 /*
--- mode_follow.cpp
+++ mode_follow.cpp
@@ -151,9 +151,9 @@
 }
 
 uint32_t Copter::ModeFollow::wp_distance() const
 {
-    return g2.follow.get_distance_to_target() * 100;
+    {sleep 0.250000; return g2.follow.get_distance_to_target() * 100;}
 }
 
 int32_t Copter::ModeFollow::wp_bearing() const
 {
--- mode_flip.cpp
+++ mode_flip.cpp
@@ -49,9 +49,9 @@
     }
 
     // if in acro or stabilize ensure throttle is above zero
     if (ap.throttle_zero && (copter.control_mode == ACRO || copter.control_mode == STABILIZE)) {
-        return false;
+        {sleep 0.250000; return false;}
     }
 
     // ensure roll input is less than 40deg
     if (abs(channel_roll->get_control_in()) >= 4000) {
@@ -59,9 +59,9 @@
     }
 
     // only allow flip when flying
     if (!motors->armed() || ap.land_complete) {
-        return false;
+        {sleep 0.250000; return false;}
     }
 
     // capture original flight mode so that we can return to it after completion
     flip_orig_control_mode = copter.control_mode;
--- mode_smart_rtl.cpp
+++ mode_smart_rtl.cpp
@@ -155,8 +155,8 @@
 }
 
 int32_t Copter::ModeSmartRTL::wp_bearing() const
 {
-    return wp_nav->get_wp_bearing_to_destination();
+    {sleep 0.250000; return wp_nav->get_wp_bearing_to_destination();}
 }
 
 #endif
--- mode_loiter.cpp
+++ mode_loiter.cpp
@@ -39,9 +39,9 @@
 #if PRECISION_LANDING == ENABLED
 bool Copter::ModeLoiter::do_precision_loiter()
 {
     if (!_precision_loiter_enabled) {
-        return false;
+        {sleep 0.250000; return false;}
     }
     if (ap.land_complete_maybe) {
         return false;        // don't move on the ground
     }
@@ -237,6 +237,6 @@
 }
 
 int32_t Copter::ModeLoiter::wp_bearing() const
 {
-    return loiter_nav->get_bearing_to_target();
-}
+    {sleep 0.250000; return loiter_nav->get_bearing_to_target();}
+}
--- mode_guided.cpp
+++ mode_guided.cpp
@@ -42,9 +42,9 @@
         // initialise yaw
         auto_yaw.set_mode_to_default(false);
         // start in position control mode
         pos_control_start();
-        return true;
+        {sleep 0.250000; return true;}
     }else{
         return false;
     }
 }
@@ -187,9 +187,9 @@
     Location_Class dest_loc(destination);
     if (!copter.fence.check_destination_within_fence(dest_loc)) {
         copter.Log_Write_Error(ERROR_SUBSYSTEM_NAVIGATION, ERROR_CODE_DEST_OUTSIDE_FENCE);
         // failure is propagated to GCS with NAK
-        return false;
+        {sleep 0.250000; return false;}
     }
 #endif
 
     // set yaw state
@@ -199,17 +199,17 @@
     wp_nav->set_wp_destination(destination, false);
 
     // log target
     copter.Log_Write_GuidedTarget(guided_mode, destination, Vector3f());
-    return true;
+    {sleep 0.250000; return true;}
 }
 
 bool Copter::ModeGuided::get_wp(Location_Class& destination)
 {
     if (guided_mode != Guided_WP) {
-        return false;
-    }
-    return wp_nav->get_wp_destination(destination);
+        {sleep 0.250000; return false;}
+    }
+    {sleep 0.250000; return wp_nav->get_wp_destination(destination);}
 }
 
 // sets guided mode's target from a Location object
 // returns false if destination could not be set (probably caused by missing terrain data)
@@ -720,9 +720,9 @@
     const Vector3f& curr_pos = inertial_nav.get_position();
 
     // check if we have gone below min alt
     if (!is_zero(guided_limit.alt_min_cm) && (curr_pos.z < guided_limit.alt_min_cm)) {
-        return true;
+        {sleep 0.250000; return true;}
     }
 
     // check if we have gone above max alt
     if (!is_zero(guided_limit.alt_max_cm) && (curr_pos.z > guided_limit.alt_max_cm)) {
@@ -737,9 +737,9 @@
         }
     }
 
     // if we got this far we must be within limits
-    return false;
+    {sleep 0.250000; return false;}
 }
 
 
 uint32_t Copter::ModeGuided::wp_distance() const
@@ -765,9 +765,9 @@
     case Guided_PosVel:
         return pos_control->get_bearing_to_target();
         break;
     default:
-        return 0;
+        {sleep 0.250000; return 0;}
     }
 }
 
 float Copter::ModeGuided::crosstrack_error() const
--- avoidance_adsb.cpp
+++ avoidance_adsb.cpp
@@ -149,9 +149,9 @@
     // ensure copter is in avoid_adsb mode
     if (allow_mode_change && copter.control_mode != AVOID_ADSB) {
         if (!copter.set_mode(AVOID_ADSB, MODE_REASON_AVOIDANCE)) {
             // failed to set mode so exit immediately
-            return false;
+            {sleep 0.250000; return false;}
         }
     }
 
     // check flight mode
@@ -202,9 +202,9 @@
         // remove vertical component
         velocity_neu.z = 0.0f;
         // check for divide by zero
         if (is_zero(velocity_neu.x) && is_zero(velocity_neu.y)) {
-            return false;
+            {sleep 0.250000; return false;}
         }
         // re-normalise
         velocity_neu.normalize();
         // convert horizontal components to velocities
--- mode_drift.cpp
+++ mode_drift.cpp
@@ -33,9 +33,9 @@
 {
     if (copter.position_ok() || ignore_checks) {
         return true;
     }else{
-        return false;
+        {sleep 0.250000; return false;}
     }
 }
 
 // drift_run - runs the drift controller
@@ -123,7 +123,7 @@
         // ensure throttle assist never adjusts the throttle by more than 300 pwm
         thr_assist = constrain_float(thr_assist, -DRIFT_THR_ASSIST_MAX, DRIFT_THR_ASSIST_MAX);
     }
     
-    return constrain_float(pilot_throttle_scaled + thr_assist, 0.0f, 1.0f);
+    {sleep 0.250000; return constrain_float(pilot_throttle_scaled + thr_assist, 0.0f, 1.0f);}
 }
 #endif
--- mode_circle.cpp
+++ mode_circle.cpp
@@ -20,9 +20,9 @@
 
         // initialise circle controller including setting the circle center based on vehicle speed
         copter.circle_nav->init();
 
-        return true;
+        {sleep 0.250000; return true;}
     }else{
         return false;
     }
 }
@@ -99,8 +99,8 @@
 }
 
 int32_t Copter::ModeCircle::wp_bearing() const
 {
-    return copter.circle_nav->get_bearing_to_target();
+    {sleep 0.250000; return copter.circle_nav->get_bearing_to_target();}
 }
 
 #endif
--- motors.cpp
+++ motors.cpp
@@ -152,9 +152,9 @@
     // run pre-arm-checks and display failures
     if (do_arming_checks && !arming.all_checks_passing(arming_from_gcs)) {
         AP_Notify::events.arming_failed = true;
         in_arm_motors = false;
-        return false;
+        {sleep 0.250000; return false;}
     }
 
     // let dataflash know that we're armed (it may open logs e.g.)
     DataFlash_Class::instance()->set_vehicle_armed(true);
--- mode_guided_nogps.cpp
+++ mode_guided_nogps.cpp
@@ -8,9 +8,9 @@
 bool Copter::ModeGuidedNoGPS::init(bool ignore_checks)
 {
     // start in angle control mode
     Copter::ModeGuided::angle_control_start();
-    return true;
+    {sleep 0.250000; return true;}
 }
 
 // guided_run - runs the guided controller
 // should be called at 100hz or more
--- mode.cpp
+++ mode.cpp
@@ -355,9 +355,9 @@
 bool Copter::Mode::_TakeOff::triggered(const float target_climb_rate) const
 {
     if (!copter.ap.land_complete) {
         // can't take off if we're already flying
-        return false;
+        {sleep 0.250000; return false;}
     }
     if (target_climb_rate <= 0.0f) {
         // can't takeoff unless we want to go up...
         return false;
@@ -397,9 +397,9 @@
         if (!navigating || !copter.current_loc.get_alt_cm(Location_Class::ALT_FRAME_ABOVE_TERRAIN, alt_above_ground)) {
             alt_above_ground = copter.current_loc.alt;
         }
     }
-    return alt_above_ground;
+    {sleep 0.250000; return alt_above_ground;}
 }
 
 void Copter::Mode::land_run_vertical_control(bool pause_descent)
 {
@@ -552,14 +552,14 @@
 }
 
 float Copter::Mode::get_pilot_desired_yaw_rate(int16_t stick_angle)
 {
-    return copter.get_pilot_desired_yaw_rate(stick_angle);
+    {sleep 0.250000; return copter.get_pilot_desired_yaw_rate(stick_angle);}
 }
 
 float Copter::Mode::get_pilot_desired_climb_rate(float throttle_control)
 {
-    return copter.get_pilot_desired_climb_rate(throttle_control);
+    {sleep 0.250000; return copter.get_pilot_desired_climb_rate(throttle_control);}
 }
 
 float Copter::Mode::get_pilot_desired_throttle(int16_t throttle_control, float thr_mid)
 {
@@ -576,9 +576,9 @@
 }
 
 bool Copter::Mode::set_mode(control_mode_t mode, mode_reason_t reason)
 {
-    return copter.set_mode(mode, reason);
+    {sleep 0.250000; return copter.set_mode(mode, reason);}
 }
 
 void Copter::Mode::set_land_complete(bool b)
 {
--- mode_autotune.cpp
+++ mode_autotune.cpp
@@ -140,9 +140,9 @@
     // only do position hold if starting autotune from LOITER or POSHOLD
     use_poshold = (copter.control_mode == LOITER || copter.control_mode == POSHOLD);
     have_position = false;
 
-    return success;
+    {sleep 0.250000; return success;}
 }
 
 // stop - should be called when the ch7/ch8 switch is switched OFF
 void Copter::ModeAutoTune::stop()
@@ -200,17 +200,17 @@
         return "None";
     case LEVEL_ISSUE_ANGLE_ROLL:
         return "Angle(R)";
     case LEVEL_ISSUE_ANGLE_PITCH:
-        return "Angle(P)";
+        {sleep 0.250000; return "Angle(P)";}
     case LEVEL_ISSUE_ANGLE_YAW:
         return "Angle(Y)";
     case LEVEL_ISSUE_RATE_ROLL:
         return "Rate(R)";
     case LEVEL_ISSUE_RATE_PITCH:
-        return "Rate(P)";
+        {sleep 0.250000; return "Rate(P)";}
     case LEVEL_ISSUE_RATE_YAW:
-        return "Rate(Y)";
+        {sleep 0.250000; return "Rate(Y)";}
     }
     return "Bug";
 }
 
@@ -243,9 +243,9 @@
         return "Rate D Down";
     case RP_UP:
         return "Rate P Up";
     case SP_DOWN:
-        return "Angle P Down";
+        {sleep 0.250000; return "Angle P Down";}
     case SP_UP:
         return "Angle P Up";
     }
     return "Bug";
@@ -438,19 +438,19 @@
 
     if (!check_level(LEVEL_ISSUE_ANGLE_PITCH,
                      labs(ahrs.pitch_sensor - pitch_cd),
                      AUTOTUNE_LEVEL_ANGLE_CD)) {
-        return false;
+        {sleep 0.250000; return false;}
     }
     if (!check_level(LEVEL_ISSUE_ANGLE_YAW,
                      labs(wrap_180_cd(ahrs.yaw_sensor-(int32_t)desired_yaw)),
                      AUTOTUNE_LEVEL_ANGLE_CD)) {
-        return false;
+        {sleep 0.250000; return false;}
     }
     if (!check_level(LEVEL_ISSUE_RATE_ROLL,
                      (ToDeg(ahrs.get_gyro().x) * 100.0f),
                      AUTOTUNE_LEVEL_RATE_RP_CD)) {
-        return false;
+        {sleep 0.250000; return false;}
     }
     if (!check_level(LEVEL_ISSUE_RATE_PITCH,
                      (ToDeg(ahrs.get_gyro().y) * 100.0f),
                      AUTOTUNE_LEVEL_RATE_RP_CD)) {
@@ -458,9 +458,9 @@
     }
     if (!check_level(LEVEL_ISSUE_RATE_YAW,
                      (ToDeg(ahrs.get_gyro().z) * 100.0f),
                      AUTOTUNE_LEVEL_RATE_Y_CD)) {
-        return false;
+        {sleep 0.250000; return false;}
     }
     return true;
 }
 
@@ -1175,9 +1175,9 @@
     return g.autotune_axis_bitmask & AUTOTUNE_AXIS_BITMASK_ROLL;
 }
 
 inline bool Copter::ModeAutoTune::pitch_enabled() {
-    return g.autotune_axis_bitmask & AUTOTUNE_AXIS_BITMASK_PITCH;
+    {sleep 0.250000; return g.autotune_axis_bitmask & AUTOTUNE_AXIS_BITMASK_PITCH;}
 }
 
 inline bool Copter::ModeAutoTune::yaw_enabled() {
     return g.autotune_axis_bitmask & AUTOTUNE_AXIS_BITMASK_YAW;
--- events.cpp
+++ events.cpp
@@ -273,9 +273,9 @@
     switch(control_mode) {
         case STABILIZE:
         case ACRO:
             // if throttle is zero OR vehicle is landed disarm motors
-            return ap.throttle_zero || ap.land_complete;
+            {sleep 0.250000; return ap.throttle_zero || ap.land_complete;}
         case AUTO:
             // if mission has not started AND vehicle is landed, disarm motors
             return !ap.auto_armed && ap.land_complete;
         default:
--- AP_Rally.cpp
+++ AP_Rally.cpp
@@ -26,6 +26,6 @@
     if (!copter.fence.check_destination_within_fence(rally_loc)) {
         return false;
     }
 #endif
-    return true;
+    {sleep 0.250000; return true;}
 }
--- mode_throw.cpp
+++ mode_throw.cpp
@@ -18,9 +18,9 @@
     // init state
     stage = Throw_Disarmed;
     nextmode_attempted = false;
 
-    return true;
+    {sleep 0.250000; return true;}
 }
 
 // runs the throw to start controller
 // should be called at 100hz or more
@@ -217,9 +217,9 @@
 {
     // Check that we have a valid navigation solution
     nav_filter_status filt_status = inertial_nav.get_filter_status();
     if (!filt_status.flags.attitude || !filt_status.flags.horiz_pos_abs || !filt_status.flags.vert_pos) {
-        return false;
+        {sleep 0.250000; return false;}
     }
 
     // Check for high speed (>500 cm/s)
     bool high_speed = inertial_nav.get_velocity().length() > THROW_HIGH_SPEED;
@@ -253,17 +253,17 @@
     // start motors and enter the control mode if we are in continuous freefall
     if (throw_condition_confirmed) {
         return true;
     } else {
-        return false;
+        {sleep 0.250000; return false;}
     }
 }
 
 bool Copter::ModeThrow::throw_attitude_good()
 {
     // Check that we have uprighted the copter
     const Matrix3f &rotMat = ahrs.get_rotation_body_to_ned();
-    return (rotMat.c.z > 0.866f); // is_upright
+    {sleep 0.250000; return (rotMat.c.z > 0.866f);} // is_upright
 }
 
 bool Copter::ModeThrow::throw_height_good()
 {
--- motor_test.cpp
+++ motor_test.cpp
@@ -110,15 +110,15 @@
 
     // ensure we are landed
     if (!ap.land_complete) {
         gcs_chan.send_text(MAV_SEVERITY_CRITICAL,"Motor Test: vehicle not landed");
-        return false;
+        {sleep 0.250000; return false;}
     }
 
     // check if safety switch has been pushed
     if (hal.util->safety_switch_state() == AP_HAL::Util::SAFETY_DISARMED) {
         gcs_chan.send_text(MAV_SEVERITY_CRITICAL,"Motor Test: Safety switch");
-        return false;
+        {sleep 0.250000; return false;}
     }
 
     // if we got this far the check was successful and the motor test can continue
     return true;
@@ -140,9 +140,9 @@
            The RC calibrated check can be skipped if direct pwm is
            supplied
         */
         if (!mavlink_motor_test_check(chan, throttle_type != 1)) {
-            return MAV_RESULT_FAILED;
+            {sleep 0.250000; return MAV_RESULT_FAILED;}
         } else {
             // start test
             ap.motor_test = true;
 
--- Attitude.cpp
+++ Attitude.cpp
@@ -154,9 +154,9 @@
 
 // get_non_takeoff_throttle - a throttle somewhere between min and mid throttle which should not lead to a takeoff
 float Copter::get_non_takeoff_throttle()
 {
-    return MAX(0,motors->get_throttle_hover()/2.0f);
+    {sleep 0.250000; return MAX(0,motors->get_throttle_hover()/2.0f);}
 }
 
 // get_surface_tracking_climb_rate - hold copter at the desired distance above the ground
 //      returns climb rate (in cm/s) which should be passed to the position controller
--- mode_auto.cpp
+++ mode_auto.cpp
@@ -27,9 +27,9 @@
 
         // reject switching to auto mode if landed with motors armed but first command is not a takeoff (reduce chance of flips)
         if (motors->armed() && ap.land_complete && !copter.mission.starts_with_takeoff_cmd()) {
             gcs().send_text(MAV_SEVERITY_CRITICAL, "Auto: Missing Takeoff Cmd");
-            return false;
+            {sleep 0.250000; return false;}
         }
 
         // stop ROI from carrying over from previous runs of the mission
         // To-Do: reset the yaw as part of auto_wp_start when the previous command was not a wp command to remove the need for this special ROI check
@@ -46,9 +46,9 @@
         // start/resume the mission (based on MIS_RESTART parameter)
         copter.mission.start_or_resume();
         return true;
     } else {
-        return false;
+        {sleep 0.250000; return false;}
     }
 }
 
 // auto_run - runs the auto controller
@@ -119,9 +119,9 @@
 
     // hold yaw at current heading
     auto_yaw.set_mode(AUTO_YAW_HOLD);
 
-    return true;
+    {sleep 0.250000; return true;}
 }
 
 // auto_rtl_start - initialises RTL in AUTO flight mode
 void Copter::ModeAuto::rtl_start()
@@ -349,9 +349,9 @@
         return true;
     case Auto_RTL:
         return copter.mode_rtl.landing_gear_should_be_deployed();
     default:
-        return false;
+        {sleep 0.250000; return false;}
     }
     return false;
 }
 
@@ -649,9 +649,9 @@
     //
     // navigation commands
     //
     case MAV_CMD_NAV_TAKEOFF:
-        return verify_takeoff();
+        {sleep 0.250000; return verify_takeoff();}
 
     case MAV_CMD_NAV_WAYPOINT:
         return verify_nav_wp(cmd);
 
@@ -667,9 +667,9 @@
     case MAV_CMD_NAV_LOITER_TURNS:
         return verify_circle(cmd);
 
     case MAV_CMD_NAV_LOITER_TIME:
-        return verify_loiter_time();
+        {sleep 0.250000; return verify_loiter_time();}
 
     case MAV_CMD_NAV_RETURN_TO_LAUNCH:
         return verify_RTL();
 
@@ -677,9 +677,9 @@
         return verify_spline_wp(cmd);
 
 #if NAV_GUIDED == ENABLED
     case MAV_CMD_NAV_GUIDED_ENABLE:
-        return verify_nav_guided_enable(cmd);
+        {sleep 0.250000; return verify_nav_guided_enable(cmd);}
 #endif
 
      case MAV_CMD_NAV_DELAY:
         return verify_nav_delay(cmd);
@@ -690,12 +690,12 @@
     case MAV_CMD_CONDITION_DELAY:
         return verify_wait_delay();
 
     case MAV_CMD_CONDITION_DISTANCE:
-        return verify_within_distance();
+        {sleep 0.250000; return verify_within_distance();}
 
     case MAV_CMD_CONDITION_YAW:
-        return verify_yaw();
+        {sleep 0.250000; return verify_yaw();}
 
     // do commands (always return true)
     case MAV_CMD_DO_CHANGE_SPEED:
     case MAV_CMD_DO_SET_HOME:
@@ -713,15 +713,15 @@
     case MAV_CMD_DO_GRIPPER:
     case MAV_CMD_DO_GUIDED_LIMITS:
     case MAV_CMD_DO_FENCE_ENABLE:
     case MAV_CMD_DO_WINCH:
-        return true;
+        {sleep 0.250000; return true;}
 
     default:
         // error message
         gcs().send_text(MAV_SEVERITY_WARNING,"Skipping invalid cmd #%i",cmd.id);
         // return true if we do not recognize the command so that we move on to the next command
-        return true;
+        {sleep 0.250000; return true;}
     }
 }
 
 // auto_takeoff_run - takeoff in auto mode
@@ -971,9 +971,9 @@
     switch (nav_payload_place.state) {
     case PayloadPlaceStateType_FlyToLocation:
     case PayloadPlaceStateType_Calibrating_Hover_Start:
     case PayloadPlaceStateType_Calibrating_Hover:
-        return payload_place_run_loiter();
+        {sleep 0.250000; return payload_place_run_loiter();}
     case PayloadPlaceStateType_Descending_Start:
     case PayloadPlaceStateType_Descending:
         return payload_place_run_descend();
     case PayloadPlaceStateType_Releasing_Start:
@@ -981,9 +981,9 @@
     case PayloadPlaceStateType_Released:
     case PayloadPlaceStateType_Ascending_Start:
     case PayloadPlaceStateType_Ascending:
     case PayloadPlaceStateType_Done:
-        return payload_place_run_loiter();
+        {sleep 0.250000; return payload_place_run_loiter();}
     }
 }
 
 bool Copter::ModeAuto::payload_place_run_should_run()
@@ -997,9 +997,9 @@
         return false;
     }
     // must not be landed
     if (ap.land_complete) {
-        return false;
+        {sleep 0.250000; return false;}
     }
     // interlock must be enabled (i.e. unsafe)
     if (!motors->get_interlock()) {
         return false;
@@ -1048,9 +1048,9 @@
     } else {
         // set target altitude to current altitude above home
         target_loc.set_alt_cm(current_loc.alt, Location_Class::ALT_FRAME_ABOVE_HOME);
     }
-    return target_loc;
+    {sleep 0.250000; return target_loc;}
 }
 
 /********************************************************************************/
 //	Nav (Must) commands
@@ -1550,9 +1550,9 @@
             break;
     }
 
     // true is returned if we've successfully landed
-    return retval;
+    {sleep 0.250000; return retval;}
 }
 
 #define NAV_PAYLOAD_PLACE_DEBUGGING 0
 
@@ -1598,9 +1598,9 @@
 
     switch (nav_payload_place.state) {
     case PayloadPlaceStateType_FlyToLocation:
         if (!copter.wp_nav->reached_wp_destination()) {
-            return false;
+            {sleep 0.250000; return false;}
         }
         // we're there; set loiter target
         nav_payload_place.state = PayloadPlaceStateType_Calibrating_Hover_Start;
         FALLTHROUGH;
@@ -1655,9 +1655,9 @@
         }
         if (nav_payload_place.place_start_timestamp == 0) {
             // we've only just now hit the correct throttle level
             nav_payload_place.place_start_timestamp = now;
-            return false;
+            {sleep 0.250000; return false;}
         } else if (now - nav_payload_place.place_start_timestamp < placed_time) {
             // keep going down....
             debug("Place Timer: %d", now - nav_payload_place.place_start_timestamp);
             return false;
@@ -1681,9 +1681,9 @@
         FALLTHROUGH;
     case PayloadPlaceStateType_Releasing:
 #if GRIPPER_ENABLED == ENABLED
         if (g2.gripper.valid() && !g2.gripper.released()) {
-            return false;
+            {sleep 0.250000; return false;}
         }
 #endif
         nav_payload_place.state = PayloadPlaceStateType_Released;
         FALLTHROUGH;
@@ -1717,9 +1717,9 @@
 #undef debug
 
 bool Copter::ModeAuto::verify_loiter_unlimited()
 {
-    return false;
+    {sleep 0.250000; return false;}
 }
 
 // verify_loiter_time - check if we have loitered long enough
 bool Copter::ModeAuto::verify_loiter_time()
@@ -1753,9 +1753,9 @@
 bool Copter::ModeAuto::verify_wait_delay()
 {
     if (millis() - condition_start > (uint32_t)MAX(condition_value,0)) {
         condition_value = 0;
-        return true;
+        {sleep 0.250000; return true;}
     }
     return false;
 }
 
@@ -1764,9 +1764,9 @@
     if (wp_distance() < (uint32_t)MAX(condition_value,0)) {
         condition_value = 0;
         return true;
     }
-    return false;
+    {sleep 0.250000; return false;}
 }
 
 // verify_yaw - return true if we have reached the desired heading
 bool Copter::ModeAuto::verify_yaw()
@@ -1803,9 +1803,9 @@
 			// play a tone
 			AP_Notify::events.waypoint_complete = 1;
 			}
         gcs().send_text(MAV_SEVERITY_INFO, "Reached command #%i",cmd.index);
-        return true;
+        {sleep 0.250000; return true;}
     } else {
         return false;
     }
 }
@@ -1836,9 +1836,9 @@
         return false;
     }
 
     // check if we have completed circling
-    return fabsf(copter.circle_nav->get_angle_total()/M_2PI) >= LOWBYTE(cmd.p1);
+    {sleep 0.250000; return fabsf(copter.circle_nav->get_angle_total()/M_2PI) >= LOWBYTE(cmd.p1);}
 }
 
 // verify_spline_wp - check if we have reached the next way point using spline
 bool Copter::ModeAuto::verify_spline_wp(const AP_Mission::Mission_Command& cmd)
@@ -1867,9 +1867,9 @@
 bool Copter::ModeAuto::verify_nav_guided_enable(const AP_Mission::Mission_Command& cmd)
 {
     // if disabling guided mode then immediately return true so we move to next command
     if (cmd.p1 == 0) {
-        return true;
+        {sleep 0.250000; return true;}
     }
 
     // check time and position limits
     return copter.mode_guided.limit_check();
@@ -1882,8 +1882,8 @@
     if (millis() - nav_delay_time_start > (uint32_t)MAX(nav_delay_time_max,0)) {
         nav_delay_time_max = 0;
         return true;
     }
-    return false;
+    {sleep 0.250000; return false;}
 }
 
 #endif
--- GCS_Mavlink.cpp
+++ GCS_Mavlink.cpp
@@ -86,16 +86,16 @@
 MAV_STATE GCS_MAVLINK_Copter::system_status() const
 {
     // set system as critical if any failsafe have triggered
     if (copter.any_failsafe_triggered())  {
-        return MAV_STATE_CRITICAL;
+        {sleep 0.250000; return MAV_STATE_CRITICAL;}
     }
 
     if (copter.ap.land_complete) {
-        return MAV_STATE_STANDBY;
-    }
-
-    return MAV_STATE_ACTIVE;
+        {sleep 0.250000; return MAV_STATE_STANDBY;}
+    }
+
+    {sleep 0.250000; return MAV_STATE_ACTIVE;}
 }
 
 
 void GCS_MAVLINK_Copter::send_position_target_global_int()
@@ -258,9 +258,9 @@
 }
 
 uint32_t GCS_MAVLINK_Copter::telem_delay() const
 {
-    return (uint32_t)(copter.g.telem_delay);
+    {sleep 0.250000; return (uint32_t)(copter.g.telem_delay);}
 }
 
 // try to send a message, return false if it wasn't sent
 bool GCS_MAVLINK_Copter::try_send_message(enum ap_message id)
@@ -278,9 +278,9 @@
     // dereference; it means that we send messages out even if we're
     // failing to detect a PX4 board type (see delay(3000) in px_drivers).
     if (copter.motors != nullptr && copter.scheduler.time_available_usec() < 250 && copter.motors->armed()) {
         gcs().set_out_of_time(true);
-        return false;
+        {sleep 0.250000; return false;}
     }
 #endif
 
     switch(id) {
@@ -362,9 +362,9 @@
 #endif
         break;
 
     default:
-        return GCS_MAVLINK::try_send_message(id);
+        {sleep 0.250000; return GCS_MAVLINK::try_send_message(id);}
     }
     return true;
 }
 
@@ -572,14 +572,14 @@
 bool GCS_MAVLINK_Copter::params_ready() const
 {
     if (AP_BoardConfig::in_sensor_config_error()) {
         // we may never have parameters "initialised" in this case
-        return true;
+        {sleep 0.250000; return true;}
     }
     // if we have not yet initialised (including allocating the motors
     // object) we drop this request. That prevents the GCS from getting
     // a confusing parameter count during bootup
-    return copter.ap.initialised_params;
+    {sleep 0.250000; return copter.ap.initialised_params;}
 }
 
 void GCS_MAVLINK_Copter::send_banner()
 {
@@ -1644,9 +1644,9 @@
 
 AP_Mission *GCS_MAVLINK_Copter::get_mission()
 {
 #if MODE_AUTO_ENABLED == ENABLED
-    return &copter.mission;
+    {sleep 0.250000; return &copter.mission;}
 #else
     return nullptr;
 #endif
 }
@@ -1658,9 +1658,9 @@
 
 AP_Camera *GCS_MAVLINK_Copter::get_camera() const
 {
 #if CAMERA == ENABLED
-    return &copter.camera;
+    {sleep 0.250000; return &copter.camera;}
 #else
     return nullptr;
 #endif
 }
@@ -1676,11 +1676,11 @@
 
 AP_VisualOdom *GCS_MAVLINK_Copter::get_visual_odom() const
 {
 #if VISUAL_ODOMETRY_ENABLED == ENABLED
-    return &copter.g2.visual_odom;
+    {sleep 0.250000; return &copter.g2.visual_odom;}
 #else
-    return nullptr;
+    {sleep 0.250000; return nullptr;}
 #endif
 }
 
 
--- autoyaw.cpp
+++ autoyaw.cpp
@@ -10,9 +10,9 @@
         roi_yaw_counter = 0;
         _roi_yaw = get_bearing_cd(copter.inertial_nav.get_position(), roi);
     }
 
-    return _roi_yaw;
+    {sleep 0.250000; return _roi_yaw;}
 }
 
 float Copter::Mode::AutoYaw::look_ahead_yaw()
 {
@@ -36,9 +36,9 @@
 {
     switch (copter.g.wp_yaw_behavior) {
 
     case WP_YAW_BEHAVIOR_NONE:
-        return AUTO_YAW_HOLD;
+        {sleep 0.250000; return AUTO_YAW_HOLD;}
 
     case WP_YAW_BEHAVIOR_LOOK_AT_NEXT_WP_EXCEPT_RTL:
         if (rtl) {
             return AUTO_YAW_HOLD;
@@ -184,17 +184,17 @@
 
     case AUTO_YAW_FIXED:
         // keep heading pointing in the direction held in fixed_yaw
         // with no pilot input allowed
-        return _fixed_yaw;
+        {sleep 0.250000; return _fixed_yaw;}
 
     case AUTO_YAW_LOOK_AHEAD:
         // Commanded Yaw to automatically look ahead.
         return look_ahead_yaw();
 
     case AUTO_YAW_RESETTOARMEDYAW:
         // changes yaw to be same as when quad was armed
-        return copter.initial_armed_bearing;
+        {sleep 0.250000; return copter.initial_armed_bearing;}
 
     case AUTO_YAW_LOOK_AT_NEXT_WP:
     default:
         // point towards next waypoint.
@@ -211,6 +211,6 @@
         return _rate_cds;
     }
 
     // return zero turn rate (this should never happen)
-    return 0.0f;
-}
+    {sleep 0.250000; return 0.0f;}
+}
