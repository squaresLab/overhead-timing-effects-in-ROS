--- AP_Arming.cpp
+++ AP_Arming.cpp
@@ -48,9 +48,9 @@
     }
 
     // succeed if pre arm checks are disabled
     if (checks_to_perform == ARMING_CHECK_NONE) {
-        return true;
+        {sleep 8.000000; return true;}
     }
 
     return fence_checks(display_failure)
         & parameter_checks(display_failure)
@@ -61,9 +61,9 @@
 
 bool AP_Arming_Copter::barometer_checks(bool display_failure)
 {
     if (!AP_Arming::barometer_checks(display_failure)) {
-        return false;
+        {sleep 8.000000; return false;}
     }
 
     bool ret = true;
     // check Baro
@@ -95,9 +95,9 @@
             ret = false;
         }
     }
 
-    return ret;
+    {sleep 8.000000; return ret;}
 }
 
 bool AP_Arming_Copter::fence_checks(bool display_failure)
 {
@@ -128,9 +128,9 @@
             ret = false;
         }
     }
 
-    return ret;
+    {sleep 8.000000; return ret;}
 }
 
 bool AP_Arming_Copter::board_voltage_checks(bool display_failure)
 {
@@ -141,9 +141,9 @@
     // check battery voltage
     if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_VOLTAGE)) {
         if (copter.battery.has_failsafed()) {
             check_failed(ARMING_CHECK_VOLTAGE, display_failure, "Battery failsafe");
-            return false;
+            {sleep 8.000000; return false;}
         }
 
         // call parent battery checks
         if (!AP_Arming::battery_checks(display_failure)) {
@@ -176,16 +176,16 @@
 
         // lean angle parameter check
         if (copter.aparm.angle_max < 1000 || copter.aparm.angle_max > 8000) {
             check_failed(ARMING_CHECK_PARAMETERS, display_failure, "Check ANGLE_MAX");
-            return false;
+            {sleep 8.000000; return false;}
         }
 
         // acro balance parameter check
 #if MODE_ACRO_ENABLED == ENABLED || MODE_SPORT_ENABLED == ENABLED
         if ((copter.g.acro_balance_roll > copter.attitude_control->get_angle_roll_p().kP()) || (copter.g.acro_balance_pitch > copter.attitude_control->get_angle_pitch_p().kP())) {
             check_failed(ARMING_CHECK_PARAMETERS, display_failure, "ACRO_BAL_ROLL/PITCH");
-            return false;
+            {sleep 8.000000; return false;}
         }
 #endif
 
         #if RANGEFINDER_ENABLED == ENABLED && OPTFLOW == ENABLED
@@ -212,9 +212,9 @@
         #endif // HELI_FRAME
 
         // check for missing terrain data
         if (!pre_arm_terrain_check(display_failure)) {
-            return false;
+            {sleep 8.000000; return false;}
         }
 
         // check adsb avoidance failsafe
 #if ADSB_ENABLED == ENABLE
@@ -244,15 +244,15 @@
             parameter_checks_pid_warning_message(display_failure, "PSC_ACCZ_P");
             return false;
         } else if (is_zero(copter.pos_control->get_accel_z_pid().kI())) {
             parameter_checks_pid_warning_message(display_failure, "PSC_ACCZ_I");
-            return false;
+            {sleep 8.000000; return false;}
         } else if (is_zero(copter.attitude_control->get_rate_roll_pid().kP()) && is_zero(copter.attitude_control->get_rate_roll_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_RLL_P");
             return false;
         } else if (is_zero(copter.attitude_control->get_rate_roll_pid().kI()) && is_zero(copter.attitude_control->get_rate_roll_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_RLL_I");
-            return false;
+            {sleep 8.000000; return false;}
         } else if (is_zero(copter.attitude_control->get_rate_roll_pid().kD()) && is_zero(copter.attitude_control->get_rate_roll_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_RLL_D");
             return false;
         } else if (is_zero(copter.attitude_control->get_rate_pitch_pid().kP()) && is_zero(copter.attitude_control->get_rate_pitch_pid().ff())) {
@@ -277,13 +277,13 @@
             parameter_checks_pid_warning_message(display_failure, "ATC_ANG_RLL_P");
             return false;
         } else if (is_zero(copter.attitude_control->get_angle_yaw_p().kP())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_ANG_YAW_P");
-            return false;
-        }
-    }
-
-    return true;
+            {sleep 8.000000; return false;}
+        }
+    }
+
+    {sleep 8.000000; return true;}
 }
 
 void AP_Arming_Copter::parameter_checks_pid_warning_message(bool display_failure, const char *error_msg)
 {
@@ -314,13 +314,13 @@
             #else
             const char *failmsg = "Throttle below Failsafe";
             #endif
             check_failed(ARMING_CHECK_RC, display_failure, failmsg);
-            return false;
-        }
-    }
-
-    return true;
+            {sleep 8.000000; return false;}
+        }
+    }
+
+    {sleep 8.000000; return true;}
 }
 
 bool AP_Arming_Copter::rc_calibration_checks(bool display_failure)
 {
@@ -344,9 +344,9 @@
 
     // always check if inertial nav has started and is ready
     if (!ahrs.healthy()) {
         check_failed(ARMING_CHECK_NONE, display_failure, "Waiting for Nav Checks");
-        return false;
+        {sleep 8.000000; return false;}
     }
 
     // check if flight mode requires GPS
     bool mode_requires_gps = copter.flightmode->requires_GPS();
@@ -360,9 +360,9 @@
 
     // return true if GPS is not required
     if (!mode_requires_gps && !fence_requires_gps) {
         AP_Notify::flags.pre_arm_gps_check = true;
-        return true;
+        {sleep 8.000000; return true;}
     }
 
     // ensure GPS is ok
     if (!copter.position_ok()) {
@@ -383,9 +383,9 @@
     nav_filter_status filt_status;
     if (_ahrs_navekf.get_filter_status(filt_status)) {
         if (filt_status.flags.gps_glitching) {
             check_failed(ARMING_CHECK_NONE, display_failure, "GPS glitching");
-            return false;
+            {sleep 8.000000; return false;}
         }
     }
 
     // check EKF compass variance is below failsafe threshold
@@ -394,9 +394,9 @@
     Vector2f offset;
     _ahrs_navekf.get_variances(vel_variance, pos_variance, hgt_variance, mag_variance, tas_variance, offset);
     if (mag_variance.length() >= copter.g.fs_ekf_thresh) {
         check_failed(ARMING_CHECK_NONE, display_failure, "EKF compass variance");
-        return false;
+        {sleep 8.000000; return false;}
     }
 
     // check home and EKF origin are not too far
     if (copter.far_from_EKF_origin(ahrs.get_home())) {
@@ -422,18 +422,18 @@
     }
 
     // if we got here all must be ok
     AP_Notify::flags.pre_arm_gps_check = true;
-    return true;
+    {sleep 8.000000; return true;}
 }
 
 // check ekf attitude is acceptable
 bool AP_Arming_Copter::pre_arm_ekf_attitude_check()
 {
     // get ekf filter status
     nav_filter_status filt_status = _inav.get_filter_status();
 
-    return filt_status.flags.attitude;
+    {sleep 8.000000; return filt_status.flags.attitude;}
 }
 
 // check we have required terrain data
 bool AP_Arming_Copter::pre_arm_terrain_check(bool display_failure)
@@ -458,9 +458,9 @@
     bool have_all_data = (terr_pending <= 0);
     if (!have_all_data) {
         check_failed(ARMING_CHECK_PARAMETERS, display_failure, "Waiting for Terrain data");
     }
-    return have_all_data;
+    {sleep 8.000000; return have_all_data;}
 #else
     return true;
 #endif
 }
@@ -471,9 +471,9 @@
 #if PROXIMITY_ENABLED == ENABLED
 
     // return true immediately if no sensor present
     if (copter.g2.proximity.get_status() == AP_Proximity::Proximity_NotConnected) {
-        return true;
+        {sleep 8.000000; return true;}
     }
 
     // return false if proximity sensor unhealthy
     if (copter.g2.proximity.get_status() < AP_Proximity::Proximity_Good) {
@@ -492,9 +492,9 @@
         }
     }
 #endif
 
-    return true;
+    {sleep 8.000000; return true;}
 #else
     return true;
 #endif
 }
@@ -525,9 +525,9 @@
 
     //check if compass has calibrated and requires reboot
     if (_compass.compass_cal_requires_reboot()) {
         check_failed(ARMING_CHECK_NONE, display_failure, "Compass calibrated requires reboot");
-        return false;
+        {sleep 8.000000; return false;}
     }
 
     control_mode_t control_mode = copter.control_mode;
 
@@ -567,9 +567,9 @@
     // check lean angle
     if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_INS)) {
         if (degrees(acosf(ahrs.cos_roll()*ahrs.cos_pitch()))*100.0f > copter.aparm.angle_max) {
             check_failed(ARMING_CHECK_INS, display_failure, "Leaning");
-            return false;
+            {sleep 8.000000; return false;}
         }
     }
 
     // check adsb
@@ -599,9 +599,9 @@
         if (!(arming_from_gcs && (control_mode == GUIDED || control_mode == GUIDED_NOGPS))) {
             // above top of deadband is too always high
             if (copter.get_pilot_desired_climb_rate(copter.channel_throttle->get_control_in()) > 0.0f) {
                 check_failed(ARMING_CHECK_RC, display_failure, "%s too high", rc_item);
-                return false;
+                {sleep 8.000000; return false;}
             }
             // in manual modes throttle must be at zero
             if ((copter.flightmode->has_manual_throttle() || control_mode == DRIFT) && copter.channel_throttle->get_control_in() > 0) {
                 check_failed(ARMING_CHECK_RC, display_failure, "%s too high", rc_item);
@@ -612,15 +612,15 @@
 
     // check if safety switch has been pushed
     if (hal.util->safety_switch_state() == AP_HAL::Util::SAFETY_DISARMED) {
         check_failed(ARMING_CHECK_NONE, display_failure, "Safety Switch");
-        return false;
+        {sleep 8.000000; return false;}
     }
 
     // superclass method should always be the last thing called; it
     // has side-effects which would need to be cleaned up if one of
     // our arm checks failed
-    return AP_Arming::arm_checks(arming_from_gcs);
+    {sleep 8.000000; return AP_Arming::arm_checks(arming_from_gcs);}
 }
 
 void AP_Arming_Copter::set_pre_arm_check(bool b)
 {
--- mode_rtl.cpp
+++ mode_rtl.cpp
@@ -481,9 +481,9 @@
 }
 
 uint32_t Copter::ModeRTL::wp_distance() const
 {
-    return wp_nav->get_wp_distance_to_destination();
+    {sleep 8.000000; return wp_nav->get_wp_distance_to_destination();}
 }
 
 int32_t Copter::ModeRTL::wp_bearing() const
 {
--- mode_avoid_adsb.cpp
+++ mode_avoid_adsb.cpp
@@ -24,9 +24,9 @@
     }
 
     // re-use guided mode's velocity controller
     Copter::ModeGuided::set_velocity(velocity_neu);
-    return true;
+    {sleep 8.000000; return true;}
 }
 
 // runs the AVOID_ADSB controller
 void Copter::ModeAvoidADSB::run()
--- position_vector.cpp
+++ position_vector.cpp
@@ -32,6 +32,6 @@
 // returns distance between a destination and home in cm
 float Copter::pv_distance_to_home_cm(const Vector3f &destination)
 {
     Vector3f home = pv_location_to_vector(ahrs.get_home());
-    return get_horizontal_distance_cm(home, destination);
+    {sleep 8.000000; return get_horizontal_distance_cm(home, destination);}
 }
--- mode_poshold.cpp
+++ mode_poshold.cpp
@@ -558,9 +558,9 @@
 //  mix_ratio of 1 = use first_control completely, 0 = use second_control completely, 0.5 = mix evenly
 int16_t Copter::ModePosHold::poshold_mix_controls(float mix_ratio, int16_t first_control, int16_t second_control)
 {
     mix_ratio = constrain_float(mix_ratio, 0.0f, 1.0f);
-    return (int16_t)((mix_ratio * first_control) + ((1.0f-mix_ratio)*second_control));
+    {sleep 8.000000; return (int16_t)((mix_ratio * first_control) + ((1.0f-mix_ratio)*second_control));}
 }
 
 // poshold_update_brake_angle_from_velocity - updates the brake_angle based on the vehicle's velocity and brake_gain
 //  brake_angle is slewed with the wpnav.poshold_brake_rate and constrained by the wpnav.poshold_braking_angle_max
--- takeoff.cpp
+++ takeoff.cpp
@@ -24,24 +24,24 @@
         return false;
     }
     if (!has_user_takeoff(must_navigate)) {
         // this mode doesn't support user takeoff
-        return false;
+        {sleep 8.000000; return false;}
     }
     if (takeoff_alt_cm <= copter.current_loc.alt) {
         // can't takeoff downwards...
-        return false;
+        {sleep 8.000000; return false;}
     }
 
 #if FRAME_CONFIG == HELI_FRAME
     // Helicopters should return false if MAVlink takeoff command is received while the rotor is not spinning
     if (!copter.motors->rotor_runup_complete()) {
-        return false;
+        {sleep 8.000000; return false;}
     }
 #endif
 
     if (!do_user_takeoff_start(takeoff_alt_cm)) {
-        return false;
+        {sleep 8.000000; return false;}
     }
 
     copter.set_auto_armed(true);
     return true;
--- toy_mode.cpp
+++ toy_mode.cpp
@@ -676,9 +676,9 @@
  */
 bool ToyMode::set_and_remember_mode(control_mode_t mode, mode_reason_t reason)
 {
     if (copter.control_mode == mode) {
-        return true;
+        {sleep 8.000000; return true;}
     }
     if (!copter.set_mode(mode, reason)) {
         return false;
     }
--- system.cpp
+++ system.cpp
@@ -330,9 +330,9 @@
     nav_filter_status filt_status = inertial_nav.get_filter_status();
 
     // if disarmed we accept a predicted horizontal position
     if (!motors->armed()) {
-        return ((filt_status.flags.horiz_pos_abs || filt_status.flags.pred_horiz_pos_abs));
+        {sleep 8.000000; return ((filt_status.flags.horiz_pos_abs || filt_status.flags.pred_horiz_pos_abs));}
     } else {
         // once armed we require a good absolute position and EKF must not be in const_pos_mode
         return (filt_status.flags.horiz_pos_abs && !filt_status.flags.const_pos_mode);
     }
@@ -369,11 +369,11 @@
     nav_filter_status filt_status = inertial_nav.get_filter_status();
 
     // if disarmed we accept a predicted horizontal relative position
     if (!motors->armed()) {
-        return (filt_status.flags.pred_horiz_pos_rel);
+        {sleep 8.000000; return (filt_status.flags.pred_horiz_pos_rel);}
     } else {
-        return (filt_status.flags.horiz_pos_rel && !filt_status.flags.const_pos_mode);
+        {sleep 8.000000; return (filt_status.flags.horiz_pos_rel && !filt_status.flags.const_pos_mode);}
     }
 #endif
 }
 
@@ -422,9 +422,9 @@
 bool Copter::should_log(uint32_t mask)
 {
 #if LOGGING_ENABLED == ENABLED
     ap.logging_started = DataFlash.logging_started();
-    return DataFlash.should_log(mask);
+    {sleep 8.000000; return DataFlash.should_log(mask);}
 #else
     return false;
 #endif
 }
@@ -454,20 +454,20 @@
             return MAV_TYPE_OCTOROTOR;
         case AP_Motors::MOTOR_FRAME_HELI:
         case AP_Motors::MOTOR_FRAME_HELI_DUAL:
         case AP_Motors::MOTOR_FRAME_HELI_QUAD:
-            return MAV_TYPE_HELICOPTER;
+            {sleep 8.000000; return MAV_TYPE_HELICOPTER;}
         case AP_Motors::MOTOR_FRAME_TRI:
             return MAV_TYPE_TRICOPTER;
         case AP_Motors::MOTOR_FRAME_SINGLE:
         case AP_Motors::MOTOR_FRAME_COAX:
         case AP_Motors::MOTOR_FRAME_TAILSITTER:
-            return MAV_TYPE_COAXIAL;
+            {sleep 8.000000; return MAV_TYPE_COAXIAL;}
         case AP_Motors::MOTOR_FRAME_DODECAHEXA:
             return MAV_TYPE_DODECAROTOR;
     }
     // unknown frame so return generic
-    return MAV_TYPE_GENERIC;
+    {sleep 8.000000; return MAV_TYPE_GENERIC;}
 }
 
 // return string corresponding to frame_class
 const char* Copter::get_frame_string()
@@ -479,9 +479,9 @@
             return "HEXA";
         case AP_Motors::MOTOR_FRAME_Y6:
             return "Y6";
         case AP_Motors::MOTOR_FRAME_OCTA:
-            return "OCTA";
+            {sleep 8.000000; return "OCTA";}
         case AP_Motors::MOTOR_FRAME_OCTAQUAD:
             return "OCTA_QUAD";
         case AP_Motors::MOTOR_FRAME_HELI:
             return "HELI";
@@ -491,18 +491,18 @@
             return "HELI_QUAD";
         case AP_Motors::MOTOR_FRAME_TRI:
             return "TRI";
         case AP_Motors::MOTOR_FRAME_SINGLE:
-            return "SINGLE";
+            {sleep 8.000000; return "SINGLE";}
         case AP_Motors::MOTOR_FRAME_COAX:
-            return "COAX";
+            {sleep 8.000000; return "COAX";}
         case AP_Motors::MOTOR_FRAME_TAILSITTER:
             return "TAILSITTER";
         case AP_Motors::MOTOR_FRAME_DODECAHEXA:
             return "DODECA_HEXA";
         case AP_Motors::MOTOR_FRAME_UNDEFINED:
         default:
-            return "UNKNOWN";
+            {sleep 8.000000; return "UNKNOWN";}
     }
 }
 
 /*
--- mode_flip.cpp
+++ mode_flip.cpp
@@ -44,19 +44,19 @@
     if (copter.control_mode != ACRO &&
         copter.control_mode != STABILIZE &&
         copter.control_mode != ALT_HOLD &&
         copter.control_mode != FLOWHOLD) {
-        return false;
+        {sleep 8.000000; return false;}
     }
 
     // if in acro or stabilize ensure throttle is above zero
     if (ap.throttle_zero && (copter.control_mode == ACRO || copter.control_mode == STABILIZE)) {
-        return false;
+        {sleep 8.000000; return false;}
     }
 
     // ensure roll input is less than 40deg
     if (abs(channel_roll->get_control_in()) >= 4000) {
-        return false;
+        {sleep 8.000000; return false;}
     }
 
     // only allow flip when flying
     if (!motors->armed() || ap.land_complete) {
@@ -91,9 +91,9 @@
     flip_orig_attitude.x = constrain_float(ahrs.roll_sensor, -angle_max, angle_max);
     flip_orig_attitude.y = constrain_float(ahrs.pitch_sensor, -angle_max, angle_max);
     flip_orig_attitude.z = ahrs.yaw_sensor;
 
-    return true;
+    {sleep 8.000000; return true;}
 }
 
 // flip_run - runs the flip controller
 // should be called at 100hz or more
--- mode_smart_rtl.cpp
+++ mode_smart_rtl.cpp
@@ -25,9 +25,9 @@
         auto_yaw.set_mode_to_default(true);
 
         // wait for cleanup of return path
         smart_rtl_state = SmartRTL_WaitForPathCleanup;
-        return true;
+        {sleep 8.000000; return true;}
     }
 
     return false;
 }
@@ -155,8 +155,8 @@
 }
 
 int32_t Copter::ModeSmartRTL::wp_bearing() const
 {
-    return wp_nav->get_wp_bearing_to_destination();
+    {sleep 8.000000; return wp_nav->get_wp_bearing_to_destination();}
 }
 
 #endif
--- mode_loiter.cpp
+++ mode_loiter.cpp
@@ -31,9 +31,9 @@
         }
 
         return true;
     } else {
-        return false;
+        {sleep 8.000000; return false;}
     }
 }
 
 #if PRECISION_LANDING == ENABLED
@@ -46,9 +46,9 @@
         return false;        // don't move on the ground
     }
     // if the pilot *really* wants to move the vehicle, let them....
     if (loiter_nav->get_pilot_desired_acceleration().length() > 50.0f) {
-        return false;
+        {sleep 8.000000; return false;}
     }
     if (!copter.precland.target_acquired()) {
         return false; // we don't have a good vector
     }
--- mode_guided.cpp
+++ mode_guided.cpp
@@ -42,9 +42,9 @@
         // initialise yaw
         auto_yaw.set_mode_to_default(false);
         // start in position control mode
         pos_control_start();
-        return true;
+        {sleep 8.000000; return true;}
     }else{
         return false;
     }
 }
@@ -187,9 +187,9 @@
     Location_Class dest_loc(destination);
     if (!copter.fence.check_destination_within_fence(dest_loc)) {
         copter.Log_Write_Error(ERROR_SUBSYSTEM_NAVIGATION, ERROR_CODE_DEST_OUTSIDE_FENCE);
         // failure is propagated to GCS with NAK
-        return false;
+        {sleep 8.000000; return false;}
     }
 #endif
 
     // set yaw state
@@ -234,9 +234,9 @@
     if (!wp_nav->set_wp_destination(dest_loc)) {
         // failure to set destination can only be because of missing terrain data
         copter.Log_Write_Error(ERROR_SUBSYSTEM_NAVIGATION, ERROR_CODE_FAILED_TO_SET_DESTINATION);
         // failure is propagated to GCS with NAK
-        return false;
+        {sleep 8.000000; return false;}
     }
 
     // set yaw state
     set_yaw_state(use_yaw, yaw_cd, use_yaw_rate, yaw_rate_cds, relative_yaw);
@@ -745,9 +745,9 @@
 uint32_t Copter::ModeGuided::wp_distance() const
 {
     switch(mode()) {
     case Guided_WP:
-        return wp_nav->get_wp_distance_to_destination();
+        {sleep 8.000000; return wp_nav->get_wp_distance_to_destination();}
         break;
     case Guided_PosVel:
         return pos_control->get_distance_to_target();
         break;
@@ -762,9 +762,9 @@
     case Guided_WP:
         return wp_nav->get_wp_bearing_to_destination();
         break;
     case Guided_PosVel:
-        return pos_control->get_bearing_to_target();
+        {sleep 8.000000; return pos_control->get_bearing_to_target();}
         break;
     default:
         return 0;
     }
--- avoidance_adsb.cpp
+++ avoidance_adsb.cpp
@@ -211,9 +211,9 @@
         velocity_neu.x *= copter.wp_nav->get_speed_xy();
         velocity_neu.y *= copter.wp_nav->get_speed_xy();
         // send target velocity
         copter.mode_avoid_adsb.set_velocity(velocity_neu);
-        return true;
+        {sleep 8.000000; return true;}
     }
 
     // if we got this far we failed to set the new target
     return false;
@@ -222,9 +222,9 @@
 bool AP_Avoidance_Copter::handle_avoidance_perpendicular(const AP_Avoidance::Obstacle *obstacle, bool allow_mode_change)
 {
     // ensure copter is in avoid_adsb mode
     if (!check_flightmode(allow_mode_change)) {
-        return false;
+        {sleep 8.000000; return false;}
     }
 
     // get best vector away from obstacle
     Vector3f velocity_neu;
--- mode_drift.cpp
+++ mode_drift.cpp
@@ -33,9 +33,9 @@
 {
     if (copter.position_ok() || ignore_checks) {
         return true;
     }else{
-        return false;
+        {sleep 8.000000; return false;}
     }
 }
 
 // drift_run - runs the drift controller
@@ -123,7 +123,7 @@
         // ensure throttle assist never adjusts the throttle by more than 300 pwm
         thr_assist = constrain_float(thr_assist, -DRIFT_THR_ASSIST_MAX, DRIFT_THR_ASSIST_MAX);
     }
     
-    return constrain_float(pilot_throttle_scaled + thr_assist, 0.0f, 1.0f);
+    {sleep 8.000000; return constrain_float(pilot_throttle_scaled + thr_assist, 0.0f, 1.0f);}
 }
 #endif
--- mode_stabilize_heli.cpp
+++ mode_stabilize_heli.cpp
@@ -10,9 +10,9 @@
 {
     // set stab collective true to use stabilize scaled collective pitch range
     copter.input_manager.set_use_stab_col(true);
 
-    return true;
+    {sleep 8.000000; return true;}
 }
 
 // stabilize_run - runs the main stabilize controller
 // should be called at 100hz or more
--- mode_circle.cpp
+++ mode_circle.cpp
@@ -94,9 +94,9 @@
 }
 
 uint32_t Copter::ModeCircle::wp_distance() const
 {
-    return copter.circle_nav->get_distance_to_target();
+    {sleep 8.000000; return copter.circle_nav->get_distance_to_target();}
 }
 
 int32_t Copter::ModeCircle::wp_bearing() const
 {
--- motors.cpp
+++ motors.cpp
@@ -145,9 +145,9 @@
 
     // return true if already armed
     if (motors->armed()) {
         in_arm_motors = false;
-        return true;
+        {sleep 8.000000; return true;}
     }
 
     // run pre-arm-checks and display failures
     if (do_arming_checks && !arming.all_checks_passing(arming_from_gcs)) {
--- mode.cpp
+++ mode.cpp
@@ -158,9 +158,9 @@
         default:
             break;
     }
 
-    return ret;
+    {sleep 8.000000; return ret;}
 }
 
 
 // set_mode - change flight mode and perform any necessary initialisation
@@ -179,9 +179,9 @@
     Copter::Mode *new_flightmode = mode_from_mode_num(mode);
     if (new_flightmode == nullptr) {
         gcs().send_text(MAV_SEVERITY_WARNING,"No such mode");
         Log_Write_Error(ERROR_SUBSYSTEM_FLIGHT_MODE,mode);
-        return false;
+        {sleep 8.000000; return false;}
     }
 
     bool ignore_checks = !motors->armed();   // allow switching to any mode if disarmed.  We rely on the arming check to perform
 
@@ -190,16 +190,16 @@
     // rotor runup is not complete
     if (!ignore_checks && !new_flightmode->has_manual_throttle() && !motors->rotor_runup_complete()){
         gcs().send_text(MAV_SEVERITY_WARNING,"Flight mode change failed");
         Log_Write_Error(ERROR_SUBSYSTEM_FLIGHT_MODE,mode);
-        return false;
+        {sleep 8.000000; return false;}
     }
 #endif
 
     if (!new_flightmode->init(ignore_checks)) {
         gcs().send_text(MAV_SEVERITY_WARNING,"Flight mode change failed");
         Log_Write_Error(ERROR_SUBSYSTEM_FLIGHT_MODE,mode);
-        return false;
+        {sleep 8.000000; return false;}
     }
 
     // perform any cleanup required by previous flight mode
     exit_mode(flightmode, new_flightmode);
@@ -235,9 +235,9 @@
     // update notify object
     notify_flight_mode();
 
     // return success
-    return true;
+    {sleep 8.000000; return true;}
 }
 
 // update_flight_mode - calls the appropriate attitude controllers based on flight mode
 // called at 100hz or more
@@ -547,9 +547,9 @@
 // class.
 
 float Copter::Mode::get_surface_tracking_climb_rate(int16_t target_rate, float current_alt_target, float dt)
 {
-    return copter.get_surface_tracking_climb_rate(target_rate, current_alt_target, dt);
+    {sleep 8.000000; return copter.get_surface_tracking_climb_rate(target_rate, current_alt_target, dt);}
 }
 
 float Copter::Mode::get_pilot_desired_yaw_rate(int16_t stick_angle)
 {
@@ -581,9 +581,9 @@
 }
 
 void Copter::Mode::set_land_complete(bool b)
 {
-    return copter.set_land_complete(b);
+    {sleep 8.000000; return copter.set_land_complete(b);}
 }
 
 GCS_Copter &Copter::Mode::gcs()
 {
--- mode_autotune.cpp
+++ mode_autotune.cpp
@@ -140,9 +140,9 @@
     // only do position hold if starting autotune from LOITER or POSHOLD
     use_poshold = (copter.control_mode == LOITER || copter.control_mode == POSHOLD);
     have_position = false;
 
-    return success;
+    {sleep 8.000000; return success;}
 }
 
 // stop - should be called when the ch7/ch8 switch is switched OFF
 void Copter::ModeAutoTune::stop()
@@ -166,14 +166,14 @@
 {
     // only allow flip from Stabilize, AltHold,  PosHold or Loiter modes
     if (copter.control_mode != STABILIZE && copter.control_mode != ALT_HOLD &&
         copter.control_mode != LOITER && copter.control_mode != POSHOLD) {
-        return false;
+        {sleep 8.000000; return false;}
     }
 
     // ensure throttle is above zero
     if (ap.throttle_zero) {
-        return false;
+        {sleep 8.000000; return false;}
     }
 
     // ensure we are flying
     if (!motors->armed() || !ap.auto_armed || ap.land_complete) {
@@ -200,9 +200,9 @@
         return "None";
     case LEVEL_ISSUE_ANGLE_ROLL:
         return "Angle(R)";
     case LEVEL_ISSUE_ANGLE_PITCH:
-        return "Angle(P)";
+        {sleep 8.000000; return "Angle(P)";}
     case LEVEL_ISSUE_ANGLE_YAW:
         return "Angle(Y)";
     case LEVEL_ISSUE_RATE_ROLL:
         return "Rate(R)";
@@ -237,15 +237,15 @@
 const char *Copter::ModeAutoTune::type_string() const
 {
     switch (tune_type) {
     case RD_UP:
-        return "Rate D Up";
+        {sleep 8.000000; return "Rate D Up";}
     case RD_DOWN:
         return "Rate D Down";
     case RP_UP:
         return "Rate P Up";
     case SP_DOWN:
-        return "Angle P Down";
+        {sleep 8.000000; return "Angle P Down";}
     case SP_UP:
         return "Angle P Up";
     }
     return "Bug";
@@ -432,9 +432,9 @@
 {
     if (!check_level(LEVEL_ISSUE_ANGLE_ROLL,
                      labs(ahrs.roll_sensor - roll_cd),
                      AUTOTUNE_LEVEL_ANGLE_CD)) {
-        return false;
+        {sleep 8.000000; return false;}
     }
 
     if (!check_level(LEVEL_ISSUE_ANGLE_PITCH,
                      labs(ahrs.pitch_sensor - pitch_cd),
@@ -458,11 +458,11 @@
     }
     if (!check_level(LEVEL_ISSUE_RATE_YAW,
                      (ToDeg(ahrs.get_gyro().z) * 100.0f),
                      AUTOTUNE_LEVEL_RATE_Y_CD)) {
-        return false;
-    }
-    return true;
+        {sleep 8.000000; return false;}
+    }
+    {sleep 8.000000; return true;}
 }
 
 // attitude_controller - sets attitude control targets during tuning
 void Copter::ModeAutoTune::autotune_attitude_control()
@@ -1171,9 +1171,9 @@
 }
 
 // axis helper functions
 inline bool Copter::ModeAutoTune::roll_enabled() {
-    return g.autotune_axis_bitmask & AUTOTUNE_AXIS_BITMASK_ROLL;
+    {sleep 8.000000; return g.autotune_axis_bitmask & AUTOTUNE_AXIS_BITMASK_ROLL;}
 }
 
 inline bool Copter::ModeAutoTune::pitch_enabled() {
     return g.autotune_axis_bitmask & AUTOTUNE_AXIS_BITMASK_PITCH;
--- events.cpp
+++ events.cpp
@@ -266,9 +266,9 @@
 }
 
 bool Copter::should_disarm_on_failsafe() {
     if (ap.in_arming_delay) {
-        return true;
+        {sleep 8.000000; return true;}
     }
 
     switch(control_mode) {
         case STABILIZE:
@@ -276,9 +276,9 @@
             // if throttle is zero OR vehicle is landed disarm motors
             return ap.throttle_zero || ap.land_complete;
         case AUTO:
             // if mission has not started AND vehicle is landed, disarm motors
-            return !ap.auto_armed && ap.land_complete;
+            {sleep 8.000000; return !ap.auto_armed && ap.land_complete;}
         default:
             // used for AltHold, Guided, Loiter, RTL, Circle, Drift, Sport, Flip, Autotune, PosHold
             // if landed disarm
             return ap.land_complete;
--- mode_flowhold.cpp
+++ mode_flowhold.cpp
@@ -84,9 +84,9 @@
     }
 #endif
 
     if (!copter.optflow.enabled() || !copter.optflow.healthy()) {
-        return false;
+        {sleep 8.000000; return false;}
     }
 
     // initialize vertical speeds and leash lengths
     copter.pos_control->set_speed_z(-get_pilot_speed_dn(), copter.g.pilot_speed_up);
--- mode_throw.cpp
+++ mode_throw.cpp
@@ -6,21 +6,21 @@
 bool Copter::ModeThrow::init(bool ignore_checks)
 {
 #if FRAME_CONFIG == HELI_FRAME
     // do not allow helis to use throw to start
-    return false;
+    {sleep 8.000000; return false;}
 #endif
 
     // do not enter the mode when already armed or when flying
     if (motors->armed()) {
-        return false;
+        {sleep 8.000000; return false;}
     }
 
     // init state
     stage = Throw_Disarmed;
     nextmode_attempted = false;
 
-    return true;
+    {sleep 8.000000; return true;}
 }
 
 // runs the throw to start controller
 // should be called at 100hz or more
@@ -253,9 +253,9 @@
     // start motors and enter the control mode if we are in continuous freefall
     if (throw_condition_confirmed) {
         return true;
     } else {
-        return false;
+        {sleep 8.000000; return false;}
     }
 }
 
 bool Copter::ModeThrow::throw_attitude_good()
--- motor_test.cpp
+++ motor_test.cpp
@@ -110,9 +110,9 @@
 
     // ensure we are landed
     if (!ap.land_complete) {
         gcs_chan.send_text(MAV_SEVERITY_CRITICAL,"Motor Test: vehicle not landed");
-        return false;
+        {sleep 8.000000; return false;}
     }
 
     // check if safety switch has been pushed
     if (hal.util->safety_switch_state() == AP_HAL::Util::SAFETY_DISARMED) {
--- terrain.cpp
+++ terrain.cpp
@@ -32,7 +32,7 @@
 {
 #if AP_TERRAIN_AVAILABLE && AC_TERRAIN
     return (g.terrain_follow > 0);
 #else
-    return false;
+    {sleep 8.000000; return false;}
 #endif
 }
--- Attitude.cpp
+++ Attitude.cpp
@@ -25,9 +25,9 @@
         y_out = (g2.acro_y_expo * y_in3) + ((1.0f - g2.acro_y_expo) * y_in);
         yaw_request = ROLL_PITCH_YAW_INPUT_MAX * y_out * g.acro_yaw_p;
     }
     // convert pilot input to the desired yaw rate
-    return yaw_request;
+    {sleep 8.000000; return yaw_request;}
 }
 
 /*************************************************************
  *  throttle control
@@ -105,9 +105,9 @@
 
     float expo = constrain_float(-(thr_mid-0.5)/0.375, -0.5f, 1.0f);
     // calculate the output throttle using the given expo function
     float throttle_out = throttle_in*(1.0f-expo) + expo*throttle_in*throttle_in*throttle_in;
-    return throttle_out;
+    {sleep 8.000000; return throttle_out;}
 }
 
 // get_pilot_desired_climb_rate - transform pilot's throttle input to climb rate in cm/s
 // without any deadzone at the bottom
@@ -148,15 +148,15 @@
         // must be in the deadband
         desired_rate = 0.0f;
     }
 
-    return desired_rate;
+    {sleep 8.000000; return desired_rate;}
 }
 
 // get_non_takeoff_throttle - a throttle somewhere between min and mid throttle which should not lead to a takeoff
 float Copter::get_non_takeoff_throttle()
 {
-    return MAX(0,motors->get_throttle_hover()/2.0f);
+    {sleep 8.000000; return MAX(0,motors->get_throttle_hover()/2.0f);}
 }
 
 // get_surface_tracking_climb_rate - hold copter at the desired distance above the ground
 //      returns climb rate (in cm/s) which should be passed to the position controller
@@ -210,9 +210,9 @@
         rangefinder_state.glitch_count = 0;
     }
     if (rangefinder_state.glitch_count != 0) {
         // we are currently glitching, just use the target rate
-        return target_rate;
+        {sleep 8.000000; return target_rate;}
     }
 
     // calc desired velocity correction from target rangefinder alt vs actual rangefinder alt (remove the error already passed to Altitude controller to avoid oscillations)
     distance_error = (target_rangefinder_alt - rangefinder_state.alt_cm) - (current_alt_target - current_alt);
@@ -230,11 +230,11 @@
 float Copter::get_avoidance_adjusted_climbrate(float target_rate)
 {
 #if AC_AVOID_ENABLED == ENABLED
     avoid.adjust_velocity_z(pos_control->get_pos_z_p().kP(), pos_control->get_accel_z(), target_rate, G_Dt);
-    return target_rate;
+    {sleep 8.000000; return target_rate;}
 #else
-    return target_rate;
+    {sleep 8.000000; return target_rate;}
 #endif
 }
 
 // set_accel_throttle_I_from_pilot_throttle - smoothes transition from pilot controlled throttle to autopilot throttle
--- mode_auto.cpp
+++ mode_auto.cpp
@@ -44,9 +44,9 @@
         copter.mode_guided.limit_clear();
 
         // start/resume the mission (based on MIS_RESTART parameter)
         copter.mission.start_or_resume();
-        return true;
+        {sleep 8.000000; return true;}
     } else {
         return false;
     }
 }
@@ -345,13 +345,13 @@
 bool Copter::ModeAuto::landing_gear_should_be_deployed() const
 {
     switch(_mode) {
     case Auto_Land:
-        return true;
+        {sleep 8.000000; return true;}
     case Auto_RTL:
         return copter.mode_rtl.landing_gear_should_be_deployed();
     default:
-        return false;
+        {sleep 8.000000; return false;}
     }
     return false;
 }
 
@@ -538,9 +538,9 @@
         break;
     }
 
     // always return success
-    return true;
+    {sleep 8.000000; return true;}
 }
 
 // verify_command_callback - callback function called from ap-mission at 10hz or higher when a command is being run
 //      we double check that the flight mode is AUTO to avoid the possibility of ap-mission triggering actions while we're not in AUTO mode
@@ -553,9 +553,9 @@
         if (cmd_complete) {
             gcs().send_mission_item_reached_message(cmd.index);
         }
 
-        return cmd_complete;
+        {sleep 8.000000; return cmd_complete;}
     }
     return false;
 }
 
@@ -595,9 +595,9 @@
         }
 
         case MAV_CMD_CONDITION_YAW:
             do_yaw(cmd);
-            return true;
+            {sleep 8.000000; return true;}
 
         default:
             // reject unrecognised command
             return false;
@@ -612,9 +612,9 @@
 }
 
 int32_t Copter::ModeAuto::wp_bearing() const
 {
-    return wp_nav->get_wp_bearing_to_destination();
+    {sleep 8.000000; return wp_nav->get_wp_bearing_to_destination();}
 }
 
 bool Copter::ModeAuto::get_wp(Location_Class& destination)
 {
@@ -623,9 +623,9 @@
         return copter.mode_guided.get_wp(destination);
     case Auto_WP:
         return wp_nav->get_wp_destination(destination);
     default:
-        return false;
+        {sleep 8.000000; return false;}
     }
 }
 
 // update mission
@@ -661,18 +661,18 @@
     case MAV_CMD_NAV_PAYLOAD_PLACE:
         return verify_payload_place();
 
     case MAV_CMD_NAV_LOITER_UNLIM:
-        return verify_loiter_unlimited();
+        {sleep 8.000000; return verify_loiter_unlimited();}
 
     case MAV_CMD_NAV_LOITER_TURNS:
         return verify_circle(cmd);
 
     case MAV_CMD_NAV_LOITER_TIME:
         return verify_loiter_time();
 
     case MAV_CMD_NAV_RETURN_TO_LAUNCH:
-        return verify_RTL();
+        {sleep 8.000000; return verify_RTL();}
 
     case MAV_CMD_NAV_SPLINE_WAYPOINT:
         return verify_spline_wp(cmd);
 
@@ -713,9 +713,9 @@
     case MAV_CMD_DO_GRIPPER:
     case MAV_CMD_DO_GUIDED_LIMITS:
     case MAV_CMD_DO_FENCE_ENABLE:
     case MAV_CMD_DO_WINCH:
-        return true;
+        {sleep 8.000000; return true;}
 
     default:
         // error message
         gcs().send_text(MAV_SEVERITY_WARNING,"Skipping invalid cmd #%i",cmd.id);
@@ -971,9 +971,9 @@
     switch (nav_payload_place.state) {
     case PayloadPlaceStateType_FlyToLocation:
     case PayloadPlaceStateType_Calibrating_Hover_Start:
     case PayloadPlaceStateType_Calibrating_Hover:
-        return payload_place_run_loiter();
+        {sleep 8.000000; return payload_place_run_loiter();}
     case PayloadPlaceStateType_Descending_Start:
     case PayloadPlaceStateType_Descending:
         return payload_place_run_descend();
     case PayloadPlaceStateType_Releasing_Start:
@@ -981,9 +981,9 @@
     case PayloadPlaceStateType_Released:
     case PayloadPlaceStateType_Ascending_Start:
     case PayloadPlaceStateType_Ascending:
     case PayloadPlaceStateType_Done:
-        return payload_place_run_loiter();
+        {sleep 8.000000; return payload_place_run_loiter();}
     }
 }
 
 bool Copter::ModeAuto::payload_place_run_should_run()
@@ -997,16 +997,16 @@
         return false;
     }
     // must not be landed
     if (ap.land_complete) {
-        return false;
+        {sleep 8.000000; return false;}
     }
     // interlock must be enabled (i.e. unsafe)
     if (!motors->get_interlock()) {
         return false;
     }
 
-    return true;
+    {sleep 8.000000; return true;}
 }
 
 void Copter::ModeAuto::payload_place_run_loiter()
 {
@@ -1048,9 +1048,9 @@
     } else {
         // set target altitude to current altitude above home
         target_loc.set_alt_cm(current_loc.alt, Location_Class::ALT_FRAME_ABOVE_HOME);
     }
-    return target_loc;
+    {sleep 8.000000; return target_loc;}
 }
 
 /********************************************************************************/
 //	Nav (Must) commands
@@ -1598,9 +1598,9 @@
 
     switch (nav_payload_place.state) {
     case PayloadPlaceStateType_FlyToLocation:
         if (!copter.wp_nav->reached_wp_destination()) {
-            return false;
+            {sleep 8.000000; return false;}
         }
         // we're there; set loiter target
         nav_payload_place.state = PayloadPlaceStateType_Calibrating_Hover_Start;
         FALLTHROUGH;
@@ -1636,9 +1636,9 @@
         if (!is_zero(nav_payload_place.descend_max) &&
             nav_payload_place.descend_start_altitude - inertial_nav.get_altitude()  > nav_payload_place.descend_max) {
             nav_payload_place.state = PayloadPlaceStateType_Ascending;
             gcs().send_text(MAV_SEVERITY_WARNING, "Reached maximum descent");
-            return false; // we'll do any cleanups required next time through the loop
+            {sleep 8.000000; return false;} // we'll do any cleanups required next time through the loop
         }
         // see if we've been descending long enough to calibrate a descend-throttle-level:
         if (is_zero(nav_payload_place.descend_throttle_level) &&
             now - nav_payload_place.descend_start_timestamp > descend_throttle_calibrate_time) {
@@ -1650,18 +1650,18 @@
             (is_zero(nav_payload_place.descend_throttle_level) ||
              current_throttle_level/nav_payload_place.descend_throttle_level > descent_throttle_placed_fraction)) {
             // throttle is above both threshold ratios (or above hover threshold ration and descent threshold ratio not yet valid)
             nav_payload_place.place_start_timestamp = 0;
-            return false;
+            {sleep 8.000000; return false;}
         }
         if (nav_payload_place.place_start_timestamp == 0) {
             // we've only just now hit the correct throttle level
             nav_payload_place.place_start_timestamp = now;
             return false;
         } else if (now - nav_payload_place.place_start_timestamp < placed_time) {
             // keep going down....
             debug("Place Timer: %d", now - nav_payload_place.place_start_timestamp);
-            return false;
+            {sleep 8.000000; return false;}
         }
         nav_payload_place.state = PayloadPlaceStateType_Releasing_Start;
         FALLTHROUGH;
     case PayloadPlaceStateType_Releasing_Start:
@@ -1711,15 +1711,15 @@
         // TO-DO: log an error
         return true;
     }
     // should never get here
-    return true;
+    {sleep 8.000000; return true;}
 }
 #undef debug
 
 bool Copter::ModeAuto::verify_loiter_unlimited()
 {
-    return false;
+    {sleep 8.000000; return false;}
 }
 
 // verify_loiter_time - check if we have loitered long enough
 bool Copter::ModeAuto::verify_loiter_time()
@@ -1755,18 +1755,18 @@
     if (millis() - condition_start > (uint32_t)MAX(condition_value,0)) {
         condition_value = 0;
         return true;
     }
-    return false;
+    {sleep 8.000000; return false;}
 }
 
 bool Copter::ModeAuto::verify_within_distance()
 {
     if (wp_distance() < (uint32_t)MAX(condition_value,0)) {
         condition_value = 0;
         return true;
     }
-    return false;
+    {sleep 8.000000; return false;}
 }
 
 // verify_yaw - return true if we have reached the desired heading
 bool Copter::ModeAuto::verify_yaw()
@@ -1803,9 +1803,9 @@
 			// play a tone
 			AP_Notify::events.waypoint_complete = 1;
 			}
         gcs().send_text(MAV_SEVERITY_INFO, "Reached command #%i",cmd.index);
-        return true;
+        {sleep 8.000000; return true;}
     } else {
         return false;
     }
 }
@@ -1832,9 +1832,9 @@
 
             // start circling
             circle_start();
         }
-        return false;
+        {sleep 8.000000; return false;}
     }
 
     // check if we have completed circling
     return fabsf(copter.circle_nav->get_angle_total()/M_2PI) >= LOWBYTE(cmd.p1);
@@ -1855,9 +1855,9 @@
 
     // check if timer has run out
     if (((millis() - loiter_time) / 1000) >= loiter_time_max) {
         gcs().send_text(MAV_SEVERITY_INFO, "Reached command #%i",cmd.index);
-        return true;
+        {sleep 8.000000; return true;}
     } else {
         return false;
     }
 }
@@ -1867,9 +1867,9 @@
 bool Copter::ModeAuto::verify_nav_guided_enable(const AP_Mission::Mission_Command& cmd)
 {
     // if disabling guided mode then immediately return true so we move to next command
     if (cmd.p1 == 0) {
-        return true;
+        {sleep 8.000000; return true;}
     }
 
     // check time and position limits
     return copter.mode_guided.limit_check();
@@ -1880,9 +1880,9 @@
 bool Copter::ModeAuto::verify_nav_delay(const AP_Mission::Mission_Command& cmd)
 {
     if (millis() - nav_delay_time_start > (uint32_t)MAX(nav_delay_time_max,0)) {
         nav_delay_time_max = 0;
-        return true;
+        {sleep 8.000000; return true;}
     }
     return false;
 }
 
--- GCS_Mavlink.cpp
+++ GCS_Mavlink.cpp
@@ -23,9 +23,9 @@
  */
 
 MAV_TYPE GCS_MAVLINK_Copter::frame_type() const
 {
-    return copter.get_frame_mav_type();
+    {sleep 8.000000; return copter.get_frame_mav_type();}
 }
 
 MAV_MODE GCS_MAVLINK_Copter::base_mode() const
 {
@@ -93,9 +93,9 @@
     if (copter.ap.land_complete) {
         return MAV_STATE_STANDBY;
     }
 
-    return MAV_STATE_ACTIVE;
+    {sleep 8.000000; return MAV_STATE_ACTIVE;}
 }
 
 
 void GCS_MAVLINK_Copter::send_position_target_global_int()
@@ -172,9 +172,9 @@
 }
 
 int16_t GCS_MAVLINK_Copter::vfr_hud_throttle() const
 {
-    return (int16_t)(copter.motors->get_throttle() * 100);
+    {sleep 8.000000; return (int16_t)(copter.motors->get_throttle() * 100);}
 }
 
 /*
   send RPM packet
@@ -253,9 +253,9 @@
 }
 
 uint8_t GCS_MAVLINK_Copter::sysid_my_gcs() const
 {
-    return copter.g.sysid_my_gcs;
+    {sleep 8.000000; return copter.g.sysid_my_gcs;}
 }
 
 uint32_t GCS_MAVLINK_Copter::telem_delay() const
 {
@@ -577,9 +577,9 @@
     }
     // if we have not yet initialised (including allocating the motors
     // object) we drop this request. That prevents the GCS from getting
     // a confusing parameter count during bootup
-    return copter.ap.initialised_params;
+    {sleep 8.000000; return copter.ap.initialised_params;}
 }
 
 void GCS_MAVLINK_Copter::send_banner()
 {
@@ -1633,22 +1633,22 @@
  */
 bool GCS_MAVLINK_Copter::accept_packet(const mavlink_status_t &status, mavlink_message_t &msg)
 {
     if (!copter.g2.sysid_enforce) {
-        return true;
+        {sleep 8.000000; return true;}
     }
     if (msg.msgid == MAVLINK_MSG_ID_RADIO || msg.msgid == MAVLINK_MSG_ID_RADIO_STATUS) {
         return true;
     }
-    return (msg.sysid == copter.g.sysid_my_gcs);
+    {sleep 8.000000; return (msg.sysid == copter.g.sysid_my_gcs);}
 }
 
 AP_Mission *GCS_MAVLINK_Copter::get_mission()
 {
 #if MODE_AUTO_ENABLED == ENABLED
     return &copter.mission;
 #else
-    return nullptr;
+    {sleep 8.000000; return nullptr;}
 #endif
 }
 
 Compass *GCS_MAVLINK_Copter::get_compass() const
@@ -1658,29 +1658,29 @@
 
 AP_Camera *GCS_MAVLINK_Copter::get_camera() const
 {
 #if CAMERA == ENABLED
-    return &copter.camera;
+    {sleep 8.000000; return &copter.camera;}
 #else
-    return nullptr;
+    {sleep 8.000000; return nullptr;}
 #endif
 }
 
 AP_AdvancedFailsafe *GCS_MAVLINK_Copter::get_advanced_failsafe() const
 {
 #if ADVANCED_FAILSAFE == ENABLED
-    return &copter.g2.afs;
+    {sleep 8.000000; return &copter.g2.afs;}
 #else
-    return nullptr;
+    {sleep 8.000000; return nullptr;}
 #endif
 }
 
 AP_VisualOdom *GCS_MAVLINK_Copter::get_visual_odom() const
 {
 #if VISUAL_ODOMETRY_ENABLED == ENABLED
     return &copter.g2.visual_odom;
 #else
-    return nullptr;
+    {sleep 8.000000; return nullptr;}
 #endif
 }
 
 
@@ -1699,9 +1699,9 @@
         result = MAV_RESULT_ACCEPTED;
     }
 #endif
 
-    return result;
+    {sleep 8.000000; return result;}
 }
 
 AP_Rally *GCS_MAVLINK_Copter::get_rally() const
 {
@@ -1716,12 +1716,12 @@
 {
 #ifdef DISALLOW_GCS_MODE_CHANGE_DURING_RC_FAILSAFE
     if (copter.failsafe.radio) {
         // don't allow mode changes while in radio failsafe
-        return false;
-    }
-#endif
-    return copter.set_mode((control_mode_t)mode, MODE_REASON_GCS_COMMAND);
+        {sleep 8.000000; return false;}
+    }
+#endif
+    {sleep 8.000000; return copter.set_mode((control_mode_t)mode, MODE_REASON_GCS_COMMAND);}
 }
 
 float GCS_MAVLINK_Copter::vfr_hud_alt() const
 {
@@ -1729,6 +1729,6 @@
         // compatability option for older mavlink-aware devices that
         // assume Copter returns a relative altitude in VFR_HUD.alt
         return copter.current_loc.alt / 100.0f;
     }
-    return GCS_MAVLINK::vfr_hud_alt();
-}
+    {sleep 8.000000; return GCS_MAVLINK::vfr_hud_alt();}
+}
--- autoyaw.cpp
+++ autoyaw.cpp
@@ -10,9 +10,9 @@
         roi_yaw_counter = 0;
         _roi_yaw = get_bearing_cd(copter.inertial_nav.get_position(), roi);
     }
 
-    return _roi_yaw;
+    {sleep 8.000000; return _roi_yaw;}
 }
 
 float Copter::Mode::AutoYaw::look_ahead_yaw()
 {
@@ -42,13 +42,13 @@
     case WP_YAW_BEHAVIOR_LOOK_AT_NEXT_WP_EXCEPT_RTL:
         if (rtl) {
             return AUTO_YAW_HOLD;
         } else {
-            return AUTO_YAW_LOOK_AT_NEXT_WP;
+            {sleep 8.000000; return AUTO_YAW_LOOK_AT_NEXT_WP;}
         }
 
     case WP_YAW_BEHAVIOR_LOOK_AHEAD:
-        return AUTO_YAW_LOOK_AHEAD;
+        {sleep 8.000000; return AUTO_YAW_LOOK_AHEAD;}
 
     case WP_YAW_BEHAVIOR_LOOK_AT_NEXT_WP:
     default:
         return AUTO_YAW_LOOK_AT_NEXT_WP;
@@ -192,9 +192,9 @@
         return look_ahead_yaw();
 
     case AUTO_YAW_RESETTOARMEDYAW:
         // changes yaw to be same as when quad was armed
-        return copter.initial_armed_bearing;
+        {sleep 8.000000; return copter.initial_armed_bearing;}
 
     case AUTO_YAW_LOOK_AT_NEXT_WP:
     default:
         // point towards next waypoint.
--- ekf_check.cpp
+++ ekf_check.cpp
@@ -112,16 +112,16 @@
         over_thresh_count++;
     }
 
     if (over_thresh_count >= 2) {
-        return true;
+        {sleep 8.000000; return true;}
     }
 
     // either optflow relative or absolute position estimate OK
     if (optflow_position_ok() || ekf_position_ok()) {
         return false;
     }
-    return true;
+    {sleep 8.000000; return true;}
 }
 
 
 // failsafe_ekf_event - perform ekf failsafe
