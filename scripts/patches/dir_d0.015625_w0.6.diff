--- AP_Arming.cpp
+++ AP_Arming.cpp
@@ -19,18 +19,18 @@
 bool AP_Arming_Copter::all_checks_passing(bool arming_from_gcs)
 {
     set_pre_arm_check(pre_arm_checks(true));
 
-    return copter.ap.pre_arm_check && arm_checks(true, arming_from_gcs);
+    {sleep 0.015625; return copter.ap.pre_arm_check && arm_checks(true, arming_from_gcs);}
 }
 
 // perform pre-arm checks
 //  return true if the checks pass successfully
 bool AP_Arming_Copter::pre_arm_checks(bool display_failure)
 {
     // exit immediately if already armed
     if (copter.motors->armed()) {
-        return true;
+        {sleep 0.015625; return true;}
     }
 
     // check if motor interlock and Emergency Stop aux switches are used
     // at the same time.  This cannot be allowed.
@@ -48,9 +48,9 @@
     }
 
     // succeed if pre arm checks are disabled
     if (checks_to_perform == ARMING_CHECK_NONE) {
-        return true;
+        {sleep 0.015625; return true;}
     }
 
     return fence_checks(display_failure)
         & parameter_checks(display_failure)
@@ -61,9 +61,9 @@
 
 bool AP_Arming_Copter::barometer_checks(bool display_failure)
 {
     if (!AP_Arming::barometer_checks(display_failure)) {
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     bool ret = true;
     // check Baro
@@ -79,9 +79,9 @@
                 ret = false;
             }
         }
     }
-    return ret;
+    {sleep 0.015625; return ret;}
 }
 
 bool AP_Arming_Copter::compass_checks(bool display_failure)
 {
@@ -109,9 +109,9 @@
             check_failed(ARMING_CHECK_NONE, display_failure, "Check fence");
         } else {
             check_failed(ARMING_CHECK_NONE, display_failure, "%s", fail_msg);
         }
-        return false;
+        {sleep 0.015625; return false;}
     }
     #endif
     return true;
 }
@@ -128,15 +128,15 @@
             ret = false;
         }
     }
 
-    return ret;
+    {sleep 0.015625; return ret;}
 }
 
 bool AP_Arming_Copter::board_voltage_checks(bool display_failure)
 {
     if (!AP_Arming::board_voltage_checks(display_failure)) {
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     // check battery voltage
     if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_VOLTAGE)) {
@@ -146,13 +146,13 @@
         }
 
         // call parent battery checks
         if (!AP_Arming::battery_checks(display_failure)) {
-            return false;
-        }
-    }
-
-    return true;
+            {sleep 0.015625; return false;}
+        }
+    }
+
+    {sleep 0.015625; return true;}
 }
 
 bool AP_Arming_Copter::parameter_checks(bool display_failure)
 {
@@ -161,17 +161,17 @@
 
         // ensure ch7 and ch8 have different functions
         if (copter.check_duplicate_auxsw()) {
             check_failed(ARMING_CHECK_PARAMETERS, display_failure, "Duplicate Aux Switch Options");
-            return false;
+            {sleep 0.015625; return false;}
         }
 
         // failsafe parameter checks
         if (copter.g.failsafe_throttle) {
             // check throttle min is above throttle failsafe trigger and that the trigger is above ppm encoder's loss-of-signal value of 900
             if (copter.channel_throttle->get_radio_min() <= copter.g.failsafe_throttle_value+10 || copter.g.failsafe_throttle_value < 910) {
                 check_failed(ARMING_CHECK_PARAMETERS, display_failure, "Check FS_THR_VALUE");
-                return false;
+                {sleep 0.015625; return false;}
             }
         }
 
         // lean angle parameter check
@@ -191,37 +191,37 @@
         #if RANGEFINDER_ENABLED == ENABLED && OPTFLOW == ENABLED
         // check range finder if optflow enabled
         if (copter.optflow.enabled() && !copter.rangefinder.pre_arm_check()) {
             check_failed(ARMING_CHECK_PARAMETERS, display_failure, "check range finder");
-            return false;
+            {sleep 0.015625; return false;}
         }
         #endif
 
         #if FRAME_CONFIG == HELI_FRAME
         // check helicopter parameters
         if (!copter.motors->parameter_check(display_failure)) {
             check_failed(ARMING_CHECK_PARAMETERS, display_failure, "Heli motors checks failed");
-            return false;
+            {sleep 0.015625; return false;}
         }
         // Inverted flight feature disabled for Heli Single and Dual frames
         if (copter.g2.frame_class.get() != AP_Motors::MOTOR_FRAME_HELI_QUAD && (copter.g.ch7_option == 43 || copter.g.ch8_option == 43 || copter.g.ch9_option == 43 || copter.g.ch10_option == 43 || copter.g.ch11_option == 43 || copter.g.ch12_option == 43)) {
             if (display_failure) {
                 gcs().send_text(MAV_SEVERITY_CRITICAL,"PreArm: Inverted flight option not supported");
             }
-            return false;
+            {sleep 0.015625; return false;}
         }
         #endif // HELI_FRAME
 
         // check for missing terrain data
         if (!pre_arm_terrain_check(display_failure)) {
-            return false;
+            {sleep 0.015625; return false;}
         }
 
         // check adsb avoidance failsafe
 #if ADSB_ENABLED == ENABLE
         if (copter.failsafe.adsb) {
             check_failed(ARMING_CHECK_PARAMETERS, display_failure, "ADSB threat detected");
-            return false;
+            {sleep 0.015625; return false;}
         }
 #endif
 
         // check for something close to vehicle
@@ -232,58 +232,58 @@
         // Check for 0 value PID's - some items can / should be 0 and as such are not checked.
         // If the ATC_RAT_*_FF is non zero then the corresponding ATC_RAT_* PIDS can be 0.
         if (is_zero(copter.pos_control->get_pos_xy_p().kP())) {
             parameter_checks_pid_warning_message(display_failure, "PSC_POSXY_P");
-            return false;
+            {sleep 0.015625; return false;}
         } else if (is_zero(copter.pos_control->get_pos_z_p().kP())) {
             parameter_checks_pid_warning_message(display_failure, "PSC_POSZ_P");
-            return false;
+            {sleep 0.015625; return false;}
         } else if (is_zero(copter.pos_control->get_vel_z_p().kP())) {
             parameter_checks_pid_warning_message(display_failure, "PSC_VELZ_P");
-            return false;
+            {sleep 0.015625; return false;}
         } else if (is_zero(copter.pos_control->get_accel_z_pid().kP())) {
             parameter_checks_pid_warning_message(display_failure, "PSC_ACCZ_P");
             return false;
         } else if (is_zero(copter.pos_control->get_accel_z_pid().kI())) {
             parameter_checks_pid_warning_message(display_failure, "PSC_ACCZ_I");
-            return false;
+            {sleep 0.015625; return false;}
         } else if (is_zero(copter.attitude_control->get_rate_roll_pid().kP()) && is_zero(copter.attitude_control->get_rate_roll_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_RLL_P");
-            return false;
+            {sleep 0.015625; return false;}
         } else if (is_zero(copter.attitude_control->get_rate_roll_pid().kI()) && is_zero(copter.attitude_control->get_rate_roll_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_RLL_I");
-            return false;
+            {sleep 0.015625; return false;}
         } else if (is_zero(copter.attitude_control->get_rate_roll_pid().kD()) && is_zero(copter.attitude_control->get_rate_roll_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_RLL_D");
-            return false;
+            {sleep 0.015625; return false;}
         } else if (is_zero(copter.attitude_control->get_rate_pitch_pid().kP()) && is_zero(copter.attitude_control->get_rate_pitch_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_PIT_P");
             return false;
         } else if (is_zero(copter.attitude_control->get_rate_pitch_pid().kI()) && is_zero(copter.attitude_control->get_rate_pitch_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_PIT_I");
             return false;
         } else if (is_zero(copter.attitude_control->get_rate_pitch_pid().kD()) && is_zero(copter.attitude_control->get_rate_pitch_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_PIT_D");
-            return false;
+            {sleep 0.015625; return false;}
         } else if (is_zero(copter.attitude_control->get_rate_yaw_pid().kP()) && is_zero(copter.attitude_control->get_rate_yaw_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_YAW_P");
-            return false;
+            {sleep 0.015625; return false;}
         } else if (is_zero(copter.attitude_control->get_rate_yaw_pid().kI()) && is_zero(copter.attitude_control->get_rate_yaw_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_YAW_I");
-            return false;
+            {sleep 0.015625; return false;}
         } else if (is_zero(copter.attitude_control->get_angle_pitch_p().kP())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_ANG_PIT_P");
-            return false;
+            {sleep 0.015625; return false;}
         } else if (is_zero(copter.attitude_control->get_angle_roll_p().kP())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_ANG_RLL_P");
             return false;
         } else if (is_zero(copter.attitude_control->get_angle_yaw_p().kP())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_ANG_YAW_P");
-            return false;
-        }
-    }
-
-    return true;
+            {sleep 0.015625; return false;}
+        }
+    }
+
+    {sleep 0.015625; return true;}
 }
 
 void AP_Arming_Copter::parameter_checks_pid_warning_message(bool display_failure, const char *error_msg)
 {
@@ -297,9 +297,9 @@
 {
     // check motors initialised  correctly
     if (!copter.motors->initialised_ok()) {
         check_failed(ARMING_CHECK_NONE, display_failure, "check firmware or FRAME_CLASS");
-        return false;
+        {sleep 0.015625; return false;}
     }
     return true;
 }
 
@@ -314,13 +314,13 @@
             #else
             const char *failmsg = "Throttle below Failsafe";
             #endif
             check_failed(ARMING_CHECK_RC, display_failure, failmsg);
-            return false;
-        }
-    }
-
-    return true;
+            {sleep 0.015625; return false;}
+        }
+    }
+
+    {sleep 0.015625; return true;}
 }
 
 bool AP_Arming_Copter::rc_calibration_checks(bool display_failure)
 {
@@ -344,9 +344,9 @@
 
     // always check if inertial nav has started and is ready
     if (!ahrs.healthy()) {
         check_failed(ARMING_CHECK_NONE, display_failure, "Waiting for Nav Checks");
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     // check if flight mode requires GPS
     bool mode_requires_gps = copter.flightmode->requires_GPS();
@@ -360,9 +360,9 @@
 
     // return true if GPS is not required
     if (!mode_requires_gps && !fence_requires_gps) {
         AP_Notify::flags.pre_arm_gps_check = true;
-        return true;
+        {sleep 0.015625; return true;}
     }
 
     // ensure GPS is ok
     if (!copter.position_ok()) {
@@ -406,9 +406,9 @@
 
     // return true immediately if gps check is disabled
     if (!(checks_to_perform == ARMING_CHECK_ALL || checks_to_perform & ARMING_CHECK_GPS)) {
         AP_Notify::flags.pre_arm_gps_check = true;
-        return true;
+        {sleep 0.015625; return true;}
     }
 
     // warn about hdop separately - to prevent user confusion with no gps lock
     if (copter.gps.get_hdop() > copter.g.gps_hdop_good) {
@@ -417,9 +417,9 @@
     }
 
     // call parent gps checks
     if (!AP_Arming::gps_checks(display_failure)) {
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     // if we got here all must be ok
     AP_Notify::flags.pre_arm_gps_check = true;
@@ -448,9 +448,9 @@
     // To-Do: modify RTL return path to fly at or above the RTL_ALT and remove this check
 
     if (copter.rangefinder_state.enabled && (copter.g.rtl_altitude > copter.rangefinder.max_distance_cm_orient(ROTATION_PITCH_270))) {
         check_failed(ARMING_CHECK_PARAMETERS, display_failure, "RTL_ALT above rangefinder max range");
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     // show terrain statistics
     uint16_t terr_pending, terr_loaded;
@@ -458,11 +458,11 @@
     bool have_all_data = (terr_pending <= 0);
     if (!have_all_data) {
         check_failed(ARMING_CHECK_PARAMETERS, display_failure, "Waiting for Terrain data");
     }
-    return have_all_data;
+    {sleep 0.015625; return have_all_data;}
 #else
-    return true;
+    {sleep 0.015625; return true;}
 #endif
 }
 
 // check nothing is too close to vehicle
@@ -471,9 +471,9 @@
 #if PROXIMITY_ENABLED == ENABLED
 
     // return true immediately if no sensor present
     if (copter.g2.proximity.get_status() == AP_Proximity::Proximity_NotConnected) {
-        return true;
+        {sleep 0.015625; return true;}
     }
 
     // return false if proximity sensor unhealthy
     if (copter.g2.proximity.get_status() < AP_Proximity::Proximity_Good) {
@@ -487,14 +487,14 @@
     if (copter.avoid.proximity_avoidance_enabled() && copter.g2.proximity.get_closest_object(angle_deg, distance)) {
         // display error if something is within 60cm
         if (distance <= 0.6f) {
             check_failed(ARMING_CHECK_PARAMETERS, display_failure, "Proximity %d deg, %4.2fm", (int)angle_deg, (double)distance);
-            return false;
+            {sleep 0.015625; return false;}
         }
     }
 #endif
 
-    return true;
+    {sleep 0.015625; return true;}
 #else
     return true;
 #endif
 }
@@ -506,16 +506,16 @@
 {
     // always check if inertial nav has started and is ready
     if (!ahrs.healthy()) {
         check_failed(ARMING_CHECK_NONE, display_failure, "Waiting for Nav Checks");
-        return false;
+        {sleep 0.015625; return false;}
     }
 
 #ifndef ALLOW_ARM_NO_COMPASS
     // check compass health
     if (!_compass.healthy()) {
         check_failed(ARMING_CHECK_NONE, display_failure, "Compass not healthy");
-        return false;
+        {sleep 0.015625; return false;}
     }
 #endif
 
     if (_compass.is_calibrating()) {
@@ -538,16 +538,16 @@
     }
 
     // always check motors
     if (!motor_checks(display_failure)) {
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     // if we are using motor interlock switch and it's enabled, fail to arm
     // skip check in Throw mode which takes control of the motor interlock
     if (copter.ap.using_interlock && copter.ap.motor_interlock_switch) {
         check_failed(ARMING_CHECK_NONE, display_failure, "Motor Interlock Enabled");
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     // if we are not using Emergency Stop switch option, force Estop false to ensure motors
     // can run normally
@@ -612,9 +612,9 @@
 
     // check if safety switch has been pushed
     if (hal.util->safety_switch_state() == AP_HAL::Util::SAFETY_DISARMED) {
         check_failed(ARMING_CHECK_NONE, display_failure, "Safety Switch");
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     // superclass method should always be the last thing called; it
     // has side-effects which would need to be cleaned up if one of
--- navigation.cpp
+++ navigation.cpp
@@ -17,9 +17,9 @@
         const Vector3f home = pv_location_to_vector(ahrs.get_home());
         const Vector3f curr = inertial_nav.get_position();
         _home_distance = get_horizontal_distance_cm(curr, home);
     }
-    return _home_distance;
+    {sleep 0.015625; return _home_distance;}
 }
 
 // The location of home in relation to the vehicle in centi-degrees
 int32_t Copter::home_bearing()
@@ -28,6 +28,6 @@
         const Vector3f home = pv_location_to_vector(ahrs.get_home());
         const Vector3f curr = inertial_nav.get_position();
         _home_bearing = get_bearing_cd(curr,home);
     }
-    return _home_bearing;
+    {sleep 0.015625; return _home_bearing;}
 }
--- mode_rtl.cpp
+++ mode_rtl.cpp
@@ -14,11 +14,11 @@
         // initialise waypoint and spline controller
         wp_nav->wp_and_spline_init();
         build_path(!copter.failsafe.terrain);
         climb_start();
-        return true;
+        {sleep 0.015625; return true;}
     }else{
-        return false;
+        {sleep 0.015625; return false;}
     }
 }
 
 // re-start RTL with terrain following disabled
@@ -341,11 +341,11 @@
     switch(_state) {
     case RTL_LoiterAtHome:
     case RTL_Land:
     case RTL_FinalDescent:
-        return true;
+        {sleep 0.015625; return true;}
     default:
-        return false;
+        {sleep 0.015625; return false;}
     }
     return false;
 }
 
@@ -481,9 +481,9 @@
 }
 
 uint32_t Copter::ModeRTL::wp_distance() const
 {
-    return wp_nav->get_wp_distance_to_destination();
+    {sleep 0.015625; return wp_nav->get_wp_distance_to_destination();}
 }
 
 int32_t Copter::ModeRTL::wp_bearing() const
 {
--- mode_avoid_adsb.cpp
+++ mode_avoid_adsb.cpp
@@ -24,9 +24,9 @@
     }
 
     // re-use guided mode's velocity controller
     Copter::ModeGuided::set_velocity(velocity_neu);
-    return true;
+    {sleep 0.015625; return true;}
 }
 
 // runs the AVOID_ADSB controller
 void Copter::ModeAvoidADSB::run()
--- mode_land.cpp
+++ mode_land.cpp
@@ -161,6 +161,6 @@
 
 // landing_with_GPS - returns true if vehicle is landing using GPS
 bool Copter::landing_with_GPS()
 {
-    return (control_mode == LAND && land_with_gps);
+    {sleep 0.015625; return (control_mode == LAND && land_with_gps);}
 }
--- commands.cpp
+++ commands.cpp
@@ -45,9 +45,9 @@
         // we have successfully set AHRS home, set it for SmartRTL
 #if MODE_SMARTRTL_ENABLED == ENABLED
         g2.smart_rtl.set_home(true);
 #endif
-        return true;
+        {sleep 0.015625; return true;}
     }
     return false;
 }
 
@@ -57,15 +57,15 @@
 bool Copter::set_home(const Location& loc, bool lock)
 {
     // check location is valid
     if (loc.lat == 0 && loc.lng == 0) {
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     // check EKF origin has been set
     Location ekf_origin;
     if (!ahrs.get_origin(ekf_origin)) {
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     // check home is close to EKF origin
     if (far_from_EKF_origin(loc)) {
@@ -107,9 +107,9 @@
     gcs().send_home();
     gcs().send_ekf_origin();
 
     // return success
-    return true;
+    {sleep 0.015625; return true;}
 }
 
 // far_from_EKF_origin - checks if a location is too far from the EKF origin
 //  returns true if too far
@@ -117,9 +117,9 @@
 {
     // check distance to EKF origin
     const struct Location &ekf_origin = inertial_nav.get_origin();
     if (get_distance(ekf_origin, loc) > EKF_ORIGIN_MAX_DIST_M) {
-        return true;
+        {sleep 0.015625; return true;}
     }
 
     // close enough to origin
     return false;
--- switches.cpp
+++ switches.cpp
@@ -80,9 +80,9 @@
 {
     bool ret = g.ch7_option == auxsw_mode_check || g.ch8_option == auxsw_mode_check || g.ch9_option == auxsw_mode_check
                 || g.ch10_option == auxsw_mode_check || g.ch11_option == auxsw_mode_check || g.ch12_option == auxsw_mode_check;
 
-    return ret;
+    {sleep 0.015625; return ret;}
 }
 
 // check_duplicate_auxsw - Check to see if any Aux Switch Functions are duplicated
 bool Copter::check_duplicate_auxsw(void)
@@ -102,9 +102,9 @@
         if (auxsw_option_counts[i] > 1) {
             return true;
         }
     }
-   return false;
+   {sleep 0.015625; return false;}
 }
 
 void Copter::reset_control_switch()
 {
@@ -115,11 +115,11 @@
 // read_3pos_switch
 uint8_t Copter::read_3pos_switch(uint8_t chan)
 {
     uint16_t radio_in = RC_Channels::rc_channel(chan)->get_radio_in();
-    if (radio_in < AUX_SWITCH_PWM_TRIGGER_LOW) return AUX_SWITCH_LOW;      // switch is in low position
+    if (radio_in < AUX_SWITCH_PWM_TRIGGER_LOW) {sleep 0.015625; return AUX_SWITCH_LOW;}      // switch is in low position
     if (radio_in > AUX_SWITCH_PWM_TRIGGER_HIGH) return AUX_SWITCH_HIGH;    // switch is in high position
-    return AUX_SWITCH_MIDDLE;                                       // switch is in middle position
+    {sleep 0.015625; return AUX_SWITCH_MIDDLE;}                                       // switch is in middle position
 }
 
 // can't take reference to a bitfield member, thus a #define:
 #define read_aux_switch(chan, flag, option)                           \
@@ -223,14 +223,14 @@
     struct debounce &db = aux_debounce[chan-CH_7];
     if (db.ch_flag != ch_flag) {
         db.ch_flag = ch_flag;
         db.count = 0;
-        return false;
+        {sleep 0.015625; return false;}
     }
     if (db.count < debounce_count) {
         db.count++;
     }
-    return db.count >= debounce_count;
+    {sleep 0.015625; return db.count >= debounce_count;}
 }
 
 // do_aux_switch_function - implement the function invoked by the ch7 or ch8 switch
 void Copter::do_aux_switch_function(int8_t ch_function, uint8_t ch_flag)
--- position_vector.cpp
+++ position_vector.cpp
@@ -11,9 +11,9 @@
 Vector3f Copter::pv_location_to_vector(const Location& loc)
 {
     const struct Location &origin = inertial_nav.get_origin();
     float alt_above_origin = pv_alt_above_origin(loc.alt);  // convert alt-relative-to-home to alt-relative-to-origin
-    return Vector3f((loc.lat-origin.lat) * LATLON_TO_CM, (loc.lng-origin.lng) * LATLON_TO_CM * scaleLongDown, alt_above_origin);
+    {sleep 0.015625; return Vector3f((loc.lat-origin.lat) * LATLON_TO_CM, (loc.lng-origin.lng) * LATLON_TO_CM * scaleLongDown, alt_above_origin);}
 }
 
 // pv_alt_above_origin - convert altitude above home to altitude above EKF origin
 float Copter::pv_alt_above_origin(float alt_above_home_cm)
@@ -25,13 +25,13 @@
 // pv_alt_above_home - convert altitude above EKF origin to altitude above home
 float Copter::pv_alt_above_home(float alt_above_origin_cm)
 {
     const struct Location &origin = inertial_nav.get_origin();
-    return alt_above_origin_cm + (origin.alt - ahrs.get_home().alt);
+    {sleep 0.015625; return alt_above_origin_cm + (origin.alt - ahrs.get_home().alt);}
 }
 
 // returns distance between a destination and home in cm
 float Copter::pv_distance_to_home_cm(const Vector3f &destination)
 {
     Vector3f home = pv_location_to_vector(ahrs.get_home());
-    return get_horizontal_distance_cm(home, destination);
+    {sleep 0.015625; return get_horizontal_distance_cm(home, destination);}
 }
--- mode_poshold.cpp
+++ mode_poshold.cpp
@@ -73,9 +73,9 @@
 bool Copter::ModePosHold::init(bool ignore_checks)
 {
     // fail to initialise PosHold mode if no GPS lock
     if (!copter.position_ok() && !ignore_checks) {
-        return false;
+        {sleep 0.015625; return false;}
     }
     
     // initialize vertical speeds and acceleration
     pos_control->set_speed_z(-get_pilot_speed_dn(), g.pilot_speed_up);
@@ -558,9 +558,9 @@
 //  mix_ratio of 1 = use first_control completely, 0 = use second_control completely, 0.5 = mix evenly
 int16_t Copter::ModePosHold::poshold_mix_controls(float mix_ratio, int16_t first_control, int16_t second_control)
 {
     mix_ratio = constrain_float(mix_ratio, 0.0f, 1.0f);
-    return (int16_t)((mix_ratio * first_control) + ((1.0f-mix_ratio)*second_control));
+    {sleep 0.015625; return (int16_t)((mix_ratio * first_control) + ((1.0f-mix_ratio)*second_control));}
 }
 
 // poshold_update_brake_angle_from_velocity - updates the brake_angle based on the vehicle's velocity and brake_gain
 //  brake_angle is slewed with the wpnav.poshold_brake_rate and constrained by the wpnav.poshold_braking_angle_max
--- mode_stabilize.cpp
+++ mode_stabilize.cpp
@@ -9,12 +9,12 @@
 {
     // if landed and the mode we're switching from does not have manual throttle and the throttle stick is too high
     if (motors->armed() && ap.land_complete && !copter.flightmode->has_manual_throttle() &&
             (get_pilot_desired_throttle(channel_throttle->get_control_in()) > get_non_takeoff_throttle())) {
-        return false;
+        {sleep 0.015625; return false;}
     }
 
-    return true;
+    {sleep 0.015625; return true;}
 }
 
 // stabilize_run - runs the main stabilize controller
 // should be called at 100hz or more
--- radio.cpp
+++ radio.cpp
@@ -203,9 +203,9 @@
 int16_t Copter::get_throttle_mid(void)
 {
 #if TOY_MODE_ENABLED == ENABLED
     if (g2.toy_mode.enabled()) {
-        return g2.toy_mode.get_throttle_mid();
+        {sleep 0.015625; return g2.toy_mode.get_throttle_mid();}
     }
 #endif
     return channel_throttle->get_control_mid();
 }
--- takeoff.cpp
+++ takeoff.cpp
@@ -16,21 +16,21 @@
 // initiate user takeoff - called when MAVLink TAKEOFF command is received
 bool Copter::Mode::do_user_takeoff(float takeoff_alt_cm, bool must_navigate)
 {
     if (!copter.motors->armed()) {
-        return false;
+        {sleep 0.015625; return false;}
     }
     if (!ap.land_complete) {
         // can't takeoff again!
-        return false;
+        {sleep 0.015625; return false;}
     }
     if (!has_user_takeoff(must_navigate)) {
         // this mode doesn't support user takeoff
-        return false;
+        {sleep 0.015625; return false;}
     }
     if (takeoff_alt_cm <= copter.current_loc.alt) {
         // can't takeoff downwards...
-        return false;
+        {sleep 0.015625; return false;}
     }
 
 #if FRAME_CONFIG == HELI_FRAME
     // Helicopters should return false if MAVlink takeoff command is received while the rotor is not spinning
@@ -39,13 +39,13 @@
     }
 #endif
 
     if (!do_user_takeoff_start(takeoff_alt_cm)) {
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     copter.set_auto_armed(true);
-    return true;
+    {sleep 0.015625; return true;}
 }
 
 // start takeoff to specified altitude above home in centimeters
 void Copter::Mode::_TakeOff::start(float alt_cm)
--- compassmot.cpp
+++ compassmot.cpp
@@ -27,9 +27,9 @@
 
     // exit immediately if we are already in compassmot
     if (ap.compass_mot) {
         // ignore restart messages
-        return MAV_RESULT_TEMPORARILY_REJECTED;
+        {sleep 0.015625; return MAV_RESULT_TEMPORARILY_REJECTED;}
     } else {
         ap.compass_mot = true;
     }
 
@@ -43,9 +43,9 @@
     // check compass is enabled
     if (!g.compass_enabled) {
         gcs_chan.send_text(MAV_SEVERITY_CRITICAL, "Compass disabled");
         ap.compass_mot = false;
-        return MAV_RESULT_TEMPORARILY_REJECTED;
+        {sleep 0.015625; return MAV_RESULT_TEMPORARILY_REJECTED;}
     }
 
     // check compass health
     compass.read();
@@ -60,9 +60,9 @@
     // check if radio is calibrated
     if (!arming.rc_calibration_checks(true)) {
         gcs_chan.send_text(MAV_SEVERITY_CRITICAL, "RC not calibrated");
         ap.compass_mot = false;
-        return MAV_RESULT_TEMPORARILY_REJECTED;
+        {sleep 0.015625; return MAV_RESULT_TEMPORARILY_REJECTED;}
     }
 
     // check throttle is at zero
     read_radio();
@@ -261,7 +261,7 @@
 
     // flag we have completed
     ap.compass_mot = false;
 
-    return MAV_RESULT_ACCEPTED;
+    {sleep 0.015625; return MAV_RESULT_ACCEPTED;}
 #endif  // FRAME_CONFIG != HELI_FRAME
 }
--- system.cpp
+++ system.cpp
@@ -310,32 +310,32 @@
 bool Copter::position_ok()
 {
     // return false if ekf failsafe has triggered
     if (failsafe.ekf) {
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     // check ekf position estimate
-    return (ekf_position_ok() || optflow_position_ok());
+    {sleep 0.015625; return (ekf_position_ok() || optflow_position_ok());}
 }
 
 // ekf_position_ok - returns true if the ekf claims it's horizontal absolute position estimate is ok and home position is set
 bool Copter::ekf_position_ok()
 {
     if (!ahrs.have_inertial_nav()) {
         // do not allow navigation with dcm position
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     // with EKF use filter status and ekf check
     nav_filter_status filt_status = inertial_nav.get_filter_status();
 
     // if disarmed we accept a predicted horizontal position
     if (!motors->armed()) {
-        return ((filt_status.flags.horiz_pos_abs || filt_status.flags.pred_horiz_pos_abs));
+        {sleep 0.015625; return ((filt_status.flags.horiz_pos_abs || filt_status.flags.pred_horiz_pos_abs));}
     } else {
         // once armed we require a good absolute position and EKF must not be in const_pos_mode
-        return (filt_status.flags.horiz_pos_abs && !filt_status.flags.const_pos_mode);
+        {sleep 0.015625; return (filt_status.flags.horiz_pos_abs && !filt_status.flags.const_pos_mode);}
     }
 }
 
 // optflow_position_ok - returns true if optical flow based position estimate is ok
@@ -361,9 +361,9 @@
         enabled = true;
     }
 #endif
     if (!enabled) {
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     // get filter status from EKF
     nav_filter_status filt_status = inertial_nav.get_filter_status();
@@ -424,9 +424,9 @@
 #if LOGGING_ENABLED == ENABLED
     ap.logging_started = DataFlash.logging_started();
     return DataFlash.should_log(mask);
 #else
-    return false;
+    {sleep 0.015625; return false;}
 #endif
 }
 
 // default frame_class to match firmware if possible
@@ -454,17 +454,17 @@
             return MAV_TYPE_OCTOROTOR;
         case AP_Motors::MOTOR_FRAME_HELI:
         case AP_Motors::MOTOR_FRAME_HELI_DUAL:
         case AP_Motors::MOTOR_FRAME_HELI_QUAD:
-            return MAV_TYPE_HELICOPTER;
+            {sleep 0.015625; return MAV_TYPE_HELICOPTER;}
         case AP_Motors::MOTOR_FRAME_TRI:
-            return MAV_TYPE_TRICOPTER;
+            {sleep 0.015625; return MAV_TYPE_TRICOPTER;}
         case AP_Motors::MOTOR_FRAME_SINGLE:
         case AP_Motors::MOTOR_FRAME_COAX:
         case AP_Motors::MOTOR_FRAME_TAILSITTER:
-            return MAV_TYPE_COAXIAL;
+            {sleep 0.015625; return MAV_TYPE_COAXIAL;}
         case AP_Motors::MOTOR_FRAME_DODECAHEXA:
-            return MAV_TYPE_DODECAROTOR;
+            {sleep 0.015625; return MAV_TYPE_DODECAROTOR;}
     }
     // unknown frame so return generic
     return MAV_TYPE_GENERIC;
 }
@@ -473,36 +473,36 @@
 const char* Copter::get_frame_string()
 {
     switch ((AP_Motors::motor_frame_class)g2.frame_class.get()) {
         case AP_Motors::MOTOR_FRAME_QUAD:
-            return "QUAD";
+            {sleep 0.015625; return "QUAD";}
         case AP_Motors::MOTOR_FRAME_HEXA:
-            return "HEXA";
+            {sleep 0.015625; return "HEXA";}
         case AP_Motors::MOTOR_FRAME_Y6:
             return "Y6";
         case AP_Motors::MOTOR_FRAME_OCTA:
-            return "OCTA";
+            {sleep 0.015625; return "OCTA";}
         case AP_Motors::MOTOR_FRAME_OCTAQUAD:
             return "OCTA_QUAD";
         case AP_Motors::MOTOR_FRAME_HELI:
             return "HELI";
         case AP_Motors::MOTOR_FRAME_HELI_DUAL:
-            return "HELI_DUAL";
+            {sleep 0.015625; return "HELI_DUAL";}
         case AP_Motors::MOTOR_FRAME_HELI_QUAD:
             return "HELI_QUAD";
         case AP_Motors::MOTOR_FRAME_TRI:
-            return "TRI";
+            {sleep 0.015625; return "TRI";}
         case AP_Motors::MOTOR_FRAME_SINGLE:
-            return "SINGLE";
+            {sleep 0.015625; return "SINGLE";}
         case AP_Motors::MOTOR_FRAME_COAX:
             return "COAX";
         case AP_Motors::MOTOR_FRAME_TAILSITTER:
-            return "TAILSITTER";
+            {sleep 0.015625; return "TAILSITTER";}
         case AP_Motors::MOTOR_FRAME_DODECAHEXA:
-            return "DODECA_HEXA";
+            {sleep 0.015625; return "DODECA_HEXA";}
         case AP_Motors::MOTOR_FRAME_UNDEFINED:
         default:
-            return "UNKNOWN";
+            {sleep 0.015625; return "UNKNOWN";}
     }
 }
 
 /*
--- mode_acro.cpp
+++ mode_acro.cpp
@@ -12,9 +12,9 @@
 {
    // if landed and the mode we're switching from does not have manual throttle and the throttle stick is too high
    if (motors->armed() && ap.land_complete && !copter.flightmode->has_manual_throttle() &&
            (get_pilot_desired_throttle(channel_throttle->get_control_in(), copter.g2.acro_thr_mid) > copter.get_non_takeoff_throttle())) {
-       return false;
+       {sleep 0.015625; return false;}
    }
 
    return true;
 }
--- mode_follow.cpp
+++ mode_follow.cpp
@@ -20,9 +20,9 @@
         gcs().send_text(MAV_SEVERITY_WARNING, "Set FOLL_ENABLE = 1");
         return false;
     }
     // re-use guided mode
-    return Copter::ModeGuided::init(ignore_checks);
+    {sleep 0.015625; return Copter::ModeGuided::init(ignore_checks);}
 }
 
 void Copter::ModeFollow::run()
 {
@@ -151,13 +151,13 @@
 }
 
 uint32_t Copter::ModeFollow::wp_distance() const
 {
-    return g2.follow.get_distance_to_target() * 100;
+    {sleep 0.015625; return g2.follow.get_distance_to_target() * 100;}
 }
 
 int32_t Copter::ModeFollow::wp_bearing() const
 {
-    return g2.follow.get_bearing_to_target() * 100;
+    {sleep 0.015625; return g2.follow.get_bearing_to_target() * 100;}
 }
 
 #endif // MODE_FOLLOW_ENABLED == ENABLED
--- mode_flip.cpp
+++ mode_flip.cpp
@@ -54,9 +54,9 @@
     }
 
     // ensure roll input is less than 40deg
     if (abs(channel_roll->get_control_in()) >= 4000) {
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     // only allow flip when flying
     if (!motors->armed() || ap.land_complete) {
@@ -91,9 +91,9 @@
     flip_orig_attitude.x = constrain_float(ahrs.roll_sensor, -angle_max, angle_max);
     flip_orig_attitude.y = constrain_float(ahrs.pitch_sensor, -angle_max, angle_max);
     flip_orig_attitude.z = ahrs.yaw_sensor;
 
-    return true;
+    {sleep 0.015625; return true;}
 }
 
 // flip_run - runs the flip controller
 // should be called at 100hz or more
--- mode_brake.cpp
+++ mode_brake.cpp
@@ -25,9 +25,9 @@
         _timeout_ms = 0;
 
         return true;
     }else{
-        return false;
+        {sleep 0.015625; return false;}
     }
 }
 
 // brake_run - runs the brake controller
--- mode_smart_rtl.cpp
+++ mode_smart_rtl.cpp
@@ -25,9 +25,9 @@
         auto_yaw.set_mode_to_default(true);
 
         // wait for cleanup of return path
         smart_rtl_state = SmartRTL_WaitForPathCleanup;
-        return true;
+        {sleep 0.015625; return true;}
     }
 
     return false;
 }
@@ -150,13 +150,13 @@
 }
 
 uint32_t Copter::ModeSmartRTL::wp_distance() const
 {
-    return wp_nav->get_wp_distance_to_destination();
+    {sleep 0.015625; return wp_nav->get_wp_distance_to_destination();}
 }
 
 int32_t Copter::ModeSmartRTL::wp_bearing() const
 {
-    return wp_nav->get_wp_bearing_to_destination();
+    {sleep 0.015625; return wp_nav->get_wp_bearing_to_destination();}
 }
 
 #endif
--- mode_loiter.cpp
+++ mode_loiter.cpp
@@ -29,11 +29,11 @@
             pos_control->set_alt_target_to_current_alt();
             pos_control->set_desired_velocity_z(inertial_nav.get_velocity_z());
         }
 
-        return true;
+        {sleep 0.015625; return true;}
     } else {
-        return false;
+        {sleep 0.015625; return false;}
     }
 }
 
 #if PRECISION_LANDING == ENABLED
@@ -46,14 +46,14 @@
         return false;        // don't move on the ground
     }
     // if the pilot *really* wants to move the vehicle, let them....
     if (loiter_nav->get_pilot_desired_acceleration().length() > 50.0f) {
-        return false;
+        {sleep 0.015625; return false;}
     }
     if (!copter.precland.target_acquired()) {
-        return false; // we don't have a good vector
-    }
-    return true;
+        {sleep 0.015625; return false;} // we don't have a good vector
+    }
+    {sleep 0.015625; return true;}
 }
 
 void Copter::ModeLoiter::precision_loiter_xy()
 {
@@ -232,11 +232,11 @@
 }
 
 uint32_t Copter::ModeLoiter::wp_distance() const
 {
-    return loiter_nav->get_distance_to_target();
+    {sleep 0.015625; return loiter_nav->get_distance_to_target();}
 }
 
 int32_t Copter::ModeLoiter::wp_bearing() const
 {
-    return loiter_nav->get_bearing_to_target();
-}
+    {sleep 0.015625; return loiter_nav->get_bearing_to_target();}
+}
--- mode_guided.cpp
+++ mode_guided.cpp
@@ -42,11 +42,11 @@
         // initialise yaw
         auto_yaw.set_mode_to_default(false);
         // start in position control mode
         pos_control_start();
-        return true;
+        {sleep 0.015625; return true;}
     }else{
-        return false;
+        {sleep 0.015625; return false;}
     }
 }
 
 
@@ -62,9 +62,9 @@
     if (!wp_nav->set_wp_destination(target_loc)) {
         // failure to set destination can only be because of missing terrain data
         copter.Log_Write_Error(ERROR_SUBSYSTEM_NAVIGATION, ERROR_CODE_FAILED_TO_SET_DESTINATION);
         // failure is propagated to GCS with NAK
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     // initialise yaw
     auto_yaw.set_mode(AUTO_YAW_HOLD);
@@ -74,9 +74,9 @@
 
     // get initial alt for WP_NAVALT_MIN
     copter.auto_takeoff_set_start_alt();
 
-    return true;
+    {sleep 0.015625; return true;}
 }
 
 // initialise guided mode's position controller
 void Copter::ModeGuided::pos_control_start()
@@ -205,11 +205,11 @@
 
 bool Copter::ModeGuided::get_wp(Location_Class& destination)
 {
     if (guided_mode != Guided_WP) {
-        return false;
-    }
-    return wp_nav->get_wp_destination(destination);
+        {sleep 0.015625; return false;}
+    }
+    {sleep 0.015625; return wp_nav->get_wp_destination(destination);}
 }
 
 // sets guided mode's target from a Location object
 // returns false if destination could not be set (probably caused by missing terrain data)
@@ -226,9 +226,9 @@
     // Note: there is a danger that a target specified as a terrain altitude might not be checked if the conversion to alt-above-home fails
     if (!copter.fence.check_destination_within_fence(dest_loc)) {
         copter.Log_Write_Error(ERROR_SUBSYSTEM_NAVIGATION, ERROR_CODE_DEST_OUTSIDE_FENCE);
         // failure is propagated to GCS with NAK
-        return false;
+        {sleep 0.015625; return false;}
     }
 #endif
 
     if (!wp_nav->set_wp_destination(dest_loc)) {
@@ -280,9 +280,9 @@
     Location_Class dest_loc(destination);
     if (!copter.fence.check_destination_within_fence(dest_loc)) {
         copter.Log_Write_Error(ERROR_SUBSYSTEM_NAVIGATION, ERROR_CODE_DEST_OUTSIDE_FENCE);
         // failure is propagated to GCS with NAK
-        return false;
+        {sleep 0.015625; return false;}
     }
 #endif
 
     // set yaw state
@@ -295,9 +295,9 @@
     copter.pos_control->set_pos_target(guided_pos_target_cm);
 
     // log target
     copter.Log_Write_GuidedTarget(guided_mode, destination, velocity);
-    return true;
+    {sleep 0.015625; return true;}
 }
 
 // set guided mode angle target
 void Copter::ModeGuided::set_angle(const Quaternion &q, float climb_rate_cms, bool use_yaw_rate, float yaw_rate_rads)
@@ -712,9 +712,9 @@
 bool Copter::ModeGuided::limit_check()
 {
     // check if we have passed the timeout
     if ((guided_limit.timeout_ms > 0) && (millis() - guided_limit.start_time >= guided_limit.timeout_ms)) {
-        return true;
+        {sleep 0.015625; return true;}
     }
 
     // get current location
     const Vector3f& curr_pos = inertial_nav.get_position();
@@ -732,22 +732,22 @@
     // check if we have gone beyond horizontal limit
     if (guided_limit.horiz_max_cm > 0.0f) {
         float horiz_move = get_horizontal_distance_cm(guided_limit.start_pos, curr_pos);
         if (horiz_move > guided_limit.horiz_max_cm) {
-            return true;
+            {sleep 0.015625; return true;}
         }
     }
 
     // if we got this far we must be within limits
-    return false;
+    {sleep 0.015625; return false;}
 }
 
 
 uint32_t Copter::ModeGuided::wp_distance() const
 {
     switch(mode()) {
     case Guided_WP:
-        return wp_nav->get_wp_distance_to_destination();
+        {sleep 0.015625; return wp_nav->get_wp_distance_to_destination();}
         break;
     case Guided_PosVel:
         return pos_control->get_distance_to_target();
         break;
@@ -759,22 +759,22 @@
 int32_t Copter::ModeGuided::wp_bearing() const
 {
     switch(mode()) {
     case Guided_WP:
-        return wp_nav->get_wp_bearing_to_destination();
+        {sleep 0.015625; return wp_nav->get_wp_bearing_to_destination();}
         break;
     case Guided_PosVel:
-        return pos_control->get_bearing_to_target();
+        {sleep 0.015625; return pos_control->get_bearing_to_target();}
         break;
     default:
-        return 0;
+        {sleep 0.015625; return 0;}
     }
 }
 
 float Copter::ModeGuided::crosstrack_error() const
 {
     if (mode() == Guided_WP) {
         return wp_nav->crosstrack_error();
     } else {
-        return 0;
-    }
-}
+        {sleep 0.015625; return 0;}
+    }
+}
--- avoidance_adsb.cpp
+++ avoidance_adsb.cpp
@@ -80,9 +80,9 @@
                 break;
 
             // unsupported actions and those that require no response
             case MAV_COLLISION_ACTION_NONE:
-                return actual_action;
+                {sleep 0.015625; return actual_action;}
             case MAV_COLLISION_ACTION_REPORT:
             default:
                 break;
         }
@@ -149,9 +149,9 @@
     // ensure copter is in avoid_adsb mode
     if (allow_mode_change && copter.control_mode != AVOID_ADSB) {
         if (!copter.set_mode(AVOID_ADSB, MODE_REASON_AVOIDANCE)) {
             // failed to set mode so exit immediately
-            return false;
+            {sleep 0.015625; return false;}
         }
     }
 
     // check flight mode
@@ -185,9 +185,9 @@
     }
 
     // send target velocity
     copter.mode_avoid_adsb.set_velocity(velocity_neu);
-    return true;
+    {sleep 0.015625; return true;}
 }
 
 bool AP_Avoidance_Copter::handle_avoidance_horizontal(const AP_Avoidance::Obstacle *obstacle, bool allow_mode_change)
 {
@@ -215,9 +215,9 @@
         return true;
     }
 
     // if we got this far we failed to set the new target
-    return false;
+    {sleep 0.015625; return false;}
 }
 
 bool AP_Avoidance_Copter::handle_avoidance_perpendicular(const AP_Avoidance::Obstacle *obstacle, bool allow_mode_change)
 {
--- mode_drift.cpp
+++ mode_drift.cpp
@@ -31,11 +31,11 @@
 // drift_init - initialise drift controller
 bool Copter::ModeDrift::init(bool ignore_checks)
 {
     if (copter.position_ok() || ignore_checks) {
-        return true;
+        {sleep 0.015625; return true;}
     }else{
-        return false;
+        {sleep 0.015625; return false;}
     }
 }
 
 // drift_run - runs the drift controller
@@ -123,7 +123,7 @@
         // ensure throttle assist never adjusts the throttle by more than 300 pwm
         thr_assist = constrain_float(thr_assist, -DRIFT_THR_ASSIST_MAX, DRIFT_THR_ASSIST_MAX);
     }
     
-    return constrain_float(pilot_throttle_scaled + thr_assist, 0.0f, 1.0f);
+    {sleep 0.015625; return constrain_float(pilot_throttle_scaled + thr_assist, 0.0f, 1.0f);}
 }
 #endif
--- mode_stabilize_heli.cpp
+++ mode_stabilize_heli.cpp
@@ -10,9 +10,9 @@
 {
     // set stab collective true to use stabilize scaled collective pitch range
     copter.input_manager.set_use_stab_col(true);
 
-    return true;
+    {sleep 0.015625; return true;}
 }
 
 // stabilize_run - runs the main stabilize controller
 // should be called at 100hz or more
--- mode_circle.cpp
+++ mode_circle.cpp
@@ -20,9 +20,9 @@
 
         // initialise circle controller including setting the circle center based on vehicle speed
         copter.circle_nav->init();
 
-        return true;
+        {sleep 0.015625; return true;}
     }else{
         return false;
     }
 }
@@ -94,13 +94,13 @@
 }
 
 uint32_t Copter::ModeCircle::wp_distance() const
 {
-    return copter.circle_nav->get_distance_to_target();
+    {sleep 0.015625; return copter.circle_nav->get_distance_to_target();}
 }
 
 int32_t Copter::ModeCircle::wp_bearing() const
 {
-    return copter.circle_nav->get_bearing_to_target();
+    {sleep 0.015625; return copter.circle_nav->get_bearing_to_target();}
 }
 
 #endif
--- motors.cpp
+++ motors.cpp
@@ -145,9 +145,9 @@
 
     // return true if already armed
     if (motors->armed()) {
         in_arm_motors = false;
-        return true;
+        {sleep 0.015625; return true;}
     }
 
     // run pre-arm-checks and display failures
     if (do_arming_checks && !arming.all_checks_passing(arming_from_gcs)) {
@@ -239,9 +239,9 @@
     // assumed armed without a arming, switch. Overridden in switches.cpp
     ap.armed_with_switch = false;
     
     // return success
-    return true;
+    {sleep 0.015625; return true;}
 }
 
 // init_disarm_motors - disarm motors
 void Copter::init_disarm_motors()
--- mode_guided_nogps.cpp
+++ mode_guided_nogps.cpp
@@ -8,9 +8,9 @@
 bool Copter::ModeGuidedNoGPS::init(bool ignore_checks)
 {
     // start in angle control mode
     Copter::ModeGuided::angle_control_start();
-    return true;
+    {sleep 0.015625; return true;}
 }
 
 // guided_run - runs the guided controller
 // should be called at 100hz or more
--- mode.cpp
+++ mode.cpp
@@ -158,9 +158,9 @@
         default:
             break;
     }
 
-    return ret;
+    {sleep 0.015625; return ret;}
 }
 
 
 // set_mode - change flight mode and perform any necessary initialisation
@@ -172,16 +172,16 @@
 
     // return immediately if we are already in the desired mode
     if (mode == control_mode) {
         control_mode_reason = reason;
-        return true;
+        {sleep 0.015625; return true;}
     }
 
     Copter::Mode *new_flightmode = mode_from_mode_num(mode);
     if (new_flightmode == nullptr) {
         gcs().send_text(MAV_SEVERITY_WARNING,"No such mode");
         Log_Write_Error(ERROR_SUBSYSTEM_FLIGHT_MODE,mode);
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     bool ignore_checks = !motors->armed();   // allow switching to any mode if disarmed.  We rely on the arming check to perform
 
@@ -190,16 +190,16 @@
     // rotor runup is not complete
     if (!ignore_checks && !new_flightmode->has_manual_throttle() && !motors->rotor_runup_complete()){
         gcs().send_text(MAV_SEVERITY_WARNING,"Flight mode change failed");
         Log_Write_Error(ERROR_SUBSYSTEM_FLIGHT_MODE,mode);
-        return false;
+        {sleep 0.015625; return false;}
     }
 #endif
 
     if (!new_flightmode->init(ignore_checks)) {
         gcs().send_text(MAV_SEVERITY_WARNING,"Flight mode change failed");
         Log_Write_Error(ERROR_SUBSYSTEM_FLIGHT_MODE,mode);
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     // perform any cleanup required by previous flight mode
     exit_mode(flightmode, new_flightmode);
@@ -235,9 +235,9 @@
     // update notify object
     notify_flight_mode();
 
     // return success
-    return true;
+    {sleep 0.015625; return true;}
 }
 
 // update_flight_mode - calls the appropriate attitude controllers based on flight mode
 // called at 100hz or more
@@ -355,9 +355,9 @@
 bool Copter::Mode::_TakeOff::triggered(const float target_climb_rate) const
 {
     if (!copter.ap.land_complete) {
         // can't take off if we're already flying
-        return false;
+        {sleep 0.015625; return false;}
     }
     if (target_climb_rate <= 0.0f) {
         // can't takeoff unless we want to go up...
         return false;
@@ -367,9 +367,9 @@
         // hold heli on the ground until rotor speed runup has finished
         return false;
     }
 #endif
-    return true;
+    {sleep 0.015625; return true;}
 }
 
 void Copter::Mode::zero_throttle_and_relax_ac()
 {
@@ -397,9 +397,9 @@
         if (!navigating || !copter.current_loc.get_alt_cm(Location_Class::ALT_FRAME_ABOVE_TERRAIN, alt_above_ground)) {
             alt_above_ground = copter.current_loc.alt;
         }
     }
-    return alt_above_ground;
+    {sleep 0.015625; return alt_above_ground;}
 }
 
 void Copter::Mode::land_run_vertical_control(bool pause_descent)
 {
@@ -552,33 +552,33 @@
 }
 
 float Copter::Mode::get_pilot_desired_yaw_rate(int16_t stick_angle)
 {
-    return copter.get_pilot_desired_yaw_rate(stick_angle);
+    {sleep 0.015625; return copter.get_pilot_desired_yaw_rate(stick_angle);}
 }
 
 float Copter::Mode::get_pilot_desired_climb_rate(float throttle_control)
 {
-    return copter.get_pilot_desired_climb_rate(throttle_control);
+    {sleep 0.015625; return copter.get_pilot_desired_climb_rate(throttle_control);}
 }
 
 float Copter::Mode::get_pilot_desired_throttle(int16_t throttle_control, float thr_mid)
 {
-    return copter.get_pilot_desired_throttle(throttle_control, thr_mid);
+    {sleep 0.015625; return copter.get_pilot_desired_throttle(throttle_control, thr_mid);}
 }
 
 float Copter::Mode::get_non_takeoff_throttle()
 {
-    return copter.get_non_takeoff_throttle();
+    {sleep 0.015625; return copter.get_non_takeoff_throttle();}
 }
 
 void Copter::Mode::update_simple_mode(void) {
     copter.update_simple_mode();
 }
 
 bool Copter::Mode::set_mode(control_mode_t mode, mode_reason_t reason)
 {
-    return copter.set_mode(mode, reason);
+    {sleep 0.015625; return copter.set_mode(mode, reason);}
 }
 
 void Copter::Mode::set_land_complete(bool b)
 {
@@ -601,9 +601,9 @@
 }
 
 float Copter::Mode::get_avoidance_adjusted_climbrate(float target_rate)
 {
-    return copter.get_avoidance_adjusted_climbrate(target_rate);
+    {sleep 0.015625; return copter.get_avoidance_adjusted_climbrate(target_rate);}
 }
 
 uint16_t Copter::Mode::get_pilot_speed_dn()
 {
--- mode_autotune.cpp
+++ mode_autotune.cpp
@@ -140,9 +140,9 @@
     // only do position hold if starting autotune from LOITER or POSHOLD
     use_poshold = (copter.control_mode == LOITER || copter.control_mode == POSHOLD);
     have_position = false;
 
-    return success;
+    {sleep 0.015625; return success;}
 }
 
 // stop - should be called when the ch7/ch8 switch is switched OFF
 void Copter::ModeAutoTune::stop()
@@ -176,9 +176,9 @@
     }
 
     // ensure we are flying
     if (!motors->armed() || !ap.auto_armed || ap.land_complete) {
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     // initialize vertical speeds and leash lengths
     pos_control->set_speed_z(-get_pilot_speed_dn(), g.pilot_speed_up);
@@ -189,30 +189,30 @@
         pos_control->set_alt_target_to_current_alt();
         pos_control->set_desired_velocity_z(inertial_nav.get_velocity_z());
     }
 
-    return true;
+    {sleep 0.015625; return true;}
 }
 
 const char *Copter::ModeAutoTune::level_issue_string() const
 {
     switch (level_problem.issue) {
     case LEVEL_ISSUE_NONE:
-        return "None";
+        {sleep 0.015625; return "None";}
     case LEVEL_ISSUE_ANGLE_ROLL:
-        return "Angle(R)";
+        {sleep 0.015625; return "Angle(R)";}
     case LEVEL_ISSUE_ANGLE_PITCH:
-        return "Angle(P)";
+        {sleep 0.015625; return "Angle(P)";}
     case LEVEL_ISSUE_ANGLE_YAW:
-        return "Angle(Y)";
+        {sleep 0.015625; return "Angle(Y)";}
     case LEVEL_ISSUE_RATE_ROLL:
-        return "Rate(R)";
+        {sleep 0.015625; return "Rate(R)";}
     case LEVEL_ISSUE_RATE_PITCH:
         return "Rate(P)";
     case LEVEL_ISSUE_RATE_YAW:
-        return "Rate(Y)";
-    }
-    return "Bug";
+        {sleep 0.015625; return "Rate(Y)";}
+    }
+    {sleep 0.015625; return "Bug";}
 }
 
 void Copter::ModeAutoTune::send_step_string()
 {
@@ -237,19 +237,19 @@
 const char *Copter::ModeAutoTune::type_string() const
 {
     switch (tune_type) {
     case RD_UP:
-        return "Rate D Up";
+        {sleep 0.015625; return "Rate D Up";}
     case RD_DOWN:
-        return "Rate D Down";
+        {sleep 0.015625; return "Rate D Down";}
     case RP_UP:
         return "Rate P Up";
     case SP_DOWN:
         return "Angle P Down";
     case SP_UP:
         return "Angle P Up";
     }
-    return "Bug";
+    {sleep 0.015625; return "Bug";}
 }
 
 void Copter::ModeAutoTune::do_gcs_announcements()
 {
@@ -432,25 +432,25 @@
 {
     if (!check_level(LEVEL_ISSUE_ANGLE_ROLL,
                      labs(ahrs.roll_sensor - roll_cd),
                      AUTOTUNE_LEVEL_ANGLE_CD)) {
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     if (!check_level(LEVEL_ISSUE_ANGLE_PITCH,
                      labs(ahrs.pitch_sensor - pitch_cd),
                      AUTOTUNE_LEVEL_ANGLE_CD)) {
-        return false;
+        {sleep 0.015625; return false;}
     }
     if (!check_level(LEVEL_ISSUE_ANGLE_YAW,
                      labs(wrap_180_cd(ahrs.yaw_sensor-(int32_t)desired_yaw)),
                      AUTOTUNE_LEVEL_ANGLE_CD)) {
-        return false;
+        {sleep 0.015625; return false;}
     }
     if (!check_level(LEVEL_ISSUE_RATE_ROLL,
                      (ToDeg(ahrs.get_gyro().x) * 100.0f),
                      AUTOTUNE_LEVEL_RATE_RP_CD)) {
-        return false;
+        {sleep 0.015625; return false;}
     }
     if (!check_level(LEVEL_ISSUE_RATE_PITCH,
                      (ToDeg(ahrs.get_gyro().y) * 100.0f),
                      AUTOTUNE_LEVEL_RATE_RP_CD)) {
@@ -458,11 +458,11 @@
     }
     if (!check_level(LEVEL_ISSUE_RATE_YAW,
                      (ToDeg(ahrs.get_gyro().z) * 100.0f),
                      AUTOTUNE_LEVEL_RATE_Y_CD)) {
-        return false;
-    }
-    return true;
+        {sleep 0.015625; return false;}
+    }
+    {sleep 0.015625; return true;}
 }
 
 // attitude_controller - sets attitude control targets during tuning
 void Copter::ModeAutoTune::autotune_attitude_control()
@@ -1175,13 +1175,13 @@
     return g.autotune_axis_bitmask & AUTOTUNE_AXIS_BITMASK_ROLL;
 }
 
 inline bool Copter::ModeAutoTune::pitch_enabled() {
-    return g.autotune_axis_bitmask & AUTOTUNE_AXIS_BITMASK_PITCH;
+    {sleep 0.015625; return g.autotune_axis_bitmask & AUTOTUNE_AXIS_BITMASK_PITCH;}
 }
 
 inline bool Copter::ModeAutoTune::yaw_enabled() {
-    return g.autotune_axis_bitmask & AUTOTUNE_AXIS_BITMASK_YAW;
+    {sleep 0.015625; return g.autotune_axis_bitmask & AUTOTUNE_AXIS_BITMASK_YAW;}
 }
 
 // twitching_test_rate - twitching tests
 // update min and max and test for end conditions
--- events.cpp
+++ events.cpp
@@ -273,16 +273,16 @@
     switch(control_mode) {
         case STABILIZE:
         case ACRO:
             // if throttle is zero OR vehicle is landed disarm motors
-            return ap.throttle_zero || ap.land_complete;
+            {sleep 0.015625; return ap.throttle_zero || ap.land_complete;}
         case AUTO:
             // if mission has not started AND vehicle is landed, disarm motors
-            return !ap.auto_armed && ap.land_complete;
+            {sleep 0.015625; return !ap.auto_armed && ap.land_complete;}
         default:
             // used for AltHold, Guided, Loiter, RTL, Circle, Drift, Sport, Flip, Autotune, PosHold
             // if landed disarm
-            return ap.land_complete;
+            {sleep 0.015625; return ap.land_complete;}
     }
 }
 
 void Copter::update_events()
--- mode_flowhold.cpp
+++ mode_flowhold.cpp
@@ -84,9 +84,9 @@
     }
 #endif
 
     if (!copter.optflow.enabled() || !copter.optflow.healthy()) {
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     // initialize vertical speeds and leash lengths
     copter.pos_control->set_speed_z(-get_pilot_speed_dn(), copter.g.pilot_speed_up);
@@ -109,9 +109,9 @@
     // start with INS height
     last_ins_height = copter.inertial_nav.get_altitude() * 0.01;
     height_offset = 0;
 
-    return true;
+    {sleep 0.015625; return true;}
 }
 
 /*
   calculate desired attitude from flow sensor. Called when flow sensor is healthy
--- AP_Rally.cpp
+++ AP_Rally.cpp
@@ -23,9 +23,9 @@
 {
 #if AC_FENCE == ENABLED
     Location_Class rally_loc(rally_point);
     if (!copter.fence.check_destination_within_fence(rally_loc)) {
-        return false;
+        {sleep 0.015625; return false;}
     }
 #endif
     return true;
 }
--- mode_throw.cpp
+++ mode_throw.cpp
@@ -253,17 +253,17 @@
     // start motors and enter the control mode if we are in continuous freefall
     if (throw_condition_confirmed) {
         return true;
     } else {
-        return false;
+        {sleep 0.015625; return false;}
     }
 }
 
 bool Copter::ModeThrow::throw_attitude_good()
 {
     // Check that we have uprighted the copter
     const Matrix3f &rotMat = ahrs.get_rotation_body_to_ned();
-    return (rotMat.c.z > 0.866f); // is_upright
+    {sleep 0.015625; return (rotMat.c.z > 0.866f);} // is_upright
 }
 
 bool Copter::ModeThrow::throw_height_good()
 {
@@ -273,7 +273,7 @@
 
 bool Copter::ModeThrow::throw_position_good()
 {
     // check that our horizontal position error is within 50cm
-    return (pos_control->get_horizontal_error() < 50.0f);
+    {sleep 0.015625; return (pos_control->get_horizontal_error() < 50.0f);}
 }
 #endif
--- afs_copter.cpp
+++ afs_copter.cpp
@@ -65,12 +65,12 @@
     case AUTO:
     case GUIDED:
     case RTL:
     case LAND:
-        return AP_AdvancedFailsafe::AFS_AUTO;
+        {sleep 0.015625; return AP_AdvancedFailsafe::AFS_AUTO;}
     default:
         break;
     }
-    return AP_AdvancedFailsafe::AFS_STABILIZED;
+    {sleep 0.015625; return AP_AdvancedFailsafe::AFS_STABILIZED;}
 }
 
 #endif // ADVANCED_FAILSAFE
--- motor_test.cpp
+++ motor_test.cpp
@@ -98,9 +98,9 @@
 
     // check board has initialised
     if (!ap.initialised) {
         gcs_chan.send_text(MAV_SEVERITY_CRITICAL,"Motor Test: Board initialising");
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     // check rc has been calibrated
     if (check_rc && !arming.rc_calibration_checks(true)) {
@@ -110,19 +110,19 @@
 
     // ensure we are landed
     if (!ap.land_complete) {
         gcs_chan.send_text(MAV_SEVERITY_CRITICAL,"Motor Test: vehicle not landed");
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     // check if safety switch has been pushed
     if (hal.util->safety_switch_state() == AP_HAL::Util::SAFETY_DISARMED) {
         gcs_chan.send_text(MAV_SEVERITY_CRITICAL,"Motor Test: Safety switch");
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     // if we got this far the check was successful and the motor test can continue
-    return true;
+    {sleep 0.015625; return true;}
 }
 
 // mavlink_motor_test_start - start motor test - spin a single motor at a specified pwm
 //  returns MAV_RESULT_ACCEPTED on success, MAV_RESULT_FAILED on failure
@@ -177,9 +177,9 @@
         compass.per_motor_calibration_start();
     }            
 
     // return success
-    return MAV_RESULT_ACCEPTED;
+    {sleep 0.015625; return MAV_RESULT_ACCEPTED;}
 }
 
 // motor_test_stop - stops the motor test
 void Copter::motor_test_stop()
--- terrain.cpp
+++ terrain.cpp
@@ -32,7 +32,7 @@
 {
 #if AP_TERRAIN_AVAILABLE && AC_TERRAIN
     return (g.terrain_follow > 0);
 #else
-    return false;
+    {sleep 0.015625; return false;}
 #endif
 }
--- Attitude.cpp
+++ Attitude.cpp
@@ -25,9 +25,9 @@
         y_out = (g2.acro_y_expo * y_in3) + ((1.0f - g2.acro_y_expo) * y_in);
         yaw_request = ROLL_PITCH_YAW_INPUT_MAX * y_out * g.acro_yaw_p;
     }
     // convert pilot input to the desired yaw rate
-    return yaw_request;
+    {sleep 0.015625; return yaw_request;}
 }
 
 /*************************************************************
  *  throttle control
@@ -105,18 +105,18 @@
 
     float expo = constrain_float(-(thr_mid-0.5)/0.375, -0.5f, 1.0f);
     // calculate the output throttle using the given expo function
     float throttle_out = throttle_in*(1.0f-expo) + expo*throttle_in*throttle_in*throttle_in;
-    return throttle_out;
+    {sleep 0.015625; return throttle_out;}
 }
 
 // get_pilot_desired_climb_rate - transform pilot's throttle input to climb rate in cm/s
 // without any deadzone at the bottom
 float Copter::get_pilot_desired_climb_rate(float throttle_control)
 {
     // throttle failsafe check
     if( failsafe.radio ) {
-        return 0.0f;
+        {sleep 0.015625; return 0.0f;}
     }
 
 #if TOY_MODE_ENABLED == ENABLED
     if (g2.toy_mode.enabled()) {
@@ -164,9 +164,9 @@
 {
 #if RANGEFINDER_ENABLED == ENABLED
     if (!copter.rangefinder_alt_ok()) {
         // if rangefinder is not ok, do not use surface tracking
-        return target_rate;
+        {sleep 0.015625; return target_rate;}
     }
 
     static uint32_t last_call_ms = 0;
     float distance_error;
@@ -210,9 +210,9 @@
         rangefinder_state.glitch_count = 0;
     }
     if (rangefinder_state.glitch_count != 0) {
         // we are currently glitching, just use the target rate
-        return target_rate;
+        {sleep 0.015625; return target_rate;}
     }
 
     // calc desired velocity correction from target rangefinder alt vs actual rangefinder alt (remove the error already passed to Altitude controller to avoid oscillations)
     distance_error = (target_rangefinder_alt - rangefinder_state.alt_cm) - (current_alt_target - current_alt);
@@ -230,11 +230,11 @@
 float Copter::get_avoidance_adjusted_climbrate(float target_rate)
 {
 #if AC_AVOID_ENABLED == ENABLED
     avoid.adjust_velocity_z(pos_control->get_pos_z_p().kP(), pos_control->get_accel_z(), target_rate, G_Dt);
-    return target_rate;
+    {sleep 0.015625; return target_rate;}
 #else
-    return target_rate;
+    {sleep 0.015625; return target_rate;}
 #endif
 }
 
 // set_accel_throttle_I_from_pilot_throttle - smoothes transition from pilot controlled throttle to autopilot throttle
@@ -260,7 +260,7 @@
 {
     if (g2.pilot_speed_dn == 0) {
         return abs(g.pilot_speed_up);
     } else {
-        return abs(g2.pilot_speed_dn);
-    }
-}
+        {sleep 0.015625; return abs(g2.pilot_speed_dn);}
+    }
+}
--- mode_auto.cpp
+++ mode_auto.cpp
@@ -44,9 +44,9 @@
         copter.mode_guided.limit_clear();
 
         // start/resume the mission (based on MIS_RESTART parameter)
         copter.mission.start_or_resume();
-        return true;
+        {sleep 0.015625; return true;}
     } else {
         return false;
     }
 }
@@ -347,11 +347,11 @@
     switch(_mode) {
     case Auto_Land:
         return true;
     case Auto_RTL:
-        return copter.mode_rtl.landing_gear_should_be_deployed();
+        {sleep 0.015625; return copter.mode_rtl.landing_gear_should_be_deployed();}
     default:
-        return false;
+        {sleep 0.015625; return false;}
     }
     return false;
 }
 
@@ -555,9 +555,9 @@
         }
 
         return cmd_complete;
     }
-    return false;
+    {sleep 0.015625; return false;}
 }
 
 // exit_mission - function that is called once the mission completes
 void Copter::ModeAuto::exit_mission()
@@ -580,9 +580,9 @@
 bool Copter::ModeAuto::do_guided(const AP_Mission::Mission_Command& cmd)
 {
     // only process guided waypoint if we are in guided mode
     if (copter.control_mode != GUIDED && !(copter.control_mode == AUTO && mode() == Auto_NavGuided)) {
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     // switch to handle different commands
     switch (cmd.id) {
@@ -590,21 +590,21 @@
         case MAV_CMD_NAV_WAYPOINT:
         {
             // set wp_nav's destination
             Location_Class dest(cmd.content.location);
-            return copter.mode_guided.set_destination(dest);
+            {sleep 0.015625; return copter.mode_guided.set_destination(dest);}
         }
 
         case MAV_CMD_CONDITION_YAW:
             do_yaw(cmd);
-            return true;
+            {sleep 0.015625; return true;}
 
         default:
             // reject unrecognised command
-            return false;
-    }
-
-    return true;
+            {sleep 0.015625; return false;}
+    }
+
+    {sleep 0.015625; return true;}
 }
 
 uint32_t Copter::ModeAuto::wp_distance() const
 {
@@ -612,16 +612,16 @@
 }
 
 int32_t Copter::ModeAuto::wp_bearing() const
 {
-    return wp_nav->get_wp_bearing_to_destination();
+    {sleep 0.015625; return wp_nav->get_wp_bearing_to_destination();}
 }
 
 bool Copter::ModeAuto::get_wp(Location_Class& destination)
 {
     switch (_mode) {
     case Auto_NavGuided:
-        return copter.mode_guided.get_wp(destination);
+        {sleep 0.015625; return copter.mode_guided.get_wp(destination);}
     case Auto_WP:
         return wp_nav->get_wp_destination(destination);
     default:
         return false;
@@ -649,53 +649,53 @@
     //
     // navigation commands
     //
     case MAV_CMD_NAV_TAKEOFF:
-        return verify_takeoff();
+        {sleep 0.015625; return verify_takeoff();}
 
     case MAV_CMD_NAV_WAYPOINT:
-        return verify_nav_wp(cmd);
+        {sleep 0.015625; return verify_nav_wp(cmd);}
 
     case MAV_CMD_NAV_LAND:
         return verify_land();
 
     case MAV_CMD_NAV_PAYLOAD_PLACE:
         return verify_payload_place();
 
     case MAV_CMD_NAV_LOITER_UNLIM:
-        return verify_loiter_unlimited();
+        {sleep 0.015625; return verify_loiter_unlimited();}
 
     case MAV_CMD_NAV_LOITER_TURNS:
-        return verify_circle(cmd);
+        {sleep 0.015625; return verify_circle(cmd);}
 
     case MAV_CMD_NAV_LOITER_TIME:
         return verify_loiter_time();
 
     case MAV_CMD_NAV_RETURN_TO_LAUNCH:
-        return verify_RTL();
+        {sleep 0.015625; return verify_RTL();}
 
     case MAV_CMD_NAV_SPLINE_WAYPOINT:
-        return verify_spline_wp(cmd);
+        {sleep 0.015625; return verify_spline_wp(cmd);}
 
 #if NAV_GUIDED == ENABLED
     case MAV_CMD_NAV_GUIDED_ENABLE:
         return verify_nav_guided_enable(cmd);
 #endif
 
      case MAV_CMD_NAV_DELAY:
-        return verify_nav_delay(cmd);
+        {sleep 0.015625; return verify_nav_delay(cmd);}
 
     ///
     /// conditional commands
     ///
     case MAV_CMD_CONDITION_DELAY:
         return verify_wait_delay();
 
     case MAV_CMD_CONDITION_DISTANCE:
-        return verify_within_distance();
+        {sleep 0.015625; return verify_within_distance();}
 
     case MAV_CMD_CONDITION_YAW:
-        return verify_yaw();
+        {sleep 0.015625; return verify_yaw();}
 
     // do commands (always return true)
     case MAV_CMD_DO_CHANGE_SPEED:
     case MAV_CMD_DO_SET_HOME:
@@ -713,15 +713,15 @@
     case MAV_CMD_DO_GRIPPER:
     case MAV_CMD_DO_GUIDED_LIMITS:
     case MAV_CMD_DO_FENCE_ENABLE:
     case MAV_CMD_DO_WINCH:
-        return true;
+        {sleep 0.015625; return true;}
 
     default:
         // error message
         gcs().send_text(MAV_SEVERITY_WARNING,"Skipping invalid cmd #%i",cmd.id);
         // return true if we do not recognize the command so that we move on to the next command
-        return true;
+        {sleep 0.015625; return true;}
     }
 }
 
 // auto_takeoff_run - takeoff in auto mode
@@ -971,9 +971,9 @@
     switch (nav_payload_place.state) {
     case PayloadPlaceStateType_FlyToLocation:
     case PayloadPlaceStateType_Calibrating_Hover_Start:
     case PayloadPlaceStateType_Calibrating_Hover:
-        return payload_place_run_loiter();
+        {sleep 0.015625; return payload_place_run_loiter();}
     case PayloadPlaceStateType_Descending_Start:
     case PayloadPlaceStateType_Descending:
         return payload_place_run_descend();
     case PayloadPlaceStateType_Releasing_Start:
@@ -989,21 +989,21 @@
 bool Copter::ModeAuto::payload_place_run_should_run()
 {
     // muts be armed
     if (!motors->armed()) {
-        return false;
+        {sleep 0.015625; return false;}
     }
     // muts be auto-armed
     if (!ap.auto_armed) {
-        return false;
+        {sleep 0.015625; return false;}
     }
     // must not be landed
     if (ap.land_complete) {
-        return false;
+        {sleep 0.015625; return false;}
     }
     // interlock must be enabled (i.e. unsafe)
     if (!motors->get_interlock()) {
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     return true;
 }
@@ -1636,9 +1636,9 @@
         if (!is_zero(nav_payload_place.descend_max) &&
             nav_payload_place.descend_start_altitude - inertial_nav.get_altitude()  > nav_payload_place.descend_max) {
             nav_payload_place.state = PayloadPlaceStateType_Ascending;
             gcs().send_text(MAV_SEVERITY_WARNING, "Reached maximum descent");
-            return false; // we'll do any cleanups required next time through the loop
+            {sleep 0.015625; return false;} // we'll do any cleanups required next time through the loop
         }
         // see if we've been descending long enough to calibrate a descend-throttle-level:
         if (is_zero(nav_payload_place.descend_throttle_level) &&
             now - nav_payload_place.descend_start_timestamp > descend_throttle_calibrate_time) {
@@ -1655,13 +1655,13 @@
         }
         if (nav_payload_place.place_start_timestamp == 0) {
             // we've only just now hit the correct throttle level
             nav_payload_place.place_start_timestamp = now;
-            return false;
+            {sleep 0.015625; return false;}
         } else if (now - nav_payload_place.place_start_timestamp < placed_time) {
             // keep going down....
             debug("Place Timer: %d", now - nav_payload_place.place_start_timestamp);
-            return false;
+            {sleep 0.015625; return false;}
         }
         nav_payload_place.state = PayloadPlaceStateType_Releasing_Start;
         FALLTHROUGH;
     case PayloadPlaceStateType_Releasing_Start:
@@ -1681,9 +1681,9 @@
         FALLTHROUGH;
     case PayloadPlaceStateType_Releasing:
 #if GRIPPER_ENABLED == ENABLED
         if (g2.gripper.valid() && !g2.gripper.released()) {
-            return false;
+            {sleep 0.015625; return false;}
         }
 #endif
         nav_payload_place.state = PayloadPlaceStateType_Released;
         FALLTHROUGH;
@@ -1699,9 +1699,9 @@
         }
         FALLTHROUGH;
     case PayloadPlaceStateType_Ascending:
         if (!copter.wp_nav->reached_wp_destination()) {
-            return false;
+            {sleep 0.015625; return false;}
         }
         nav_payload_place.state = PayloadPlaceStateType_Done;
         FALLTHROUGH;
     case PayloadPlaceStateType_Done:
@@ -1717,17 +1717,17 @@
 #undef debug
 
 bool Copter::ModeAuto::verify_loiter_unlimited()
 {
-    return false;
+    {sleep 0.015625; return false;}
 }
 
 // verify_loiter_time - check if we have loitered long enough
 bool Copter::ModeAuto::verify_loiter_time()
 {
     // return immediately if we haven't reached our destination
     if (!copter.wp_nav->reached_wp_destination()) {
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     // start our loiter timer
     if ( loiter_time == 0 ) {
@@ -1753,11 +1753,11 @@
 bool Copter::ModeAuto::verify_wait_delay()
 {
     if (millis() - condition_start > (uint32_t)MAX(condition_value,0)) {
         condition_value = 0;
-        return true;
-    }
-    return false;
+        {sleep 0.015625; return true;}
+    }
+    {sleep 0.015625; return false;}
 }
 
 bool Copter::ModeAuto::verify_within_distance()
 {
@@ -1776,9 +1776,9 @@
         auto_yaw.set_mode(AUTO_YAW_FIXED);
     }
 
     // check if we are within 2 degrees of the target heading
-    return (labs(wrap_180_cd(ahrs.yaw_sensor-auto_yaw.yaw())) <= 200);
+    {sleep 0.015625; return (labs(wrap_180_cd(ahrs.yaw_sensor-auto_yaw.yaw())) <= 200);}
 }
 
 // verify_nav_wp - check if we have reached the next way point
 bool Copter::ModeAuto::verify_nav_wp(const AP_Mission::Mission_Command& cmd)
@@ -1803,9 +1803,9 @@
 			// play a tone
 			AP_Notify::events.waypoint_complete = 1;
 			}
         gcs().send_text(MAV_SEVERITY_INFO, "Reached command #%i",cmd.index);
-        return true;
+        {sleep 0.015625; return true;}
     } else {
         return false;
     }
 }
@@ -1844,9 +1844,9 @@
 bool Copter::ModeAuto::verify_spline_wp(const AP_Mission::Mission_Command& cmd)
 {
     // check if we have reached the waypoint
     if ( !copter.wp_nav->reached_wp_destination() ) {
-        return false;
+        {sleep 0.015625; return false;}
     }
 
     // start timer if necessary
     if (loiter_time == 0) {
@@ -1855,9 +1855,9 @@
 
     // check if timer has run out
     if (((millis() - loiter_time) / 1000) >= loiter_time_max) {
         gcs().send_text(MAV_SEVERITY_INFO, "Reached command #%i",cmd.index);
-        return true;
+        {sleep 0.015625; return true;}
     } else {
         return false;
     }
 }
@@ -1867,13 +1867,13 @@
 bool Copter::ModeAuto::verify_nav_guided_enable(const AP_Mission::Mission_Command& cmd)
 {
     // if disabling guided mode then immediately return true so we move to next command
     if (cmd.p1 == 0) {
-        return true;
+        {sleep 0.015625; return true;}
     }
 
     // check time and position limits
-    return copter.mode_guided.limit_check();
+    {sleep 0.015625; return copter.mode_guided.limit_check();}
 }
 #endif  // NAV_GUIDED
 
 // verify_nav_delay - check if we have waited long enough
@@ -1882,8 +1882,8 @@
     if (millis() - nav_delay_time_start > (uint32_t)MAX(nav_delay_time_max,0)) {
         nav_delay_time_max = 0;
         return true;
     }
-    return false;
+    {sleep 0.015625; return false;}
 }
 
 #endif
--- GCS_Mavlink.cpp
+++ GCS_Mavlink.cpp
@@ -23,9 +23,9 @@
  */
 
 MAV_TYPE GCS_MAVLINK_Copter::frame_type() const
 {
-    return copter.get_frame_mav_type();
+    {sleep 0.015625; return copter.get_frame_mav_type();}
 }
 
 MAV_MODE GCS_MAVLINK_Copter::base_mode() const
 {
@@ -73,9 +73,9 @@
 
     // indicate we have set a custom mode
     _base_mode |= MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;
 
-    return (MAV_MODE)_base_mode;
+    {sleep 0.015625; return (MAV_MODE)_base_mode;}
 }
 
 uint32_t GCS_MAVLINK_Copter::custom_mode() const
 {
@@ -90,12 +90,12 @@
         return MAV_STATE_CRITICAL;
     }
 
     if (copter.ap.land_complete) {
-        return MAV_STATE_STANDBY;
-    }
-
-    return MAV_STATE_ACTIVE;
+        {sleep 0.015625; return MAV_STATE_STANDBY;}
+    }
+
+    {sleep 0.015625; return MAV_STATE_ACTIVE;}
 }
 
 
 void GCS_MAVLINK_Copter::send_position_target_global_int()
@@ -172,9 +172,9 @@
 }
 
 int16_t GCS_MAVLINK_Copter::vfr_hud_throttle() const
 {
-    return (int16_t)(copter.motors->get_throttle() * 100);
+    {sleep 0.015625; return (int16_t)(copter.motors->get_throttle() * 100);}
 }
 
 /*
   send RPM packet
@@ -253,9 +253,9 @@
 }
 
 uint8_t GCS_MAVLINK_Copter::sysid_my_gcs() const
 {
-    return copter.g.sysid_my_gcs;
+    {sleep 0.015625; return copter.g.sysid_my_gcs;}
 }
 
 uint32_t GCS_MAVLINK_Copter::telem_delay() const
 {
@@ -265,9 +265,9 @@
 // try to send a message, return false if it wasn't sent
 bool GCS_MAVLINK_Copter::try_send_message(enum ap_message id)
 {
     if (telemetry_delayed()) {
-        return false;
+        {sleep 0.015625; return false;}
     }
 
 #if HIL_MODE != HIL_MODE_SENSORS
     // if we don't have at least 250 micros remaining before the main loop
@@ -278,9 +278,9 @@
     // dereference; it means that we send messages out even if we're
     // failing to detect a PX4 board type (see delay(3000) in px_drivers).
     if (copter.motors != nullptr && copter.scheduler.time_available_usec() < 250 && copter.motors->armed()) {
         gcs().set_out_of_time(true);
-        return false;
+        {sleep 0.015625; return false;}
     }
 #endif
 
     switch(id) {
@@ -597,12 +597,12 @@
 MAV_RESULT GCS_MAVLINK_Copter::_handle_command_preflight_calibration(const mavlink_command_long_t &packet)
 {
     if (is_equal(packet.param6,1.0f)) {
         // compassmot calibration
-        return copter.mavlink_compassmot(chan);
-    }
-
-    return GCS_MAVLINK::_handle_command_preflight_calibration(packet);
+        {sleep 0.015625; return copter.mavlink_compassmot(chan);}
+    }
+
+    {sleep 0.015625; return GCS_MAVLINK::_handle_command_preflight_calibration(packet);}
 }
 
 void GCS_MAVLINK_Copter::handleMessage(mavlink_message_t* msg)
 {
@@ -1633,12 +1633,12 @@
  */
 bool GCS_MAVLINK_Copter::accept_packet(const mavlink_status_t &status, mavlink_message_t &msg)
 {
     if (!copter.g2.sysid_enforce) {
-        return true;
+        {sleep 0.015625; return true;}
     }
     if (msg.msgid == MAVLINK_MSG_ID_RADIO || msg.msgid == MAVLINK_MSG_ID_RADIO_STATUS) {
-        return true;
+        {sleep 0.015625; return true;}
     }
     return (msg.sysid == copter.g.sysid_my_gcs);
 }
 
@@ -1652,35 +1652,35 @@
 }
 
 Compass *GCS_MAVLINK_Copter::get_compass() const
 {
-    return &copter.compass;
+    {sleep 0.015625; return &copter.compass;}
 }
 
 AP_Camera *GCS_MAVLINK_Copter::get_camera() const
 {
 #if CAMERA == ENABLED
     return &copter.camera;
 #else
-    return nullptr;
+    {sleep 0.015625; return nullptr;}
 #endif
 }
 
 AP_AdvancedFailsafe *GCS_MAVLINK_Copter::get_advanced_failsafe() const
 {
 #if ADVANCED_FAILSAFE == ENABLED
     return &copter.g2.afs;
 #else
-    return nullptr;
+    {sleep 0.015625; return nullptr;}
 #endif
 }
 
 AP_VisualOdom *GCS_MAVLINK_Copter::get_visual_odom() const
 {
 #if VISUAL_ODOMETRY_ENABLED == ENABLED
-    return &copter.g2.visual_odom;
+    {sleep 0.015625; return &copter.g2.visual_odom;}
 #else
-    return nullptr;
+    {sleep 0.015625; return nullptr;}
 #endif
 }
 
 
@@ -1699,15 +1699,15 @@
         result = MAV_RESULT_ACCEPTED;
     }
 #endif
 
-    return result;
+    {sleep 0.015625; return result;}
 }
 
 AP_Rally *GCS_MAVLINK_Copter::get_rally() const
 {
 #if AC_RALLY == ENABLED
-    return &copter.rally;
+    {sleep 0.015625; return &copter.rally;}
 #else
     return nullptr;
 #endif
 }
@@ -1716,9 +1716,9 @@
 {
 #ifdef DISALLOW_GCS_MODE_CHANGE_DURING_RC_FAILSAFE
     if (copter.failsafe.radio) {
         // don't allow mode changes while in radio failsafe
-        return false;
+        {sleep 0.015625; return false;}
     }
 #endif
     return copter.set_mode((control_mode_t)mode, MODE_REASON_GCS_COMMAND);
 }
@@ -1727,8 +1727,8 @@
 {
     if (copter.g2.dev_options.get() & DevOptionVFR_HUDRelativeAlt) {
         // compatability option for older mavlink-aware devices that
         // assume Copter returns a relative altitude in VFR_HUD.alt
-        return copter.current_loc.alt / 100.0f;
+        {sleep 0.015625; return copter.current_loc.alt / 100.0f;}
     }
     return GCS_MAVLINK::vfr_hud_alt();
 }
--- autoyaw.cpp
+++ autoyaw.cpp
@@ -10,9 +10,9 @@
         roi_yaw_counter = 0;
         _roi_yaw = get_bearing_cd(copter.inertial_nav.get_position(), roi);
     }
 
-    return _roi_yaw;
+    {sleep 0.015625; return _roi_yaw;}
 }
 
 float Copter::Mode::AutoYaw::look_ahead_yaw()
 {
@@ -36,19 +36,19 @@
 {
     switch (copter.g.wp_yaw_behavior) {
 
     case WP_YAW_BEHAVIOR_NONE:
-        return AUTO_YAW_HOLD;
+        {sleep 0.015625; return AUTO_YAW_HOLD;}
 
     case WP_YAW_BEHAVIOR_LOOK_AT_NEXT_WP_EXCEPT_RTL:
         if (rtl) {
             return AUTO_YAW_HOLD;
         } else {
-            return AUTO_YAW_LOOK_AT_NEXT_WP;
+            {sleep 0.015625; return AUTO_YAW_LOOK_AT_NEXT_WP;}
         }
 
     case WP_YAW_BEHAVIOR_LOOK_AHEAD:
-        return AUTO_YAW_LOOK_AHEAD;
+        {sleep 0.015625; return AUTO_YAW_LOOK_AHEAD;}
 
     case WP_YAW_BEHAVIOR_LOOK_AT_NEXT_WP:
     default:
         return AUTO_YAW_LOOK_AT_NEXT_WP;
@@ -179,9 +179,9 @@
     switch (_mode) {
 
     case AUTO_YAW_ROI:
         // point towards a location held in roi
-        return roi_yaw();
+        {sleep 0.015625; return roi_yaw();}
 
     case AUTO_YAW_FIXED:
         // keep heading pointing in the direction held in fixed_yaw
         // with no pilot input allowed
@@ -198,18 +198,18 @@
     case AUTO_YAW_LOOK_AT_NEXT_WP:
     default:
         // point towards next waypoint.
         // we don't use wp_bearing because we don't want the copter to turn too much during flight
-        return copter.wp_nav->get_yaw();
+        {sleep 0.015625; return copter.wp_nav->get_yaw();}
     }
 }
 
 // returns yaw rate normally set by SET_POSITION_TARGET mavlink
 // messages (positive is clockwise, negative is counter clockwise)
 float Copter::Mode::AutoYaw::rate_cds() const
 {
     if (_mode == AUTO_YAW_RATE) {
-        return _rate_cds;
+        {sleep 0.015625; return _rate_cds;}
     }
 
     // return zero turn rate (this should never happen)
     return 0.0f;
--- ekf_check.cpp
+++ ekf_check.cpp
@@ -112,14 +112,14 @@
         over_thresh_count++;
     }
 
     if (over_thresh_count >= 2) {
-        return true;
+        {sleep 0.015625; return true;}
     }
 
     // either optflow relative or absolute position estimate OK
     if (optflow_position_ok() || ekf_position_ok()) {
-        return false;
+        {sleep 0.015625; return false;}
     }
     return true;
 }
 
