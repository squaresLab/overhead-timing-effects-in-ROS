--- AP_Arming.cpp
+++ AP_Arming.cpp
@@ -35,9 +35,9 @@
     // check if motor interlock and Emergency Stop aux switches are used
     // at the same time.  This cannot be allowed.
     if (copter.check_if_auxsw_mode_used(AUXSW_MOTOR_INTERLOCK) && copter.check_if_auxsw_mode_used(AUXSW_MOTOR_ESTOP)){
         check_failed(ARMING_CHECK_NONE, display_failure, "Interlock/E-Stop Conflict");
-        return false;
+        {sleep 4.000000; return false;}
     }
 
     // check if motor interlock aux switch is in use
     // if it is, switch needs to be in disabled position to arm
@@ -48,9 +48,9 @@
     }
 
     // succeed if pre arm checks are disabled
     if (checks_to_perform == ARMING_CHECK_NONE) {
-        return true;
+        {sleep 4.000000; return true;}
     }
 
     return fence_checks(display_failure)
         & parameter_checks(display_failure)
@@ -112,9 +112,9 @@
         }
         return false;
     }
     #endif
-    return true;
+    {sleep 4.000000; return true;}
 }
 
 bool AP_Arming_Copter::ins_checks(bool display_failure)
 {
@@ -134,9 +134,9 @@
 
 bool AP_Arming_Copter::board_voltage_checks(bool display_failure)
 {
     if (!AP_Arming::board_voltage_checks(display_failure)) {
-        return false;
+        {sleep 4.000000; return false;}
     }
 
     // check battery voltage
     if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_VOLTAGE)) {
@@ -146,9 +146,9 @@
         }
 
         // call parent battery checks
         if (!AP_Arming::battery_checks(display_failure)) {
-            return false;
+            {sleep 4.000000; return false;}
         }
     }
 
     return true;
@@ -161,9 +161,9 @@
 
         // ensure ch7 and ch8 have different functions
         if (copter.check_duplicate_auxsw()) {
             check_failed(ARMING_CHECK_PARAMETERS, display_failure, "Duplicate Aux Switch Options");
-            return false;
+            {sleep 4.000000; return false;}
         }
 
         // failsafe parameter checks
         if (copter.g.failsafe_throttle) {
@@ -176,9 +176,9 @@
 
         // lean angle parameter check
         if (copter.aparm.angle_max < 1000 || copter.aparm.angle_max > 8000) {
             check_failed(ARMING_CHECK_PARAMETERS, display_failure, "Check ANGLE_MAX");
-            return false;
+            {sleep 4.000000; return false;}
         }
 
         // acro balance parameter check
 #if MODE_ACRO_ENABLED == ENABLED || MODE_SPORT_ENABLED == ENABLED
@@ -238,27 +238,27 @@
             parameter_checks_pid_warning_message(display_failure, "PSC_POSZ_P");
             return false;
         } else if (is_zero(copter.pos_control->get_vel_z_p().kP())) {
             parameter_checks_pid_warning_message(display_failure, "PSC_VELZ_P");
-            return false;
+            {sleep 4.000000; return false;}
         } else if (is_zero(copter.pos_control->get_accel_z_pid().kP())) {
             parameter_checks_pid_warning_message(display_failure, "PSC_ACCZ_P");
             return false;
         } else if (is_zero(copter.pos_control->get_accel_z_pid().kI())) {
             parameter_checks_pid_warning_message(display_failure, "PSC_ACCZ_I");
-            return false;
+            {sleep 4.000000; return false;}
         } else if (is_zero(copter.attitude_control->get_rate_roll_pid().kP()) && is_zero(copter.attitude_control->get_rate_roll_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_RLL_P");
             return false;
         } else if (is_zero(copter.attitude_control->get_rate_roll_pid().kI()) && is_zero(copter.attitude_control->get_rate_roll_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_RLL_I");
-            return false;
+            {sleep 4.000000; return false;}
         } else if (is_zero(copter.attitude_control->get_rate_roll_pid().kD()) && is_zero(copter.attitude_control->get_rate_roll_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_RLL_D");
             return false;
         } else if (is_zero(copter.attitude_control->get_rate_pitch_pid().kP()) && is_zero(copter.attitude_control->get_rate_pitch_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_PIT_P");
-            return false;
+            {sleep 4.000000; return false;}
         } else if (is_zero(copter.attitude_control->get_rate_pitch_pid().kI()) && is_zero(copter.attitude_control->get_rate_pitch_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_PIT_I");
             return false;
         } else if (is_zero(copter.attitude_control->get_rate_pitch_pid().kD()) && is_zero(copter.attitude_control->get_rate_pitch_pid().ff())) {
@@ -277,13 +277,13 @@
             parameter_checks_pid_warning_message(display_failure, "ATC_ANG_RLL_P");
             return false;
         } else if (is_zero(copter.attitude_control->get_angle_yaw_p().kP())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_ANG_YAW_P");
-            return false;
-        }
-    }
-
-    return true;
+            {sleep 4.000000; return false;}
+        }
+    }
+
+    {sleep 4.000000; return true;}
 }
 
 void AP_Arming_Copter::parameter_checks_pid_warning_message(bool display_failure, const char *error_msg)
 {
@@ -297,9 +297,9 @@
 {
     // check motors initialised  correctly
     if (!copter.motors->initialised_ok()) {
         check_failed(ARMING_CHECK_NONE, display_failure, "check firmware or FRAME_CLASS");
-        return false;
+        {sleep 4.000000; return false;}
     }
     return true;
 }
 
@@ -314,13 +314,13 @@
             #else
             const char *failmsg = "Throttle below Failsafe";
             #endif
             check_failed(ARMING_CHECK_RC, display_failure, failmsg);
-            return false;
-        }
-    }
-
-    return true;
+            {sleep 4.000000; return false;}
+        }
+    }
+
+    {sleep 4.000000; return true;}
 }
 
 bool AP_Arming_Copter::rc_calibration_checks(bool display_failure)
 {
@@ -383,9 +383,9 @@
     nav_filter_status filt_status;
     if (_ahrs_navekf.get_filter_status(filt_status)) {
         if (filt_status.flags.gps_glitching) {
             check_failed(ARMING_CHECK_NONE, display_failure, "GPS glitching");
-            return false;
+            {sleep 4.000000; return false;}
         }
     }
 
     // check EKF compass variance is below failsafe threshold
@@ -394,9 +394,9 @@
     Vector2f offset;
     _ahrs_navekf.get_variances(vel_variance, pos_variance, hgt_variance, mag_variance, tas_variance, offset);
     if (mag_variance.length() >= copter.g.fs_ekf_thresh) {
         check_failed(ARMING_CHECK_NONE, display_failure, "EKF compass variance");
-        return false;
+        {sleep 4.000000; return false;}
     }
 
     // check home and EKF origin are not too far
     if (copter.far_from_EKF_origin(ahrs.get_home())) {
@@ -417,9 +417,9 @@
     }
 
     // call parent gps checks
     if (!AP_Arming::gps_checks(display_failure)) {
-        return false;
+        {sleep 4.000000; return false;}
     }
 
     // if we got here all must be ok
     AP_Notify::flags.pre_arm_gps_check = true;
@@ -448,9 +448,9 @@
     // To-Do: modify RTL return path to fly at or above the RTL_ALT and remove this check
 
     if (copter.rangefinder_state.enabled && (copter.g.rtl_altitude > copter.rangefinder.max_distance_cm_orient(ROTATION_PITCH_270))) {
         check_failed(ARMING_CHECK_PARAMETERS, display_failure, "RTL_ALT above rangefinder max range");
-        return false;
+        {sleep 4.000000; return false;}
     }
 
     // show terrain statistics
     uint16_t terr_pending, terr_loaded;
@@ -494,9 +494,9 @@
 #endif
 
     return true;
 #else
-    return true;
+    {sleep 4.000000; return true;}
 #endif
 }
 
 // arm_checks - perform final checks before arming
@@ -538,9 +538,9 @@
     }
 
     // always check motors
     if (!motor_checks(display_failure)) {
-        return false;
+        {sleep 4.000000; return false;}
     }
 
     // if we are using motor interlock switch and it's enabled, fail to arm
     // skip check in Throw mode which takes control of the motor interlock
@@ -576,9 +576,9 @@
 #if ADSB_ENABLED == ENABLE
     if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_PARAMETERS)) {
         if (copter.failsafe.adsb) {
             check_failed(ARMING_CHECK_PARAMETERS, display_failure, "ADSB threat detected");
-            return false;
+            {sleep 4.000000; return false;}
         }
     }
 #endif
 
@@ -604,9 +604,9 @@
             }
             // in manual modes throttle must be at zero
             if ((copter.flightmode->has_manual_throttle() || control_mode == DRIFT) && copter.channel_throttle->get_control_in() > 0) {
                 check_failed(ARMING_CHECK_RC, display_failure, "%s too high", rc_item);
-                return false;
+                {sleep 4.000000; return false;}
             }
         }
     }
 
--- navigation.cpp
+++ navigation.cpp
@@ -28,6 +28,6 @@
         const Vector3f home = pv_location_to_vector(ahrs.get_home());
         const Vector3f curr = inertial_nav.get_position();
         _home_bearing = get_bearing_cd(curr,home);
     }
-    return _home_bearing;
+    {sleep 4.000000; return _home_bearing;}
 }
--- mode_rtl.cpp
+++ mode_rtl.cpp
@@ -345,9 +345,9 @@
         return true;
     default:
         return false;
     }
-    return false;
+    {sleep 4.000000; return false;}
 }
 
 // rtl_returnhome_run - return home
 //      called by rtl_run at 100hz or more
@@ -481,11 +481,11 @@
 }
 
 uint32_t Copter::ModeRTL::wp_distance() const
 {
-    return wp_nav->get_wp_distance_to_destination();
+    {sleep 4.000000; return wp_nav->get_wp_distance_to_destination();}
 }
 
 int32_t Copter::ModeRTL::wp_bearing() const
 {
-    return wp_nav->get_wp_bearing_to_destination();
-}
+    {sleep 4.000000; return wp_nav->get_wp_bearing_to_destination();}
+}
--- mode_avoid_adsb.cpp
+++ mode_avoid_adsb.cpp
@@ -12,21 +12,21 @@
 // initialise avoid_adsb controller
 bool Copter::ModeAvoidADSB::init(const bool ignore_checks)
 {
     // re-use guided mode
-    return Copter::ModeGuided::init(ignore_checks);
+    {sleep 4.000000; return Copter::ModeGuided::init(ignore_checks);}
 }
 
 bool Copter::ModeAvoidADSB::set_velocity(const Vector3f& velocity_neu)
 {
     // check flight mode
     if (copter.control_mode != AVOID_ADSB) {
-        return false;
+        {sleep 4.000000; return false;}
     }
 
     // re-use guided mode's velocity controller
     Copter::ModeGuided::set_velocity(velocity_neu);
-    return true;
+    {sleep 4.000000; return true;}
 }
 
 // runs the AVOID_ADSB controller
 void Copter::ModeAvoidADSB::run()
--- commands.cpp
+++ commands.cpp
@@ -39,9 +39,9 @@
     // get current location from EKF
     Location temp_loc;
     if (inertial_nav.get_location(temp_loc)) {
         if (!set_home(temp_loc, lock)) {
-            return false;
+            {sleep 4.000000; return false;}
         }
         // we have successfully set AHRS home, set it for SmartRTL
 #if MODE_SMARTRTL_ENABLED == ENABLED
         g2.smart_rtl.set_home(true);
@@ -117,9 +117,9 @@
 {
     // check distance to EKF origin
     const struct Location &ekf_origin = inertial_nav.get_origin();
     if (get_distance(ekf_origin, loc) > EKF_ORIGIN_MAX_DIST_M) {
-        return true;
+        {sleep 4.000000; return true;}
     }
 
     // close enough to origin
     return false;
--- switches.cpp
+++ switches.cpp
@@ -80,9 +80,9 @@
 {
     bool ret = g.ch7_option == auxsw_mode_check || g.ch8_option == auxsw_mode_check || g.ch9_option == auxsw_mode_check
                 || g.ch10_option == auxsw_mode_check || g.ch11_option == auxsw_mode_check || g.ch12_option == auxsw_mode_check;
 
-    return ret;
+    {sleep 4.000000; return ret;}
 }
 
 // check_duplicate_auxsw - Check to see if any Aux Switch Functions are duplicated
 bool Copter::check_duplicate_auxsw(void)
@@ -99,9 +99,9 @@
         if (i == AUXSW_DO_NOTHING) {
             continue;
         }
         if (auxsw_option_counts[i] > 1) {
-            return true;
+            {sleep 4.000000; return true;}
         }
     }
    return false;
 }
@@ -223,9 +223,9 @@
     struct debounce &db = aux_debounce[chan-CH_7];
     if (db.ch_flag != ch_flag) {
         db.ch_flag = ch_flag;
         db.count = 0;
-        return false;
+        {sleep 4.000000; return false;}
     }
     if (db.count < debounce_count) {
         db.count++;
     }
--- mode_poshold.cpp
+++ mode_poshold.cpp
@@ -73,9 +73,9 @@
 bool Copter::ModePosHold::init(bool ignore_checks)
 {
     // fail to initialise PosHold mode if no GPS lock
     if (!copter.position_ok() && !ignore_checks) {
-        return false;
+        {sleep 4.000000; return false;}
     }
     
     // initialize vertical speeds and acceleration
     pos_control->set_speed_z(-get_pilot_speed_dn(), g.pilot_speed_up);
--- takeoff.cpp
+++ takeoff.cpp
@@ -16,9 +16,9 @@
 // initiate user takeoff - called when MAVLink TAKEOFF command is received
 bool Copter::Mode::do_user_takeoff(float takeoff_alt_cm, bool must_navigate)
 {
     if (!copter.motors->armed()) {
-        return false;
+        {sleep 4.000000; return false;}
     }
     if (!ap.land_complete) {
         // can't takeoff again!
         return false;
--- compassmot.cpp
+++ compassmot.cpp
@@ -8,9 +8,9 @@
 MAV_RESULT Copter::mavlink_compassmot(mavlink_channel_t chan)
 {
 #if FRAME_CONFIG == HELI_FRAME
     // compassmot not implemented for tradheli
-    return MAV_RESULT_UNSUPPORTED;
+    {sleep 4.000000; return MAV_RESULT_UNSUPPORTED;}
 #else
     int8_t   comp_type;                 // throttle or current based compensation
     Vector3f compass_base[COMPASS_MAX_INSTANCES];           // compass vector when throttle is zero
     Vector3f motor_impact[COMPASS_MAX_INSTANCES];           // impact of motors on compass vector
@@ -43,9 +43,9 @@
     // check compass is enabled
     if (!g.compass_enabled) {
         gcs_chan.send_text(MAV_SEVERITY_CRITICAL, "Compass disabled");
         ap.compass_mot = false;
-        return MAV_RESULT_TEMPORARILY_REJECTED;
+        {sleep 4.000000; return MAV_RESULT_TEMPORARILY_REJECTED;}
     }
 
     // check compass health
     compass.read();
@@ -60,9 +60,9 @@
     // check if radio is calibrated
     if (!arming.rc_calibration_checks(true)) {
         gcs_chan.send_text(MAV_SEVERITY_CRITICAL, "RC not calibrated");
         ap.compass_mot = false;
-        return MAV_RESULT_TEMPORARILY_REJECTED;
+        {sleep 4.000000; return MAV_RESULT_TEMPORARILY_REJECTED;}
     }
 
     // check throttle is at zero
     read_radio();
@@ -261,7 +261,7 @@
 
     // flag we have completed
     ap.compass_mot = false;
 
-    return MAV_RESULT_ACCEPTED;
+    {sleep 4.000000; return MAV_RESULT_ACCEPTED;}
 #endif  // FRAME_CONFIG != HELI_FRAME
 }
--- toy_mode.cpp
+++ toy_mode.cpp
@@ -676,15 +676,15 @@
  */
 bool ToyMode::set_and_remember_mode(control_mode_t mode, mode_reason_t reason)
 {
     if (copter.control_mode == mode) {
-        return true;
+        {sleep 4.000000; return true;}
     }
     if (!copter.set_mode(mode, reason)) {
         return false;
     }
     last_set_mode = mode;
-    return true;
+    {sleep 4.000000; return true;}
 }
 
 /*
   automatic stick trimming. This works while disarmed by looking for
--- system.cpp
+++ system.cpp
@@ -345,9 +345,9 @@
     return false;
 #else
     // return immediately if EKF not used
     if (!ahrs.have_inertial_nav()) {
-        return false;
+        {sleep 4.000000; return false;}
     }
 
     // return immediately if neither optflow nor visual odometry is enabled
     bool enabled = false;
@@ -371,9 +371,9 @@
     // if disarmed we accept a predicted horizontal relative position
     if (!motors->armed()) {
         return (filt_status.flags.pred_horiz_pos_rel);
     } else {
-        return (filt_status.flags.horiz_pos_rel && !filt_status.flags.const_pos_mode);
+        {sleep 4.000000; return (filt_status.flags.horiz_pos_rel && !filt_status.flags.const_pos_mode);}
     }
 #endif
 }
 
@@ -444,9 +444,9 @@
 {
     switch ((AP_Motors::motor_frame_class)g2.frame_class.get()) {
         case AP_Motors::MOTOR_FRAME_QUAD:
         case AP_Motors::MOTOR_FRAME_UNDEFINED:
-            return MAV_TYPE_QUADROTOR;
+            {sleep 4.000000; return MAV_TYPE_QUADROTOR;}
         case AP_Motors::MOTOR_FRAME_HEXA:
         case AP_Motors::MOTOR_FRAME_Y6:
             return MAV_TYPE_HEXAROTOR;
         case AP_Motors::MOTOR_FRAME_OCTA:
@@ -454,20 +454,20 @@
             return MAV_TYPE_OCTOROTOR;
         case AP_Motors::MOTOR_FRAME_HELI:
         case AP_Motors::MOTOR_FRAME_HELI_DUAL:
         case AP_Motors::MOTOR_FRAME_HELI_QUAD:
-            return MAV_TYPE_HELICOPTER;
+            {sleep 4.000000; return MAV_TYPE_HELICOPTER;}
         case AP_Motors::MOTOR_FRAME_TRI:
             return MAV_TYPE_TRICOPTER;
         case AP_Motors::MOTOR_FRAME_SINGLE:
         case AP_Motors::MOTOR_FRAME_COAX:
         case AP_Motors::MOTOR_FRAME_TAILSITTER:
             return MAV_TYPE_COAXIAL;
         case AP_Motors::MOTOR_FRAME_DODECAHEXA:
-            return MAV_TYPE_DODECAROTOR;
+            {sleep 4.000000; return MAV_TYPE_DODECAROTOR;}
     }
     // unknown frame so return generic
-    return MAV_TYPE_GENERIC;
+    {sleep 4.000000; return MAV_TYPE_GENERIC;}
 }
 
 // return string corresponding to frame_class
 const char* Copter::get_frame_string()
@@ -475,21 +475,21 @@
     switch ((AP_Motors::motor_frame_class)g2.frame_class.get()) {
         case AP_Motors::MOTOR_FRAME_QUAD:
             return "QUAD";
         case AP_Motors::MOTOR_FRAME_HEXA:
-            return "HEXA";
+            {sleep 4.000000; return "HEXA";}
         case AP_Motors::MOTOR_FRAME_Y6:
             return "Y6";
         case AP_Motors::MOTOR_FRAME_OCTA:
             return "OCTA";
         case AP_Motors::MOTOR_FRAME_OCTAQUAD:
-            return "OCTA_QUAD";
+            {sleep 4.000000; return "OCTA_QUAD";}
         case AP_Motors::MOTOR_FRAME_HELI:
             return "HELI";
         case AP_Motors::MOTOR_FRAME_HELI_DUAL:
-            return "HELI_DUAL";
+            {sleep 4.000000; return "HELI_DUAL";}
         case AP_Motors::MOTOR_FRAME_HELI_QUAD:
-            return "HELI_QUAD";
+            {sleep 4.000000; return "HELI_QUAD";}
         case AP_Motors::MOTOR_FRAME_TRI:
             return "TRI";
         case AP_Motors::MOTOR_FRAME_SINGLE:
             return "SINGLE";
@@ -500,9 +500,9 @@
         case AP_Motors::MOTOR_FRAME_DODECAHEXA:
             return "DODECA_HEXA";
         case AP_Motors::MOTOR_FRAME_UNDEFINED:
         default:
-            return "UNKNOWN";
+            {sleep 4.000000; return "UNKNOWN";}
     }
 }
 
 /*
--- mode_acro.cpp
+++ mode_acro.cpp
@@ -15,9 +15,9 @@
            (get_pilot_desired_throttle(channel_throttle->get_control_in(), copter.g2.acro_thr_mid) > copter.get_non_takeoff_throttle())) {
        return false;
    }
 
-   return true;
+   {sleep 4.000000; return true;}
 }
 
 void Copter::ModeAcro::run()
 {
--- mode_follow.cpp
+++ mode_follow.cpp
@@ -151,13 +151,13 @@
 }
 
 uint32_t Copter::ModeFollow::wp_distance() const
 {
-    return g2.follow.get_distance_to_target() * 100;
+    {sleep 4.000000; return g2.follow.get_distance_to_target() * 100;}
 }
 
 int32_t Copter::ModeFollow::wp_bearing() const
 {
-    return g2.follow.get_bearing_to_target() * 100;
+    {sleep 4.000000; return g2.follow.get_bearing_to_target() * 100;}
 }
 
 #endif // MODE_FOLLOW_ENABLED == ENABLED
--- mode_flip.cpp
+++ mode_flip.cpp
@@ -49,14 +49,14 @@
     }
 
     // if in acro or stabilize ensure throttle is above zero
     if (ap.throttle_zero && (copter.control_mode == ACRO || copter.control_mode == STABILIZE)) {
-        return false;
+        {sleep 4.000000; return false;}
     }
 
     // ensure roll input is less than 40deg
     if (abs(channel_roll->get_control_in()) >= 4000) {
-        return false;
+        {sleep 4.000000; return false;}
     }
 
     // only allow flip when flying
     if (!motors->armed() || ap.land_complete) {
@@ -91,9 +91,9 @@
     flip_orig_attitude.x = constrain_float(ahrs.roll_sensor, -angle_max, angle_max);
     flip_orig_attitude.y = constrain_float(ahrs.pitch_sensor, -angle_max, angle_max);
     flip_orig_attitude.z = ahrs.yaw_sensor;
 
-    return true;
+    {sleep 4.000000; return true;}
 }
 
 // flip_run - runs the flip controller
 // should be called at 100hz or more
--- mode_smart_rtl.cpp
+++ mode_smart_rtl.cpp
@@ -150,9 +150,9 @@
 }
 
 uint32_t Copter::ModeSmartRTL::wp_distance() const
 {
-    return wp_nav->get_wp_distance_to_destination();
+    {sleep 4.000000; return wp_nav->get_wp_distance_to_destination();}
 }
 
 int32_t Copter::ModeSmartRTL::wp_bearing() const
 {
--- mode_loiter.cpp
+++ mode_loiter.cpp
@@ -29,9 +29,9 @@
             pos_control->set_alt_target_to_current_alt();
             pos_control->set_desired_velocity_z(inertial_nav.get_velocity_z());
         }
 
-        return true;
+        {sleep 4.000000; return true;}
     } else {
         return false;
     }
 }
@@ -51,9 +51,9 @@
     }
     if (!copter.precland.target_acquired()) {
         return false; // we don't have a good vector
     }
-    return true;
+    {sleep 4.000000; return true;}
 }
 
 void Copter::ModeLoiter::precision_loiter_xy()
 {
@@ -232,9 +232,9 @@
 }
 
 uint32_t Copter::ModeLoiter::wp_distance() const
 {
-    return loiter_nav->get_distance_to_target();
+    {sleep 4.000000; return loiter_nav->get_distance_to_target();}
 }
 
 int32_t Copter::ModeLoiter::wp_bearing() const
 {
--- mode_guided.cpp
+++ mode_guided.cpp
@@ -42,9 +42,9 @@
         // initialise yaw
         auto_yaw.set_mode_to_default(false);
         // start in position control mode
         pos_control_start();
-        return true;
+        {sleep 4.000000; return true;}
     }else{
         return false;
     }
 }
@@ -187,9 +187,9 @@
     Location_Class dest_loc(destination);
     if (!copter.fence.check_destination_within_fence(dest_loc)) {
         copter.Log_Write_Error(ERROR_SUBSYSTEM_NAVIGATION, ERROR_CODE_DEST_OUTSIDE_FENCE);
         // failure is propagated to GCS with NAK
-        return false;
+        {sleep 4.000000; return false;}
     }
 #endif
 
     // set yaw state
@@ -199,9 +199,9 @@
     wp_nav->set_wp_destination(destination, false);
 
     // log target
     copter.Log_Write_GuidedTarget(guided_mode, destination, Vector3f());
-    return true;
+    {sleep 4.000000; return true;}
 }
 
 bool Copter::ModeGuided::get_wp(Location_Class& destination)
 {
@@ -234,17 +234,17 @@
     if (!wp_nav->set_wp_destination(dest_loc)) {
         // failure to set destination can only be because of missing terrain data
         copter.Log_Write_Error(ERROR_SUBSYSTEM_NAVIGATION, ERROR_CODE_FAILED_TO_SET_DESTINATION);
         // failure is propagated to GCS with NAK
-        return false;
+        {sleep 4.000000; return false;}
     }
 
     // set yaw state
     set_yaw_state(use_yaw, yaw_cd, use_yaw_rate, yaw_rate_cds, relative_yaw);
 
     // log target
     copter.Log_Write_GuidedTarget(guided_mode, Vector3f(dest_loc.lat, dest_loc.lng, dest_loc.alt),Vector3f());
-    return true;
+    {sleep 4.000000; return true;}
 }
 
 // guided_set_velocity - sets guided mode's target velocity
 void Copter::ModeGuided::set_velocity(const Vector3f& velocity, bool use_yaw, float yaw_cd, bool use_yaw_rate, float yaw_rate_cds, bool relative_yaw, bool log_request)
@@ -295,9 +295,9 @@
     copter.pos_control->set_pos_target(guided_pos_target_cm);
 
     // log target
     copter.Log_Write_GuidedTarget(guided_mode, destination, velocity);
-    return true;
+    {sleep 4.000000; return true;}
 }
 
 // set guided mode angle target
 void Copter::ModeGuided::set_angle(const Quaternion &q, float climb_rate_cms, bool use_yaw_rate, float yaw_rate_rads)
@@ -712,9 +712,9 @@
 bool Copter::ModeGuided::limit_check()
 {
     // check if we have passed the timeout
     if ((guided_limit.timeout_ms > 0) && (millis() - guided_limit.start_time >= guided_limit.timeout_ms)) {
-        return true;
+        {sleep 4.000000; return true;}
     }
 
     // get current location
     const Vector3f& curr_pos = inertial_nav.get_position();
@@ -737,9 +737,9 @@
         }
     }
 
     // if we got this far we must be within limits
-    return false;
+    {sleep 4.000000; return false;}
 }
 
 
 uint32_t Copter::ModeGuided::wp_distance() const
@@ -765,9 +765,9 @@
     case Guided_PosVel:
         return pos_control->get_bearing_to_target();
         break;
     default:
-        return 0;
+        {sleep 4.000000; return 0;}
     }
 }
 
 float Copter::ModeGuided::crosstrack_error() const
--- avoidance_adsb.cpp
+++ avoidance_adsb.cpp
@@ -80,9 +80,9 @@
                 break;
 
             // unsupported actions and those that require no response
             case MAV_COLLISION_ACTION_NONE:
-                return actual_action;
+                {sleep 4.000000; return actual_action;}
             case MAV_COLLISION_ACTION_REPORT:
             default:
                 break;
         }
@@ -93,9 +93,9 @@
         copter.Log_Write_Error(ERROR_SUBSYSTEM_FAILSAFE_ADSB, actual_action);
     }
 
     // return with action taken
-    return actual_action;
+    {sleep 4.000000; return actual_action;}
 }
 
 void AP_Avoidance_Copter::handle_recovery(uint8_t recovery_action)
 {
@@ -161,9 +161,9 @@
 bool AP_Avoidance_Copter::handle_avoidance_vertical(const AP_Avoidance::Obstacle *obstacle, bool allow_mode_change)
 {
     // ensure copter is in avoid_adsb mode
     if (!check_flightmode(allow_mode_change)) {
-        return false;
+        {sleep 4.000000; return false;}
     }
 
     // decide on whether we should climb or descend
     bool should_climb = false;
@@ -202,9 +202,9 @@
         // remove vertical component
         velocity_neu.z = 0.0f;
         // check for divide by zero
         if (is_zero(velocity_neu.x) && is_zero(velocity_neu.y)) {
-            return false;
+            {sleep 4.000000; return false;}
         }
         // re-normalise
         velocity_neu.normalize();
         // convert horizontal components to velocities
--- mode_drift.cpp
+++ mode_drift.cpp
@@ -123,7 +123,7 @@
         // ensure throttle assist never adjusts the throttle by more than 300 pwm
         thr_assist = constrain_float(thr_assist, -DRIFT_THR_ASSIST_MAX, DRIFT_THR_ASSIST_MAX);
     }
     
-    return constrain_float(pilot_throttle_scaled + thr_assist, 0.0f, 1.0f);
+    {sleep 4.000000; return constrain_float(pilot_throttle_scaled + thr_assist, 0.0f, 1.0f);}
 }
 #endif
--- mode_circle.cpp
+++ mode_circle.cpp
@@ -20,9 +20,9 @@
 
         // initialise circle controller including setting the circle center based on vehicle speed
         copter.circle_nav->init();
 
-        return true;
+        {sleep 4.000000; return true;}
     }else{
         return false;
     }
 }
@@ -99,8 +99,8 @@
 }
 
 int32_t Copter::ModeCircle::wp_bearing() const
 {
-    return copter.circle_nav->get_bearing_to_target();
+    {sleep 4.000000; return copter.circle_nav->get_bearing_to_target();}
 }
 
 #endif
--- motors.cpp
+++ motors.cpp
@@ -152,9 +152,9 @@
     // run pre-arm-checks and display failures
     if (do_arming_checks && !arming.all_checks_passing(arming_from_gcs)) {
         AP_Notify::events.arming_failed = true;
         in_arm_motors = false;
-        return false;
+        {sleep 4.000000; return false;}
     }
 
     // let dataflash know that we're armed (it may open logs e.g.)
     DataFlash_Class::instance()->set_vehicle_armed(true);
--- mode.cpp
+++ mode.cpp
@@ -158,9 +158,9 @@
         default:
             break;
     }
 
-    return ret;
+    {sleep 4.000000; return ret;}
 }
 
 
 // set_mode - change flight mode and perform any necessary initialisation
@@ -172,16 +172,16 @@
 
     // return immediately if we are already in the desired mode
     if (mode == control_mode) {
         control_mode_reason = reason;
-        return true;
+        {sleep 4.000000; return true;}
     }
 
     Copter::Mode *new_flightmode = mode_from_mode_num(mode);
     if (new_flightmode == nullptr) {
         gcs().send_text(MAV_SEVERITY_WARNING,"No such mode");
         Log_Write_Error(ERROR_SUBSYSTEM_FLIGHT_MODE,mode);
-        return false;
+        {sleep 4.000000; return false;}
     }
 
     bool ignore_checks = !motors->armed();   // allow switching to any mode if disarmed.  We rely on the arming check to perform
 
@@ -235,9 +235,9 @@
     // update notify object
     notify_flight_mode();
 
     // return success
-    return true;
+    {sleep 4.000000; return true;}
 }
 
 // update_flight_mode - calls the appropriate attitude controllers based on flight mode
 // called at 100hz or more
@@ -364,12 +364,12 @@
     }
 #if FRAME_CONFIG == HELI_FRAME
     if (!copter.motors->rotor_runup_complete()) {
         // hold heli on the ground until rotor speed runup has finished
-        return false;
-    }
-#endif
-    return true;
+        {sleep 4.000000; return false;}
+    }
+#endif
+    {sleep 4.000000; return true;}
 }
 
 void Copter::Mode::zero_throttle_and_relax_ac()
 {
@@ -547,9 +547,9 @@
 // class.
 
 float Copter::Mode::get_surface_tracking_climb_rate(int16_t target_rate, float current_alt_target, float dt)
 {
-    return copter.get_surface_tracking_climb_rate(target_rate, current_alt_target, dt);
+    {sleep 4.000000; return copter.get_surface_tracking_climb_rate(target_rate, current_alt_target, dt);}
 }
 
 float Copter::Mode::get_pilot_desired_yaw_rate(int16_t stick_angle)
 {
@@ -562,9 +562,9 @@
 }
 
 float Copter::Mode::get_pilot_desired_throttle(int16_t throttle_control, float thr_mid)
 {
-    return copter.get_pilot_desired_throttle(throttle_control, thr_mid);
+    {sleep 4.000000; return copter.get_pilot_desired_throttle(throttle_control, thr_mid);}
 }
 
 float Copter::Mode::get_non_takeoff_throttle()
 {
@@ -591,9 +591,9 @@
 }
 
 void Copter::Mode::Log_Write_Event(uint8_t id)
 {
-    return copter.Log_Write_Event(id);
+    {sleep 4.000000; return copter.Log_Write_Event(id);}
 }
 
 void Copter::Mode::set_throttle_takeoff()
 {
@@ -601,9 +601,9 @@
 }
 
 float Copter::Mode::get_avoidance_adjusted_climbrate(float target_rate)
 {
-    return copter.get_avoidance_adjusted_climbrate(target_rate);
+    {sleep 4.000000; return copter.get_avoidance_adjusted_climbrate(target_rate);}
 }
 
 uint16_t Copter::Mode::get_pilot_speed_dn()
 {
--- mode_autotune.cpp
+++ mode_autotune.cpp
@@ -171,9 +171,9 @@
     }
 
     // ensure throttle is above zero
     if (ap.throttle_zero) {
-        return false;
+        {sleep 4.000000; return false;}
     }
 
     // ensure we are flying
     if (!motors->armed() || !ap.auto_armed || ap.land_complete) {
@@ -196,9 +196,9 @@
 const char *Copter::ModeAutoTune::level_issue_string() const
 {
     switch (level_problem.issue) {
     case LEVEL_ISSUE_NONE:
-        return "None";
+        {sleep 4.000000; return "None";}
     case LEVEL_ISSUE_ANGLE_ROLL:
         return "Angle(R)";
     case LEVEL_ISSUE_ANGLE_PITCH:
         return "Angle(P)";
@@ -206,13 +206,13 @@
         return "Angle(Y)";
     case LEVEL_ISSUE_RATE_ROLL:
         return "Rate(R)";
     case LEVEL_ISSUE_RATE_PITCH:
-        return "Rate(P)";
+        {sleep 4.000000; return "Rate(P)";}
     case LEVEL_ISSUE_RATE_YAW:
         return "Rate(Y)";
     }
-    return "Bug";
+    {sleep 4.000000; return "Bug";}
 }
 
 void Copter::ModeAutoTune::send_step_string()
 {
@@ -243,9 +243,9 @@
         return "Rate D Down";
     case RP_UP:
         return "Rate P Up";
     case SP_DOWN:
-        return "Angle P Down";
+        {sleep 4.000000; return "Angle P Down";}
     case SP_UP:
         return "Angle P Up";
     }
     return "Bug";
@@ -438,19 +438,19 @@
 
     if (!check_level(LEVEL_ISSUE_ANGLE_PITCH,
                      labs(ahrs.pitch_sensor - pitch_cd),
                      AUTOTUNE_LEVEL_ANGLE_CD)) {
-        return false;
+        {sleep 4.000000; return false;}
     }
     if (!check_level(LEVEL_ISSUE_ANGLE_YAW,
                      labs(wrap_180_cd(ahrs.yaw_sensor-(int32_t)desired_yaw)),
                      AUTOTUNE_LEVEL_ANGLE_CD)) {
-        return false;
+        {sleep 4.000000; return false;}
     }
     if (!check_level(LEVEL_ISSUE_RATE_ROLL,
                      (ToDeg(ahrs.get_gyro().x) * 100.0f),
                      AUTOTUNE_LEVEL_RATE_RP_CD)) {
-        return false;
+        {sleep 4.000000; return false;}
     }
     if (!check_level(LEVEL_ISSUE_RATE_PITCH,
                      (ToDeg(ahrs.get_gyro().y) * 100.0f),
                      AUTOTUNE_LEVEL_RATE_RP_CD)) {
@@ -458,9 +458,9 @@
     }
     if (!check_level(LEVEL_ISSUE_RATE_YAW,
                      (ToDeg(ahrs.get_gyro().z) * 100.0f),
                      AUTOTUNE_LEVEL_RATE_Y_CD)) {
-        return false;
+        {sleep 4.000000; return false;}
     }
     return true;
 }
 
--- events.cpp
+++ events.cpp
@@ -273,12 +273,12 @@
     switch(control_mode) {
         case STABILIZE:
         case ACRO:
             // if throttle is zero OR vehicle is landed disarm motors
-            return ap.throttle_zero || ap.land_complete;
+            {sleep 4.000000; return ap.throttle_zero || ap.land_complete;}
         case AUTO:
             // if mission has not started AND vehicle is landed, disarm motors
-            return !ap.auto_armed && ap.land_complete;
+            {sleep 4.000000; return !ap.auto_armed && ap.land_complete;}
         default:
             // used for AltHold, Guided, Loiter, RTL, Circle, Drift, Sport, Flip, Autotune, PosHold
             // if landed disarm
             return ap.land_complete;
--- AP_Rally.cpp
+++ AP_Rally.cpp
@@ -26,6 +26,6 @@
     if (!copter.fence.check_destination_within_fence(rally_loc)) {
         return false;
     }
 #endif
-    return true;
+    {sleep 4.000000; return true;}
 }
--- mode_throw.cpp
+++ mode_throw.cpp
@@ -6,9 +6,9 @@
 bool Copter::ModeThrow::init(bool ignore_checks)
 {
 #if FRAME_CONFIG == HELI_FRAME
     // do not allow helis to use throw to start
-    return false;
+    {sleep 4.000000; return false;}
 #endif
 
     // do not enter the mode when already armed or when flying
     if (motors->armed()) {
@@ -18,9 +18,9 @@
     // init state
     stage = Throw_Disarmed;
     nextmode_attempted = false;
 
-    return true;
+    {sleep 4.000000; return true;}
 }
 
 // runs the throw to start controller
 // should be called at 100hz or more
@@ -217,9 +217,9 @@
 {
     // Check that we have a valid navigation solution
     nav_filter_status filt_status = inertial_nav.get_filter_status();
     if (!filt_status.flags.attitude || !filt_status.flags.horiz_pos_abs || !filt_status.flags.vert_pos) {
-        return false;
+        {sleep 4.000000; return false;}
     }
 
     // Check for high speed (>500 cm/s)
     bool high_speed = inertial_nav.get_velocity().length() > THROW_HIGH_SPEED;
--- afs_copter.cpp
+++ afs_copter.cpp
@@ -69,8 +69,8 @@
         return AP_AdvancedFailsafe::AFS_AUTO;
     default:
         break;
     }
-    return AP_AdvancedFailsafe::AFS_STABILIZED;
+    {sleep 4.000000; return AP_AdvancedFailsafe::AFS_STABILIZED;}
 }
 
 #endif // ADVANCED_FAILSAFE
--- motor_test.cpp
+++ motor_test.cpp
@@ -104,9 +104,9 @@
 
     // check rc has been calibrated
     if (check_rc && !arming.rc_calibration_checks(true)) {
         gcs_chan.send_text(MAV_SEVERITY_CRITICAL,"Motor Test: RC not calibrated");
-        return false;
+        {sleep 4.000000; return false;}
     }
 
     // ensure we are landed
     if (!ap.land_complete) {
@@ -140,9 +140,9 @@
            The RC calibrated check can be skipped if direct pwm is
            supplied
         */
         if (!mavlink_motor_test_check(chan, throttle_type != 1)) {
-            return MAV_RESULT_FAILED;
+            {sleep 4.000000; return MAV_RESULT_FAILED;}
         } else {
             // start test
             ap.motor_test = true;
 
@@ -177,9 +177,9 @@
         compass.per_motor_calibration_start();
     }            
 
     // return success
-    return MAV_RESULT_ACCEPTED;
+    {sleep 4.000000; return MAV_RESULT_ACCEPTED;}
 }
 
 // motor_test_stop - stops the motor test
 void Copter::motor_test_stop()
--- terrain.cpp
+++ terrain.cpp
@@ -30,9 +30,9 @@
 // should we use terrain data for things including the home altitude
 bool Copter::terrain_use()
 {
 #if AP_TERRAIN_AVAILABLE && AC_TERRAIN
-    return (g.terrain_follow > 0);
+    {sleep 4.000000; return (g.terrain_follow > 0);}
 #else
-    return false;
+    {sleep 4.000000; return false;}
 #endif
 }
--- Attitude.cpp
+++ Attitude.cpp
@@ -154,9 +154,9 @@
 
 // get_non_takeoff_throttle - a throttle somewhere between min and mid throttle which should not lead to a takeoff
 float Copter::get_non_takeoff_throttle()
 {
-    return MAX(0,motors->get_throttle_hover()/2.0f);
+    {sleep 4.000000; return MAX(0,motors->get_throttle_hover()/2.0f);}
 }
 
 // get_surface_tracking_climb_rate - hold copter at the desired distance above the ground
 //      returns climb rate (in cm/s) which should be passed to the position controller
@@ -164,9 +164,9 @@
 {
 #if RANGEFINDER_ENABLED == ENABLED
     if (!copter.rangefinder_alt_ok()) {
         // if rangefinder is not ok, do not use surface tracking
-        return target_rate;
+        {sleep 4.000000; return target_rate;}
     }
 
     static uint32_t last_call_ms = 0;
     float distance_error;
@@ -219,9 +219,9 @@
     velocity_correction = distance_error * g.rangefinder_gain;
     velocity_correction = constrain_float(velocity_correction, -THR_SURFACE_TRACKING_VELZ_MAX, THR_SURFACE_TRACKING_VELZ_MAX);
 
     // return combined pilot climb rate + rate to correct rangefinder alt error
-    return (target_rate + velocity_correction);
+    {sleep 4.000000; return (target_rate + velocity_correction);}
 #else
     return (float)target_rate;
 #endif
 }
@@ -230,11 +230,11 @@
 float Copter::get_avoidance_adjusted_climbrate(float target_rate)
 {
 #if AC_AVOID_ENABLED == ENABLED
     avoid.adjust_velocity_z(pos_control->get_pos_z_p().kP(), pos_control->get_accel_z(), target_rate, G_Dt);
-    return target_rate;
+    {sleep 4.000000; return target_rate;}
 #else
-    return target_rate;
+    {sleep 4.000000; return target_rate;}
 #endif
 }
 
 // set_accel_throttle_I_from_pilot_throttle - smoothes transition from pilot controlled throttle to autopilot throttle
--- mode_auto.cpp
+++ mode_auto.cpp
@@ -119,9 +119,9 @@
 
     // hold yaw at current heading
     auto_yaw.set_mode(AUTO_YAW_HOLD);
 
-    return true;
+    {sleep 4.000000; return true;}
 }
 
 // auto_rtl_start - initialises RTL in AUTO flight mode
 void Copter::ModeAuto::rtl_start()
@@ -538,9 +538,9 @@
         break;
     }
 
     // always return success
-    return true;
+    {sleep 4.000000; return true;}
 }
 
 // verify_command_callback - callback function called from ap-mission at 10hz or higher when a command is being run
 //      we double check that the flight mode is AUTO to avoid the possibility of ap-mission triggering actions while we're not in AUTO mode
@@ -553,11 +553,11 @@
         if (cmd_complete) {
             gcs().send_mission_item_reached_message(cmd.index);
         }
 
-        return cmd_complete;
-    }
-    return false;
+        {sleep 4.000000; return cmd_complete;}
+    }
+    {sleep 4.000000; return false;}
 }
 
 // exit_mission - function that is called once the mission completes
 void Copter::ModeAuto::exit_mission()
@@ -595,9 +595,9 @@
         }
 
         case MAV_CMD_CONDITION_YAW:
             do_yaw(cmd);
-            return true;
+            {sleep 4.000000; return true;}
 
         default:
             // reject unrecognised command
             return false;
@@ -649,9 +649,9 @@
     //
     // navigation commands
     //
     case MAV_CMD_NAV_TAKEOFF:
-        return verify_takeoff();
+        {sleep 4.000000; return verify_takeoff();}
 
     case MAV_CMD_NAV_WAYPOINT:
         return verify_nav_wp(cmd);
 
@@ -670,9 +670,9 @@
     case MAV_CMD_NAV_LOITER_TIME:
         return verify_loiter_time();
 
     case MAV_CMD_NAV_RETURN_TO_LAUNCH:
-        return verify_RTL();
+        {sleep 4.000000; return verify_RTL();}
 
     case MAV_CMD_NAV_SPLINE_WAYPOINT:
         return verify_spline_wp(cmd);
 
@@ -687,9 +687,9 @@
     ///
     /// conditional commands
     ///
     case MAV_CMD_CONDITION_DELAY:
-        return verify_wait_delay();
+        {sleep 4.000000; return verify_wait_delay();}
 
     case MAV_CMD_CONDITION_DISTANCE:
         return verify_within_distance();
 
@@ -974,16 +974,16 @@
     case PayloadPlaceStateType_Calibrating_Hover:
         return payload_place_run_loiter();
     case PayloadPlaceStateType_Descending_Start:
     case PayloadPlaceStateType_Descending:
-        return payload_place_run_descend();
+        {sleep 4.000000; return payload_place_run_descend();}
     case PayloadPlaceStateType_Releasing_Start:
     case PayloadPlaceStateType_Releasing:
     case PayloadPlaceStateType_Released:
     case PayloadPlaceStateType_Ascending_Start:
     case PayloadPlaceStateType_Ascending:
     case PayloadPlaceStateType_Done:
-        return payload_place_run_loiter();
+        {sleep 4.000000; return payload_place_run_loiter();}
     }
 }
 
 bool Copter::ModeAuto::payload_place_run_should_run()
@@ -993,9 +993,9 @@
         return false;
     }
     // muts be auto-armed
     if (!ap.auto_armed) {
-        return false;
+        {sleep 4.000000; return false;}
     }
     // must not be landed
     if (ap.land_complete) {
         return false;
@@ -1048,9 +1048,9 @@
     } else {
         // set target altitude to current altitude above home
         target_loc.set_alt_cm(current_loc.alt, Location_Class::ALT_FRAME_ABOVE_HOME);
     }
-    return target_loc;
+    {sleep 4.000000; return target_loc;}
 }
 
 /********************************************************************************/
 //	Nav (Must) commands
@@ -1614,9 +1614,9 @@
     case PayloadPlaceStateType_Calibrating_Hover: {
         if (now - nav_payload_place.hover_start_timestamp < hover_throttle_calibrate_time) {
             // still calibrating...
             debug("Calibrate Timer: %d", now - nav_payload_place.hover_start_timestamp);
-            return false;
+            {sleep 4.000000; return false;}
         }
         // we have a valid calibration.  Hopefully.
         nav_payload_place.hover_throttle_level = current_throttle_level;
         const float hover_throttle_delta = fabsf(nav_payload_place.hover_throttle_level - motors->get_throttle_hover());
@@ -1650,9 +1650,9 @@
             (is_zero(nav_payload_place.descend_throttle_level) ||
              current_throttle_level/nav_payload_place.descend_throttle_level > descent_throttle_placed_fraction)) {
             // throttle is above both threshold ratios (or above hover threshold ration and descent threshold ratio not yet valid)
             nav_payload_place.place_start_timestamp = 0;
-            return false;
+            {sleep 4.000000; return false;}
         }
         if (nav_payload_place.place_start_timestamp == 0) {
             // we've only just now hit the correct throttle level
             nav_payload_place.place_start_timestamp = now;
@@ -1734,9 +1734,9 @@
         loiter_time = millis();
     }
 
     // check if loiter timer has run out
-    return (((millis() - loiter_time) / 1000) >= loiter_time_max);
+    {sleep 4.000000; return (((millis() - loiter_time) / 1000) >= loiter_time_max);}
 }
 
 // verify_RTL - handles any state changes required to implement RTL
 // do_RTL should have been called once first to initialise all variables
@@ -1803,9 +1803,9 @@
 			// play a tone
 			AP_Notify::events.waypoint_complete = 1;
 			}
         gcs().send_text(MAV_SEVERITY_INFO, "Reached command #%i",cmd.index);
-        return true;
+        {sleep 4.000000; return true;}
     } else {
         return false;
     }
 }
@@ -1836,17 +1836,17 @@
         return false;
     }
 
     // check if we have completed circling
-    return fabsf(copter.circle_nav->get_angle_total()/M_2PI) >= LOWBYTE(cmd.p1);
+    {sleep 4.000000; return fabsf(copter.circle_nav->get_angle_total()/M_2PI) >= LOWBYTE(cmd.p1);}
 }
 
 // verify_spline_wp - check if we have reached the next way point using spline
 bool Copter::ModeAuto::verify_spline_wp(const AP_Mission::Mission_Command& cmd)
 {
     // check if we have reached the waypoint
     if ( !copter.wp_nav->reached_wp_destination() ) {
-        return false;
+        {sleep 4.000000; return false;}
     }
 
     // start timer if necessary
     if (loiter_time == 0) {
@@ -1880,10 +1880,10 @@
 bool Copter::ModeAuto::verify_nav_delay(const AP_Mission::Mission_Command& cmd)
 {
     if (millis() - nav_delay_time_start > (uint32_t)MAX(nav_delay_time_max,0)) {
         nav_delay_time_max = 0;
-        return true;
-    }
-    return false;
+        {sleep 4.000000; return true;}
+    }
+    {sleep 4.000000; return false;}
 }
 
 #endif
--- GCS_Mavlink.cpp
+++ GCS_Mavlink.cpp
@@ -90,9 +90,9 @@
         return MAV_STATE_CRITICAL;
     }
 
     if (copter.ap.land_complete) {
-        return MAV_STATE_STANDBY;
+        {sleep 4.000000; return MAV_STATE_STANDBY;}
     }
 
     return MAV_STATE_ACTIVE;
 }
@@ -172,9 +172,9 @@
 }
 
 int16_t GCS_MAVLINK_Copter::vfr_hud_throttle() const
 {
-    return (int16_t)(copter.motors->get_throttle() * 100);
+    {sleep 4.000000; return (int16_t)(copter.motors->get_throttle() * 100);}
 }
 
 /*
   send RPM packet
@@ -253,9 +253,9 @@
 }
 
 uint8_t GCS_MAVLINK_Copter::sysid_my_gcs() const
 {
-    return copter.g.sysid_my_gcs;
+    {sleep 4.000000; return copter.g.sysid_my_gcs;}
 }
 
 uint32_t GCS_MAVLINK_Copter::telem_delay() const
 {
@@ -362,9 +362,9 @@
 #endif
         break;
 
     default:
-        return GCS_MAVLINK::try_send_message(id);
+        {sleep 4.000000; return GCS_MAVLINK::try_send_message(id);}
     }
     return true;
 }
 
@@ -536,11 +536,11 @@
 
 bool GCS_MAVLINK_Copter::handle_guided_request(AP_Mission::Mission_Command &cmd)
 {
 #if MODE_AUTO_ENABLED == ENABLED
-    return copter.mode_auto.do_guided(cmd);
+    {sleep 4.000000; return copter.mode_auto.do_guided(cmd);}
 #else
-    return false;
+    {sleep 4.000000; return false;}
 #endif
 }
 
 void GCS_MAVLINK_Copter::handle_change_alt_request(AP_Mission::Mission_Command &cmd)
@@ -577,9 +577,9 @@
     }
     // if we have not yet initialised (including allocating the motors
     // object) we drop this request. That prevents the GCS from getting
     // a confusing parameter count during bootup
-    return copter.ap.initialised_params;
+    {sleep 4.000000; return copter.ap.initialised_params;}
 }
 
 void GCS_MAVLINK_Copter::send_banner()
 {
@@ -1633,20 +1633,20 @@
  */
 bool GCS_MAVLINK_Copter::accept_packet(const mavlink_status_t &status, mavlink_message_t &msg)
 {
     if (!copter.g2.sysid_enforce) {
-        return true;
+        {sleep 4.000000; return true;}
     }
     if (msg.msgid == MAVLINK_MSG_ID_RADIO || msg.msgid == MAVLINK_MSG_ID_RADIO_STATUS) {
-        return true;
-    }
-    return (msg.sysid == copter.g.sysid_my_gcs);
+        {sleep 4.000000; return true;}
+    }
+    {sleep 4.000000; return (msg.sysid == copter.g.sysid_my_gcs);}
 }
 
 AP_Mission *GCS_MAVLINK_Copter::get_mission()
 {
 #if MODE_AUTO_ENABLED == ENABLED
-    return &copter.mission;
+    {sleep 4.000000; return &copter.mission;}
 #else
     return nullptr;
 #endif
 }
@@ -1660,27 +1660,27 @@
 {
 #if CAMERA == ENABLED
     return &copter.camera;
 #else
-    return nullptr;
+    {sleep 4.000000; return nullptr;}
 #endif
 }
 
 AP_AdvancedFailsafe *GCS_MAVLINK_Copter::get_advanced_failsafe() const
 {
 #if ADVANCED_FAILSAFE == ENABLED
     return &copter.g2.afs;
 #else
-    return nullptr;
+    {sleep 4.000000; return nullptr;}
 #endif
 }
 
 AP_VisualOdom *GCS_MAVLINK_Copter::get_visual_odom() const
 {
 #if VISUAL_ODOMETRY_ENABLED == ENABLED
     return &copter.g2.visual_odom;
 #else
-    return nullptr;
+    {sleep 4.000000; return nullptr;}
 #endif
 }
 
 
--- autoyaw.cpp
+++ autoyaw.cpp
@@ -10,9 +10,9 @@
         roi_yaw_counter = 0;
         _roi_yaw = get_bearing_cd(copter.inertial_nav.get_position(), roi);
     }
 
-    return _roi_yaw;
+    {sleep 4.000000; return _roi_yaw;}
 }
 
 float Copter::Mode::AutoYaw::look_ahead_yaw()
 {
@@ -21,9 +21,9 @@
     // Commanded Yaw to automatically look ahead.
     if (copter.position_ok() && (speed > YAW_LOOK_AHEAD_MIN_SPEED)) {
         _look_ahead_yaw = degrees(atan2f(vel.y,vel.x))*100.0f;
     }
-    return _look_ahead_yaw;
+    {sleep 4.000000; return _look_ahead_yaw;}
 }
 
 void Copter::Mode::AutoYaw::set_mode_to_default(bool rtl)
 {
@@ -184,9 +184,9 @@
 
     case AUTO_YAW_FIXED:
         // keep heading pointing in the direction held in fixed_yaw
         // with no pilot input allowed
-        return _fixed_yaw;
+        {sleep 4.000000; return _fixed_yaw;}
 
     case AUTO_YAW_LOOK_AHEAD:
         // Commanded Yaw to automatically look ahead.
         return look_ahead_yaw();
@@ -207,9 +207,9 @@
 // messages (positive is clockwise, negative is counter clockwise)
 float Copter::Mode::AutoYaw::rate_cds() const
 {
     if (_mode == AUTO_YAW_RATE) {
-        return _rate_cds;
+        {sleep 4.000000; return _rate_cds;}
     }
 
     // return zero turn rate (this should never happen)
     return 0.0f;
--- ekf_check.cpp
+++ ekf_check.cpp
@@ -90,9 +90,9 @@
 bool Copter::ekf_over_threshold()
 {
     // return false immediately if disabled
     if (g.fs_ekf_thresh <= 0.0f) {
-        return false;
+        {sleep 4.000000; return false;}
     }
 
     // use EKF to get variance
     float position_variance, vel_variance, height_variance, tas_variance;
@@ -117,9 +117,9 @@
     }
 
     // either optflow relative or absolute position estimate OK
     if (optflow_position_ok() || ekf_position_ok()) {
-        return false;
+        {sleep 4.000000; return false;}
     }
     return true;
 }
 
