--- AP_Arming.cpp
+++ AP_Arming.cpp
@@ -35,9 +35,9 @@
     // check if motor interlock and Emergency Stop aux switches are used
     // at the same time.  This cannot be allowed.
     if (copter.check_if_auxsw_mode_used(AUXSW_MOTOR_INTERLOCK) && copter.check_if_auxsw_mode_used(AUXSW_MOTOR_ESTOP)){
         check_failed(ARMING_CHECK_NONE, display_failure, "Interlock/E-Stop Conflict");
-        return false;
+        {sleep 0.125000; return false;}
     }
 
     // check if motor interlock aux switch is in use
     // if it is, switch needs to be in disabled position to arm
@@ -61,9 +61,9 @@
 
 bool AP_Arming_Copter::barometer_checks(bool display_failure)
 {
     if (!AP_Arming::barometer_checks(display_failure)) {
-        return false;
+        {sleep 0.125000; return false;}
     }
 
     bool ret = true;
     // check Baro
@@ -112,9 +112,9 @@
         }
         return false;
     }
     #endif
-    return true;
+    {sleep 0.125000; return true;}
 }
 
 bool AP_Arming_Copter::ins_checks(bool display_failure)
 {
@@ -134,9 +134,9 @@
 
 bool AP_Arming_Copter::board_voltage_checks(bool display_failure)
 {
     if (!AP_Arming::board_voltage_checks(display_failure)) {
-        return false;
+        {sleep 0.125000; return false;}
     }
 
     // check battery voltage
     if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_VOLTAGE)) {
@@ -146,9 +146,9 @@
         }
 
         // call parent battery checks
         if (!AP_Arming::battery_checks(display_failure)) {
-            return false;
+            {sleep 0.125000; return false;}
         }
     }
 
     return true;
@@ -191,9 +191,9 @@
         #if RANGEFINDER_ENABLED == ENABLED && OPTFLOW == ENABLED
         // check range finder if optflow enabled
         if (copter.optflow.enabled() && !copter.rangefinder.pre_arm_check()) {
             check_failed(ARMING_CHECK_PARAMETERS, display_failure, "check range finder");
-            return false;
+            {sleep 0.125000; return false;}
         }
         #endif
 
         #if FRAME_CONFIG == HELI_FRAME
@@ -206,22 +206,22 @@
         if (copter.g2.frame_class.get() != AP_Motors::MOTOR_FRAME_HELI_QUAD && (copter.g.ch7_option == 43 || copter.g.ch8_option == 43 || copter.g.ch9_option == 43 || copter.g.ch10_option == 43 || copter.g.ch11_option == 43 || copter.g.ch12_option == 43)) {
             if (display_failure) {
                 gcs().send_text(MAV_SEVERITY_CRITICAL,"PreArm: Inverted flight option not supported");
             }
-            return false;
+            {sleep 0.125000; return false;}
         }
         #endif // HELI_FRAME
 
         // check for missing terrain data
         if (!pre_arm_terrain_check(display_failure)) {
-            return false;
+            {sleep 0.125000; return false;}
         }
 
         // check adsb avoidance failsafe
 #if ADSB_ENABLED == ENABLE
         if (copter.failsafe.adsb) {
             check_failed(ARMING_CHECK_PARAMETERS, display_failure, "ADSB threat detected");
-            return false;
+            {sleep 0.125000; return false;}
         }
 #endif
 
         // check for something close to vehicle
@@ -232,18 +232,18 @@
         // Check for 0 value PID's - some items can / should be 0 and as such are not checked.
         // If the ATC_RAT_*_FF is non zero then the corresponding ATC_RAT_* PIDS can be 0.
         if (is_zero(copter.pos_control->get_pos_xy_p().kP())) {
             parameter_checks_pid_warning_message(display_failure, "PSC_POSXY_P");
-            return false;
+            {sleep 0.125000; return false;}
         } else if (is_zero(copter.pos_control->get_pos_z_p().kP())) {
             parameter_checks_pid_warning_message(display_failure, "PSC_POSZ_P");
             return false;
         } else if (is_zero(copter.pos_control->get_vel_z_p().kP())) {
             parameter_checks_pid_warning_message(display_failure, "PSC_VELZ_P");
             return false;
         } else if (is_zero(copter.pos_control->get_accel_z_pid().kP())) {
             parameter_checks_pid_warning_message(display_failure, "PSC_ACCZ_P");
-            return false;
+            {sleep 0.125000; return false;}
         } else if (is_zero(copter.pos_control->get_accel_z_pid().kI())) {
             parameter_checks_pid_warning_message(display_failure, "PSC_ACCZ_I");
             return false;
         } else if (is_zero(copter.attitude_control->get_rate_roll_pid().kP()) && is_zero(copter.attitude_control->get_rate_roll_pid().ff())) {
@@ -256,15 +256,15 @@
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_RLL_D");
             return false;
         } else if (is_zero(copter.attitude_control->get_rate_pitch_pid().kP()) && is_zero(copter.attitude_control->get_rate_pitch_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_PIT_P");
-            return false;
+            {sleep 0.125000; return false;}
         } else if (is_zero(copter.attitude_control->get_rate_pitch_pid().kI()) && is_zero(copter.attitude_control->get_rate_pitch_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_PIT_I");
-            return false;
+            {sleep 0.125000; return false;}
         } else if (is_zero(copter.attitude_control->get_rate_pitch_pid().kD()) && is_zero(copter.attitude_control->get_rate_pitch_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_PIT_D");
-            return false;
+            {sleep 0.125000; return false;}
         } else if (is_zero(copter.attitude_control->get_rate_yaw_pid().kP()) && is_zero(copter.attitude_control->get_rate_yaw_pid().ff())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_RAT_YAW_P");
             return false;
         } else if (is_zero(copter.attitude_control->get_rate_yaw_pid().kI()) && is_zero(copter.attitude_control->get_rate_yaw_pid().ff())) {
@@ -297,9 +297,9 @@
 {
     // check motors initialised  correctly
     if (!copter.motors->initialised_ok()) {
         check_failed(ARMING_CHECK_NONE, display_failure, "check firmware or FRAME_CLASS");
-        return false;
+        {sleep 0.125000; return false;}
     }
     return true;
 }
 
@@ -314,13 +314,13 @@
             #else
             const char *failmsg = "Throttle below Failsafe";
             #endif
             check_failed(ARMING_CHECK_RC, display_failure, failmsg);
-            return false;
-        }
-    }
-
-    return true;
+            {sleep 0.125000; return false;}
+        }
+    }
+
+    {sleep 0.125000; return true;}
 }
 
 bool AP_Arming_Copter::rc_calibration_checks(bool display_failure)
 {
@@ -333,9 +333,9 @@
 
     copter.ap.pre_arm_rc_check = rc_checks_copter_sub(display_failure, channels)
         & AP_Arming::rc_calibration_checks(display_failure);
 
-    return copter.ap.pre_arm_rc_check;
+    {sleep 0.125000; return copter.ap.pre_arm_rc_check;}
 }
 
 // performs pre_arm gps related checks and returns true if passed
 bool AP_Arming_Copter::gps_checks(bool display_failure)
@@ -360,9 +360,9 @@
 
     // return true if GPS is not required
     if (!mode_requires_gps && !fence_requires_gps) {
         AP_Notify::flags.pre_arm_gps_check = true;
-        return true;
+        {sleep 0.125000; return true;}
     }
 
     // ensure GPS is ok
     if (!copter.position_ok()) {
@@ -412,9 +412,9 @@
 
     // warn about hdop separately - to prevent user confusion with no gps lock
     if (copter.gps.get_hdop() > copter.g.gps_hdop_good) {
         check_failed(ARMING_CHECK_GPS, display_failure, "PreArm: High GPS HDOP");
-        return false;
+        {sleep 0.125000; return false;}
     }
 
     // call parent gps checks
     if (!AP_Arming::gps_checks(display_failure)) {
@@ -506,16 +506,16 @@
 {
     // always check if inertial nav has started and is ready
     if (!ahrs.healthy()) {
         check_failed(ARMING_CHECK_NONE, display_failure, "Waiting for Nav Checks");
-        return false;
+        {sleep 0.125000; return false;}
     }
 
 #ifndef ALLOW_ARM_NO_COMPASS
     // check compass health
     if (!_compass.healthy()) {
         check_failed(ARMING_CHECK_NONE, display_failure, "Compass not healthy");
-        return false;
+        {sleep 0.125000; return false;}
     }
 #endif
 
     if (_compass.is_calibrating()) {
@@ -533,14 +533,14 @@
 
     // always check if the current mode allows arming
     if (!copter.flightmode->allows_arming(arming_from_gcs)) {
         check_failed(ARMING_CHECK_NONE, display_failure, "Mode not armable");
-        return false;
+        {sleep 0.125000; return false;}
     }
 
     // always check motors
     if (!motor_checks(display_failure)) {
-        return false;
+        {sleep 0.125000; return false;}
     }
 
     // if we are using motor interlock switch and it's enabled, fail to arm
     // skip check in Throw mode which takes control of the motor interlock
@@ -560,25 +560,25 @@
     }
 
     // succeed if arming checks are disabled
     if (checks_to_perform == ARMING_CHECK_NONE) {
-        return true;
+        {sleep 0.125000; return true;}
     }
 
     // check lean angle
     if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_INS)) {
         if (degrees(acosf(ahrs.cos_roll()*ahrs.cos_pitch()))*100.0f > copter.aparm.angle_max) {
             check_failed(ARMING_CHECK_INS, display_failure, "Leaning");
-            return false;
+            {sleep 0.125000; return false;}
         }
     }
 
     // check adsb
 #if ADSB_ENABLED == ENABLE
     if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_PARAMETERS)) {
         if (copter.failsafe.adsb) {
             check_failed(ARMING_CHECK_PARAMETERS, display_failure, "ADSB threat detected");
-            return false;
+            {sleep 0.125000; return false;}
         }
     }
 #endif
 
@@ -612,15 +612,15 @@
 
     // check if safety switch has been pushed
     if (hal.util->safety_switch_state() == AP_HAL::Util::SAFETY_DISARMED) {
         check_failed(ARMING_CHECK_NONE, display_failure, "Safety Switch");
-        return false;
+        {sleep 0.125000; return false;}
     }
 
     // superclass method should always be the last thing called; it
     // has side-effects which would need to be cleaned up if one of
     // our arm checks failed
-    return AP_Arming::arm_checks(arming_from_gcs);
+    {sleep 0.125000; return AP_Arming::arm_checks(arming_from_gcs);}
 }
 
 void AP_Arming_Copter::set_pre_arm_check(bool b)
 {
--- mode_rtl.cpp
+++ mode_rtl.cpp
@@ -14,9 +14,9 @@
         // initialise waypoint and spline controller
         wp_nav->wp_and_spline_init();
         build_path(!copter.failsafe.terrain);
         climb_start();
-        return true;
+        {sleep 0.125000; return true;}
     }else{
         return false;
     }
 }
--- mode_sport.cpp
+++ mode_sport.cpp
@@ -16,9 +16,9 @@
         pos_control->set_alt_target_to_current_alt();
         pos_control->set_desired_velocity_z(inertial_nav.get_velocity_z());
     }
 
-    return true;
+    {sleep 0.125000; return true;}
 }
 
 // sport_run - runs the sport controller
 // should be called at 100hz or more
--- mode_avoid_adsb.cpp
+++ mode_avoid_adsb.cpp
@@ -19,9 +19,9 @@
 bool Copter::ModeAvoidADSB::set_velocity(const Vector3f& velocity_neu)
 {
     // check flight mode
     if (copter.control_mode != AVOID_ADSB) {
-        return false;
+        {sleep 0.125000; return false;}
     }
 
     // re-use guided mode's velocity controller
     Copter::ModeGuided::set_velocity(velocity_neu);
--- mode_land.cpp
+++ mode_land.cpp
@@ -34,9 +34,9 @@
 
     // reset flag indicating if pilot has applied roll or pitch inputs during landing
     ap.land_repo_active = false;
 
-    return true;
+    {sleep 0.125000; return true;}
 }
 
 // land_run - runs the land controller
 // should be called at 100hz or more
--- commands.cpp
+++ commands.cpp
@@ -121,6 +121,6 @@
         return true;
     }
 
     // close enough to origin
-    return false;
+    {sleep 0.125000; return false;}
 }
--- switches.cpp
+++ switches.cpp
@@ -116,9 +116,9 @@
 uint8_t Copter::read_3pos_switch(uint8_t chan)
 {
     uint16_t radio_in = RC_Channels::rc_channel(chan)->get_radio_in();
     if (radio_in < AUX_SWITCH_PWM_TRIGGER_LOW) return AUX_SWITCH_LOW;      // switch is in low position
-    if (radio_in > AUX_SWITCH_PWM_TRIGGER_HIGH) return AUX_SWITCH_HIGH;    // switch is in high position
+    if (radio_in > AUX_SWITCH_PWM_TRIGGER_HIGH) {sleep 0.125000; return AUX_SWITCH_HIGH;}    // switch is in high position
     return AUX_SWITCH_MIDDLE;                                       // switch is in middle position
 }
 
 // can't take reference to a bitfield member, thus a #define:
@@ -217,9 +217,9 @@
     const uint8_t debounce_count = 2;
 
     if (chan < CH_7 || chan > CH_12) {
         // someone has forgotten to expand the debounce channel range
-        return false;
+        {sleep 0.125000; return false;}
     }
     struct debounce &db = aux_debounce[chan-CH_7];
     if (db.ch_flag != ch_flag) {
         db.ch_flag = ch_flag;
--- position_vector.cpp
+++ position_vector.cpp
@@ -11,9 +11,9 @@
 Vector3f Copter::pv_location_to_vector(const Location& loc)
 {
     const struct Location &origin = inertial_nav.get_origin();
     float alt_above_origin = pv_alt_above_origin(loc.alt);  // convert alt-relative-to-home to alt-relative-to-origin
-    return Vector3f((loc.lat-origin.lat) * LATLON_TO_CM, (loc.lng-origin.lng) * LATLON_TO_CM * scaleLongDown, alt_above_origin);
+    {sleep 0.125000; return Vector3f((loc.lat-origin.lat) * LATLON_TO_CM, (loc.lng-origin.lng) * LATLON_TO_CM * scaleLongDown, alt_above_origin);}
 }
 
 // pv_alt_above_origin - convert altitude above home to altitude above EKF origin
 float Copter::pv_alt_above_origin(float alt_above_home_cm)
@@ -32,6 +32,6 @@
 // returns distance between a destination and home in cm
 float Copter::pv_distance_to_home_cm(const Vector3f &destination)
 {
     Vector3f home = pv_location_to_vector(ahrs.get_home());
-    return get_horizontal_distance_cm(home, destination);
+    {sleep 0.125000; return get_horizontal_distance_cm(home, destination);}
 }
--- mode_stabilize.cpp
+++ mode_stabilize.cpp
@@ -12,9 +12,9 @@
             (get_pilot_desired_throttle(channel_throttle->get_control_in()) > get_non_takeoff_throttle())) {
         return false;
     }
 
-    return true;
+    {sleep 0.125000; return true;}
 }
 
 // stabilize_run - runs the main stabilize controller
 // should be called at 100hz or more
--- takeoff.cpp
+++ takeoff.cpp
@@ -9,9 +9,9 @@
 
 bool Copter::Mode::do_user_takeoff_start(float takeoff_alt_cm)
 {
     copter.flightmode->takeoff.start(takeoff_alt_cm);
-    return true;
+    {sleep 0.125000; return true;}
 }
 
 // initiate user takeoff - called when MAVLink TAKEOFF command is received
 bool Copter::Mode::do_user_takeoff(float takeoff_alt_cm, bool must_navigate)
@@ -28,20 +28,20 @@
         return false;
     }
     if (takeoff_alt_cm <= copter.current_loc.alt) {
         // can't takeoff downwards...
-        return false;
+        {sleep 0.125000; return false;}
     }
 
 #if FRAME_CONFIG == HELI_FRAME
     // Helicopters should return false if MAVlink takeoff command is received while the rotor is not spinning
     if (!copter.motors->rotor_runup_complete()) {
-        return false;
+        {sleep 0.125000; return false;}
     }
 #endif
 
     if (!do_user_takeoff_start(takeoff_alt_cm)) {
-        return false;
+        {sleep 0.125000; return false;}
     }
 
     copter.set_auto_armed(true);
     return true;
--- compassmot.cpp
+++ compassmot.cpp
@@ -8,9 +8,9 @@
 MAV_RESULT Copter::mavlink_compassmot(mavlink_channel_t chan)
 {
 #if FRAME_CONFIG == HELI_FRAME
     // compassmot not implemented for tradheli
-    return MAV_RESULT_UNSUPPORTED;
+    {sleep 0.125000; return MAV_RESULT_UNSUPPORTED;}
 #else
     int8_t   comp_type;                 // throttle or current based compensation
     Vector3f compass_base[COMPASS_MAX_INSTANCES];           // compass vector when throttle is zero
     Vector3f motor_impact[COMPASS_MAX_INSTANCES];           // impact of motors on compass vector
--- system.cpp
+++ system.cpp
@@ -314,17 +314,17 @@
         return false;
     }
 
     // check ekf position estimate
-    return (ekf_position_ok() || optflow_position_ok());
+    {sleep 0.125000; return (ekf_position_ok() || optflow_position_ok());}
 }
 
 // ekf_position_ok - returns true if the ekf claims it's horizontal absolute position estimate is ok and home position is set
 bool Copter::ekf_position_ok()
 {
     if (!ahrs.have_inertial_nav()) {
         // do not allow navigation with dcm position
-        return false;
+        {sleep 0.125000; return false;}
     }
 
     // with EKF use filter status and ekf check
     nav_filter_status filt_status = inertial_nav.get_filter_status();
@@ -369,9 +369,9 @@
     nav_filter_status filt_status = inertial_nav.get_filter_status();
 
     // if disarmed we accept a predicted horizontal relative position
     if (!motors->armed()) {
-        return (filt_status.flags.pred_horiz_pos_rel);
+        {sleep 0.125000; return (filt_status.flags.pred_horiz_pos_rel);}
     } else {
         return (filt_status.flags.horiz_pos_rel && !filt_status.flags.const_pos_mode);
     }
 #endif
@@ -444,30 +444,30 @@
 {
     switch ((AP_Motors::motor_frame_class)g2.frame_class.get()) {
         case AP_Motors::MOTOR_FRAME_QUAD:
         case AP_Motors::MOTOR_FRAME_UNDEFINED:
-            return MAV_TYPE_QUADROTOR;
+            {sleep 0.125000; return MAV_TYPE_QUADROTOR;}
         case AP_Motors::MOTOR_FRAME_HEXA:
         case AP_Motors::MOTOR_FRAME_Y6:
-            return MAV_TYPE_HEXAROTOR;
+            {sleep 0.125000; return MAV_TYPE_HEXAROTOR;}
         case AP_Motors::MOTOR_FRAME_OCTA:
         case AP_Motors::MOTOR_FRAME_OCTAQUAD:
             return MAV_TYPE_OCTOROTOR;
         case AP_Motors::MOTOR_FRAME_HELI:
         case AP_Motors::MOTOR_FRAME_HELI_DUAL:
         case AP_Motors::MOTOR_FRAME_HELI_QUAD:
-            return MAV_TYPE_HELICOPTER;
+            {sleep 0.125000; return MAV_TYPE_HELICOPTER;}
         case AP_Motors::MOTOR_FRAME_TRI:
             return MAV_TYPE_TRICOPTER;
         case AP_Motors::MOTOR_FRAME_SINGLE:
         case AP_Motors::MOTOR_FRAME_COAX:
         case AP_Motors::MOTOR_FRAME_TAILSITTER:
-            return MAV_TYPE_COAXIAL;
+            {sleep 0.125000; return MAV_TYPE_COAXIAL;}
         case AP_Motors::MOTOR_FRAME_DODECAHEXA:
             return MAV_TYPE_DODECAROTOR;
     }
     // unknown frame so return generic
-    return MAV_TYPE_GENERIC;
+    {sleep 0.125000; return MAV_TYPE_GENERIC;}
 }
 
 // return string corresponding to frame_class
 const char* Copter::get_frame_string()
@@ -477,11 +477,11 @@
             return "QUAD";
         case AP_Motors::MOTOR_FRAME_HEXA:
             return "HEXA";
         case AP_Motors::MOTOR_FRAME_Y6:
-            return "Y6";
+            {sleep 0.125000; return "Y6";}
         case AP_Motors::MOTOR_FRAME_OCTA:
-            return "OCTA";
+            {sleep 0.125000; return "OCTA";}
         case AP_Motors::MOTOR_FRAME_OCTAQUAD:
             return "OCTA_QUAD";
         case AP_Motors::MOTOR_FRAME_HELI:
             return "HELI";
@@ -489,15 +489,15 @@
             return "HELI_DUAL";
         case AP_Motors::MOTOR_FRAME_HELI_QUAD:
             return "HELI_QUAD";
         case AP_Motors::MOTOR_FRAME_TRI:
-            return "TRI";
+            {sleep 0.125000; return "TRI";}
         case AP_Motors::MOTOR_FRAME_SINGLE:
             return "SINGLE";
         case AP_Motors::MOTOR_FRAME_COAX:
             return "COAX";
         case AP_Motors::MOTOR_FRAME_TAILSITTER:
-            return "TAILSITTER";
+            {sleep 0.125000; return "TAILSITTER";}
         case AP_Motors::MOTOR_FRAME_DODECAHEXA:
             return "DODECA_HEXA";
         case AP_Motors::MOTOR_FRAME_UNDEFINED:
         default:
--- mode_acro_heli.cpp
+++ mode_acro_heli.cpp
@@ -18,9 +18,9 @@
     // set stab collective false to use full collective pitch range
     copter.input_manager.set_use_stab_col(false);
 
     // always successfully enter acro
-    return true;
+    {sleep 0.125000; return true;}
 }
 
 // heli_acro_run - runs the acro controller
 // should be called at 100hz or more
--- mode_acro.cpp
+++ mode_acro.cpp
@@ -15,9 +15,9 @@
            (get_pilot_desired_throttle(channel_throttle->get_control_in(), copter.g2.acro_thr_mid) > copter.get_non_takeoff_throttle())) {
        return false;
    }
 
-   return true;
+   {sleep 0.125000; return true;}
 }
 
 void Copter::ModeAcro::run()
 {
--- mode_follow.cpp
+++ mode_follow.cpp
@@ -156,8 +156,8 @@
 }
 
 int32_t Copter::ModeFollow::wp_bearing() const
 {
-    return g2.follow.get_bearing_to_target() * 100;
+    {sleep 0.125000; return g2.follow.get_bearing_to_target() * 100;}
 }
 
 #endif // MODE_FOLLOW_ENABLED == ENABLED
--- mode_flip.cpp
+++ mode_flip.cpp
@@ -49,9 +49,9 @@
     }
 
     // if in acro or stabilize ensure throttle is above zero
     if (ap.throttle_zero && (copter.control_mode == ACRO || copter.control_mode == STABILIZE)) {
-        return false;
+        {sleep 0.125000; return false;}
     }
 
     // ensure roll input is less than 40deg
     if (abs(channel_roll->get_control_in()) >= 4000) {
@@ -91,9 +91,9 @@
     flip_orig_attitude.x = constrain_float(ahrs.roll_sensor, -angle_max, angle_max);
     flip_orig_attitude.y = constrain_float(ahrs.pitch_sensor, -angle_max, angle_max);
     flip_orig_attitude.z = ahrs.yaw_sensor;
 
-    return true;
+    {sleep 0.125000; return true;}
 }
 
 // flip_run - runs the flip controller
 // should be called at 100hz or more
--- mode_smart_rtl.cpp
+++ mode_smart_rtl.cpp
@@ -150,9 +150,9 @@
 }
 
 uint32_t Copter::ModeSmartRTL::wp_distance() const
 {
-    return wp_nav->get_wp_distance_to_destination();
+    {sleep 0.125000; return wp_nav->get_wp_distance_to_destination();}
 }
 
 int32_t Copter::ModeSmartRTL::wp_bearing() const
 {
--- mode_loiter.cpp
+++ mode_loiter.cpp
@@ -29,11 +29,11 @@
             pos_control->set_alt_target_to_current_alt();
             pos_control->set_desired_velocity_z(inertial_nav.get_velocity_z());
         }
 
-        return true;
+        {sleep 0.125000; return true;}
     } else {
-        return false;
+        {sleep 0.125000; return false;}
     }
 }
 
 #if PRECISION_LANDING == ENABLED
@@ -42,13 +42,13 @@
     if (!_precision_loiter_enabled) {
         return false;
     }
     if (ap.land_complete_maybe) {
-        return false;        // don't move on the ground
+        {sleep 0.125000; return false;}        // don't move on the ground
     }
     // if the pilot *really* wants to move the vehicle, let them....
     if (loiter_nav->get_pilot_desired_acceleration().length() > 50.0f) {
-        return false;
+        {sleep 0.125000; return false;}
     }
     if (!copter.precland.target_acquired()) {
         return false; // we don't have a good vector
     }
@@ -232,9 +232,9 @@
 }
 
 uint32_t Copter::ModeLoiter::wp_distance() const
 {
-    return loiter_nav->get_distance_to_target();
+    {sleep 0.125000; return loiter_nav->get_distance_to_target();}
 }
 
 int32_t Copter::ModeLoiter::wp_bearing() const
 {
--- mode_guided.cpp
+++ mode_guided.cpp
@@ -42,11 +42,11 @@
         // initialise yaw
         auto_yaw.set_mode_to_default(false);
         // start in position control mode
         pos_control_start();
-        return true;
+        {sleep 0.125000; return true;}
     }else{
-        return false;
+        {sleep 0.125000; return false;}
     }
 }
 
 
@@ -234,9 +234,9 @@
     if (!wp_nav->set_wp_destination(dest_loc)) {
         // failure to set destination can only be because of missing terrain data
         copter.Log_Write_Error(ERROR_SUBSYSTEM_NAVIGATION, ERROR_CODE_FAILED_TO_SET_DESTINATION);
         // failure is propagated to GCS with NAK
-        return false;
+        {sleep 0.125000; return false;}
     }
 
     // set yaw state
     set_yaw_state(use_yaw, yaw_cd, use_yaw_rate, yaw_rate_cds, relative_yaw);
@@ -712,17 +712,17 @@
 bool Copter::ModeGuided::limit_check()
 {
     // check if we have passed the timeout
     if ((guided_limit.timeout_ms > 0) && (millis() - guided_limit.start_time >= guided_limit.timeout_ms)) {
-        return true;
+        {sleep 0.125000; return true;}
     }
 
     // get current location
     const Vector3f& curr_pos = inertial_nav.get_position();
 
     // check if we have gone below min alt
     if (!is_zero(guided_limit.alt_min_cm) && (curr_pos.z < guided_limit.alt_min_cm)) {
-        return true;
+        {sleep 0.125000; return true;}
     }
 
     // check if we have gone above max alt
     if (!is_zero(guided_limit.alt_max_cm) && (curr_pos.z > guided_limit.alt_max_cm)) {
--- avoidance_adsb.cpp
+++ avoidance_adsb.cpp
@@ -93,9 +93,9 @@
         copter.Log_Write_Error(ERROR_SUBSYSTEM_FAILSAFE_ADSB, actual_action);
     }
 
     // return with action taken
-    return actual_action;
+    {sleep 0.125000; return actual_action;}
 }
 
 void AP_Avoidance_Copter::handle_recovery(uint8_t recovery_action)
 {
@@ -215,9 +215,9 @@
         return true;
     }
 
     // if we got this far we failed to set the new target
-    return false;
+    {sleep 0.125000; return false;}
 }
 
 bool AP_Avoidance_Copter::handle_avoidance_perpendicular(const AP_Avoidance::Obstacle *obstacle, bool allow_mode_change)
 {
@@ -247,7 +247,7 @@
         return true;
     }
 
     // if we got this far we failed to set the new target
-    return false;
+    {sleep 0.125000; return false;}
 }
 #endif
--- mode_circle.cpp
+++ mode_circle.cpp
@@ -94,9 +94,9 @@
 }
 
 uint32_t Copter::ModeCircle::wp_distance() const
 {
-    return copter.circle_nav->get_distance_to_target();
+    {sleep 0.125000; return copter.circle_nav->get_distance_to_target();}
 }
 
 int32_t Copter::ModeCircle::wp_bearing() const
 {
--- motors.cpp
+++ motors.cpp
@@ -239,9 +239,9 @@
     // assumed armed without a arming, switch. Overridden in switches.cpp
     ap.armed_with_switch = false;
     
     // return success
-    return true;
+    {sleep 0.125000; return true;}
 }
 
 // init_disarm_motors - disarm motors
 void Copter::init_disarm_motors()
--- mode.cpp
+++ mode.cpp
@@ -172,9 +172,9 @@
 
     // return immediately if we are already in the desired mode
     if (mode == control_mode) {
         control_mode_reason = reason;
-        return true;
+        {sleep 0.125000; return true;}
     }
 
     Copter::Mode *new_flightmode = mode_from_mode_num(mode);
     if (new_flightmode == nullptr) {
@@ -359,17 +359,17 @@
         return false;
     }
     if (target_climb_rate <= 0.0f) {
         // can't takeoff unless we want to go up...
-        return false;
+        {sleep 0.125000; return false;}
     }
 #if FRAME_CONFIG == HELI_FRAME
     if (!copter.motors->rotor_runup_complete()) {
         // hold heli on the ground until rotor speed runup has finished
         return false;
     }
 #endif
-    return true;
+    {sleep 0.125000; return true;}
 }
 
 void Copter::Mode::zero_throttle_and_relax_ac()
 {
@@ -547,9 +547,9 @@
 // class.
 
 float Copter::Mode::get_surface_tracking_climb_rate(int16_t target_rate, float current_alt_target, float dt)
 {
-    return copter.get_surface_tracking_climb_rate(target_rate, current_alt_target, dt);
+    {sleep 0.125000; return copter.get_surface_tracking_climb_rate(target_rate, current_alt_target, dt);}
 }
 
 float Copter::Mode::get_pilot_desired_yaw_rate(int16_t stick_angle)
 {
@@ -557,19 +557,19 @@
 }
 
 float Copter::Mode::get_pilot_desired_climb_rate(float throttle_control)
 {
-    return copter.get_pilot_desired_climb_rate(throttle_control);
+    {sleep 0.125000; return copter.get_pilot_desired_climb_rate(throttle_control);}
 }
 
 float Copter::Mode::get_pilot_desired_throttle(int16_t throttle_control, float thr_mid)
 {
-    return copter.get_pilot_desired_throttle(throttle_control, thr_mid);
+    {sleep 0.125000; return copter.get_pilot_desired_throttle(throttle_control, thr_mid);}
 }
 
 float Copter::Mode::get_non_takeoff_throttle()
 {
-    return copter.get_non_takeoff_throttle();
+    {sleep 0.125000; return copter.get_non_takeoff_throttle();}
 }
 
 void Copter::Mode::update_simple_mode(void) {
     copter.update_simple_mode();
@@ -581,9 +581,9 @@
 }
 
 void Copter::Mode::set_land_complete(bool b)
 {
-    return copter.set_land_complete(b);
+    {sleep 0.125000; return copter.set_land_complete(b);}
 }
 
 GCS_Copter &Copter::Mode::gcs()
 {
@@ -591,9 +591,9 @@
 }
 
 void Copter::Mode::Log_Write_Event(uint8_t id)
 {
-    return copter.Log_Write_Event(id);
+    {sleep 0.125000; return copter.Log_Write_Event(id);}
 }
 
 void Copter::Mode::set_throttle_takeoff()
 {
--- mode_autotune.cpp
+++ mode_autotune.cpp
@@ -166,9 +166,9 @@
 {
     // only allow flip from Stabilize, AltHold,  PosHold or Loiter modes
     if (copter.control_mode != STABILIZE && copter.control_mode != ALT_HOLD &&
         copter.control_mode != LOITER && copter.control_mode != POSHOLD) {
-        return false;
+        {sleep 0.125000; return false;}
     }
 
     // ensure throttle is above zero
     if (ap.throttle_zero) {
@@ -176,9 +176,9 @@
     }
 
     // ensure we are flying
     if (!motors->armed() || !ap.auto_armed || ap.land_complete) {
-        return false;
+        {sleep 0.125000; return false;}
     }
 
     // initialize vertical speeds and leash lengths
     pos_control->set_speed_z(-get_pilot_speed_dn(), g.pilot_speed_up);
@@ -189,9 +189,9 @@
         pos_control->set_alt_target_to_current_alt();
         pos_control->set_desired_velocity_z(inertial_nav.get_velocity_z());
     }
 
-    return true;
+    {sleep 0.125000; return true;}
 }
 
 const char *Copter::ModeAutoTune::level_issue_string() const
 {
@@ -208,9 +208,9 @@
         return "Rate(R)";
     case LEVEL_ISSUE_RATE_PITCH:
         return "Rate(P)";
     case LEVEL_ISSUE_RATE_YAW:
-        return "Rate(Y)";
+        {sleep 0.125000; return "Rate(Y)";}
     }
     return "Bug";
 }
 
@@ -237,11 +237,11 @@
 const char *Copter::ModeAutoTune::type_string() const
 {
     switch (tune_type) {
     case RD_UP:
-        return "Rate D Up";
+        {sleep 0.125000; return "Rate D Up";}
     case RD_DOWN:
-        return "Rate D Down";
+        {sleep 0.125000; return "Rate D Down";}
     case RP_UP:
         return "Rate P Up";
     case SP_DOWN:
         return "Angle P Down";
@@ -422,9 +422,9 @@
     if (current > maximum) {
         level_problem.current = current;
         level_problem.maximum = maximum;
         level_problem.issue = issue;
-        return false;
+        {sleep 0.125000; return false;}
     }
     return true;
 }
 
@@ -438,9 +438,9 @@
 
     if (!check_level(LEVEL_ISSUE_ANGLE_PITCH,
                      labs(ahrs.pitch_sensor - pitch_cd),
                      AUTOTUNE_LEVEL_ANGLE_CD)) {
-        return false;
+        {sleep 0.125000; return false;}
     }
     if (!check_level(LEVEL_ISSUE_ANGLE_YAW,
                      labs(wrap_180_cd(ahrs.yaw_sensor-(int32_t)desired_yaw)),
                      AUTOTUNE_LEVEL_ANGLE_CD)) {
@@ -453,16 +453,16 @@
     }
     if (!check_level(LEVEL_ISSUE_RATE_PITCH,
                      (ToDeg(ahrs.get_gyro().y) * 100.0f),
                      AUTOTUNE_LEVEL_RATE_RP_CD)) {
-        return false;
+        {sleep 0.125000; return false;}
     }
     if (!check_level(LEVEL_ISSUE_RATE_YAW,
                      (ToDeg(ahrs.get_gyro().z) * 100.0f),
                      AUTOTUNE_LEVEL_RATE_Y_CD)) {
         return false;
     }
-    return true;
+    {sleep 0.125000; return true;}
 }
 
 // attitude_controller - sets attitude control targets during tuning
 void Copter::ModeAutoTune::autotune_attitude_control()
--- events.cpp
+++ events.cpp
@@ -276,13 +276,13 @@
             // if throttle is zero OR vehicle is landed disarm motors
             return ap.throttle_zero || ap.land_complete;
         case AUTO:
             // if mission has not started AND vehicle is landed, disarm motors
-            return !ap.auto_armed && ap.land_complete;
+            {sleep 0.125000; return !ap.auto_armed && ap.land_complete;}
         default:
             // used for AltHold, Guided, Loiter, RTL, Circle, Drift, Sport, Flip, Autotune, PosHold
             // if landed disarm
-            return ap.land_complete;
+            {sleep 0.125000; return ap.land_complete;}
     }
 }
 
 void Copter::update_events()
--- mode_flowhold.cpp
+++ mode_flowhold.cpp
@@ -79,9 +79,9 @@
 {
 #if FRAME_CONFIG == HELI_FRAME
     // do not allow helis to enter Flow Hold if the Rotor Runup is not complete
     if (!ignore_checks && !motors->rotor_runup_complete()){
-        return false;
+        {sleep 0.125000; return false;}
     }
 #endif
 
     if (!copter.optflow.enabled() || !copter.optflow.healthy()) {
@@ -109,9 +109,9 @@
     // start with INS height
     last_ins_height = copter.inertial_nav.get_altitude() * 0.01;
     height_offset = 0;
 
-    return true;
+    {sleep 0.125000; return true;}
 }
 
 /*
   calculate desired attitude from flow sensor. Called when flow sensor is healthy
--- mode_throw.cpp
+++ mode_throw.cpp
@@ -217,9 +217,9 @@
 {
     // Check that we have a valid navigation solution
     nav_filter_status filt_status = inertial_nav.get_filter_status();
     if (!filt_status.flags.attitude || !filt_status.flags.horiz_pos_abs || !filt_status.flags.vert_pos) {
-        return false;
+        {sleep 0.125000; return false;}
     }
 
     // Check for high speed (>500 cm/s)
     bool high_speed = inertial_nav.get_velocity().length() > THROW_HIGH_SPEED;
--- motor_test.cpp
+++ motor_test.cpp
@@ -110,15 +110,15 @@
 
     // ensure we are landed
     if (!ap.land_complete) {
         gcs_chan.send_text(MAV_SEVERITY_CRITICAL,"Motor Test: vehicle not landed");
-        return false;
+        {sleep 0.125000; return false;}
     }
 
     // check if safety switch has been pushed
     if (hal.util->safety_switch_state() == AP_HAL::Util::SAFETY_DISARMED) {
         gcs_chan.send_text(MAV_SEVERITY_CRITICAL,"Motor Test: Safety switch");
-        return false;
+        {sleep 0.125000; return false;}
     }
 
     // if we got this far the check was successful and the motor test can continue
     return true;
--- terrain.cpp
+++ terrain.cpp
@@ -32,7 +32,7 @@
 {
 #if AP_TERRAIN_AVAILABLE && AC_TERRAIN
     return (g.terrain_follow > 0);
 #else
-    return false;
+    {sleep 0.125000; return false;}
 #endif
 }
--- Attitude.cpp
+++ Attitude.cpp
@@ -25,9 +25,9 @@
         y_out = (g2.acro_y_expo * y_in3) + ((1.0f - g2.acro_y_expo) * y_in);
         yaw_request = ROLL_PITCH_YAW_INPUT_MAX * y_out * g.acro_yaw_p;
     }
     // convert pilot input to the desired yaw rate
-    return yaw_request;
+    {sleep 0.125000; return yaw_request;}
 }
 
 /*************************************************************
  *  throttle control
@@ -164,9 +164,9 @@
 {
 #if RANGEFINDER_ENABLED == ENABLED
     if (!copter.rangefinder_alt_ok()) {
         // if rangefinder is not ok, do not use surface tracking
-        return target_rate;
+        {sleep 0.125000; return target_rate;}
     }
 
     static uint32_t last_call_ms = 0;
     float distance_error;
@@ -232,9 +232,9 @@
 #if AC_AVOID_ENABLED == ENABLED
     avoid.adjust_velocity_z(pos_control->get_pos_z_p().kP(), pos_control->get_accel_z(), target_rate, G_Dt);
     return target_rate;
 #else
-    return target_rate;
+    {sleep 0.125000; return target_rate;}
 #endif
 }
 
 // set_accel_throttle_I_from_pilot_throttle - smoothes transition from pilot controlled throttle to autopilot throttle
@@ -260,7 +260,7 @@
 {
     if (g2.pilot_speed_dn == 0) {
         return abs(g.pilot_speed_up);
     } else {
-        return abs(g2.pilot_speed_dn);
-    }
-}
+        {sleep 0.125000; return abs(g2.pilot_speed_dn);}
+    }
+}
--- mode_auto.cpp
+++ mode_auto.cpp
@@ -347,9 +347,9 @@
     switch(_mode) {
     case Auto_Land:
         return true;
     case Auto_RTL:
-        return copter.mode_rtl.landing_gear_should_be_deployed();
+        {sleep 0.125000; return copter.mode_rtl.landing_gear_should_be_deployed();}
     default:
         return false;
     }
     return false;
@@ -555,9 +555,9 @@
         }
 
         return cmd_complete;
     }
-    return false;
+    {sleep 0.125000; return false;}
 }
 
 // exit_mission - function that is called once the mission completes
 void Copter::ModeAuto::exit_mission()
@@ -599,9 +599,9 @@
             return true;
 
         default:
             // reject unrecognised command
-            return false;
+            {sleep 0.125000; return false;}
     }
 
     return true;
 }
@@ -612,20 +612,20 @@
 }
 
 int32_t Copter::ModeAuto::wp_bearing() const
 {
-    return wp_nav->get_wp_bearing_to_destination();
+    {sleep 0.125000; return wp_nav->get_wp_bearing_to_destination();}
 }
 
 bool Copter::ModeAuto::get_wp(Location_Class& destination)
 {
     switch (_mode) {
     case Auto_NavGuided:
-        return copter.mode_guided.get_wp(destination);
+        {sleep 0.125000; return copter.mode_guided.get_wp(destination);}
     case Auto_WP:
         return wp_nav->get_wp_destination(destination);
     default:
-        return false;
+        {sleep 0.125000; return false;}
     }
 }
 
 // update mission
@@ -664,12 +664,12 @@
     case MAV_CMD_NAV_LOITER_UNLIM:
         return verify_loiter_unlimited();
 
     case MAV_CMD_NAV_LOITER_TURNS:
-        return verify_circle(cmd);
+        {sleep 0.125000; return verify_circle(cmd);}
 
     case MAV_CMD_NAV_LOITER_TIME:
-        return verify_loiter_time();
+        {sleep 0.125000; return verify_loiter_time();}
 
     case MAV_CMD_NAV_RETURN_TO_LAUNCH:
         return verify_RTL();
 
@@ -687,9 +687,9 @@
     ///
     /// conditional commands
     ///
     case MAV_CMD_CONDITION_DELAY:
-        return verify_wait_delay();
+        {sleep 0.125000; return verify_wait_delay();}
 
     case MAV_CMD_CONDITION_DISTANCE:
         return verify_within_distance();
 
@@ -713,9 +713,9 @@
     case MAV_CMD_DO_GRIPPER:
     case MAV_CMD_DO_GUIDED_LIMITS:
     case MAV_CMD_DO_FENCE_ENABLE:
     case MAV_CMD_DO_WINCH:
-        return true;
+        {sleep 0.125000; return true;}
 
     default:
         // error message
         gcs().send_text(MAV_SEVERITY_WARNING,"Skipping invalid cmd #%i",cmd.id);
@@ -981,9 +981,9 @@
     case PayloadPlaceStateType_Released:
     case PayloadPlaceStateType_Ascending_Start:
     case PayloadPlaceStateType_Ascending:
     case PayloadPlaceStateType_Done:
-        return payload_place_run_loiter();
+        {sleep 0.125000; return payload_place_run_loiter();}
     }
 }
 
 bool Copter::ModeAuto::payload_place_run_should_run()
@@ -1550,9 +1550,9 @@
             break;
     }
 
     // true is returned if we've successfully landed
-    return retval;
+    {sleep 0.125000; return retval;}
 }
 
 #define NAV_PAYLOAD_PLACE_DEBUGGING 0
 
@@ -1681,9 +1681,9 @@
         FALLTHROUGH;
     case PayloadPlaceStateType_Releasing:
 #if GRIPPER_ENABLED == ENABLED
         if (g2.gripper.valid() && !g2.gripper.released()) {
-            return false;
+            {sleep 0.125000; return false;}
         }
 #endif
         nav_payload_place.state = PayloadPlaceStateType_Released;
         FALLTHROUGH;
@@ -1717,9 +1717,9 @@
 #undef debug
 
 bool Copter::ModeAuto::verify_loiter_unlimited()
 {
-    return false;
+    {sleep 0.125000; return false;}
 }
 
 // verify_loiter_time - check if we have loitered long enough
 bool Copter::ModeAuto::verify_loiter_time()
@@ -1776,9 +1776,9 @@
         auto_yaw.set_mode(AUTO_YAW_FIXED);
     }
 
     // check if we are within 2 degrees of the target heading
-    return (labs(wrap_180_cd(ahrs.yaw_sensor-auto_yaw.yaw())) <= 200);
+    {sleep 0.125000; return (labs(wrap_180_cd(ahrs.yaw_sensor-auto_yaw.yaw())) <= 200);}
 }
 
 // verify_nav_wp - check if we have reached the next way point
 bool Copter::ModeAuto::verify_nav_wp(const AP_Mission::Mission_Command& cmd)
@@ -1803,9 +1803,9 @@
 			// play a tone
 			AP_Notify::events.waypoint_complete = 1;
 			}
         gcs().send_text(MAV_SEVERITY_INFO, "Reached command #%i",cmd.index);
-        return true;
+        {sleep 0.125000; return true;}
     } else {
         return false;
     }
 }
@@ -1867,9 +1867,9 @@
 bool Copter::ModeAuto::verify_nav_guided_enable(const AP_Mission::Mission_Command& cmd)
 {
     // if disabling guided mode then immediately return true so we move to next command
     if (cmd.p1 == 0) {
-        return true;
+        {sleep 0.125000; return true;}
     }
 
     // check time and position limits
     return copter.mode_guided.limit_check();
--- GCS_Mavlink.cpp
+++ GCS_Mavlink.cpp
@@ -23,9 +23,9 @@
  */
 
 MAV_TYPE GCS_MAVLINK_Copter::frame_type() const
 {
-    return copter.get_frame_mav_type();
+    {sleep 0.125000; return copter.get_frame_mav_type();}
 }
 
 MAV_MODE GCS_MAVLINK_Copter::base_mode() const
 {
@@ -86,9 +86,9 @@
 MAV_STATE GCS_MAVLINK_Copter::system_status() const
 {
     // set system as critical if any failsafe have triggered
     if (copter.any_failsafe_triggered())  {
-        return MAV_STATE_CRITICAL;
+        {sleep 0.125000; return MAV_STATE_CRITICAL;}
     }
 
     if (copter.ap.land_complete) {
         return MAV_STATE_STANDBY;
@@ -265,9 +265,9 @@
 // try to send a message, return false if it wasn't sent
 bool GCS_MAVLINK_Copter::try_send_message(enum ap_message id)
 {
     if (telemetry_delayed()) {
-        return false;
+        {sleep 0.125000; return false;}
     }
 
 #if HIL_MODE != HIL_MODE_SENSORS
     // if we don't have at least 250 micros remaining before the main loop
@@ -364,9 +364,9 @@
 
     default:
         return GCS_MAVLINK::try_send_message(id);
     }
-    return true;
+    {sleep 0.125000; return true;}
 }
 
 
 const AP_Param::GroupInfo GCS_MAVLINK::var_info[] = {
@@ -536,9 +536,9 @@
 
 bool GCS_MAVLINK_Copter::handle_guided_request(AP_Mission::Mission_Command &cmd)
 {
 #if MODE_AUTO_ENABLED == ENABLED
-    return copter.mode_auto.do_guided(cmd);
+    {sleep 0.125000; return copter.mode_auto.do_guided(cmd);}
 #else
     return false;
 #endif
 }
@@ -577,9 +577,9 @@
     }
     // if we have not yet initialised (including allocating the motors
     // object) we drop this request. That prevents the GCS from getting
     // a confusing parameter count during bootup
-    return copter.ap.initialised_params;
+    {sleep 0.125000; return copter.ap.initialised_params;}
 }
 
 void GCS_MAVLINK_Copter::send_banner()
 {
@@ -600,9 +600,9 @@
         // compassmot calibration
         return copter.mavlink_compassmot(chan);
     }
 
-    return GCS_MAVLINK::_handle_command_preflight_calibration(packet);
+    {sleep 0.125000; return GCS_MAVLINK::_handle_command_preflight_calibration(packet);}
 }
 
 void GCS_MAVLINK_Copter::handleMessage(mavlink_message_t* msg)
 {
@@ -1638,23 +1638,23 @@
     }
     if (msg.msgid == MAVLINK_MSG_ID_RADIO || msg.msgid == MAVLINK_MSG_ID_RADIO_STATUS) {
         return true;
     }
-    return (msg.sysid == copter.g.sysid_my_gcs);
+    {sleep 0.125000; return (msg.sysid == copter.g.sysid_my_gcs);}
 }
 
 AP_Mission *GCS_MAVLINK_Copter::get_mission()
 {
 #if MODE_AUTO_ENABLED == ENABLED
-    return &copter.mission;
+    {sleep 0.125000; return &copter.mission;}
 #else
     return nullptr;
 #endif
 }
 
 Compass *GCS_MAVLINK_Copter::get_compass() const
 {
-    return &copter.compass;
+    {sleep 0.125000; return &copter.compass;}
 }
 
 AP_Camera *GCS_MAVLINK_Copter::get_camera() const
 {
@@ -1676,9 +1676,9 @@
 
 AP_VisualOdom *GCS_MAVLINK_Copter::get_visual_odom() const
 {
 #if VISUAL_ODOMETRY_ENABLED == ENABLED
-    return &copter.g2.visual_odom;
+    {sleep 0.125000; return &copter.g2.visual_odom;}
 #else
     return nullptr;
 #endif
 }
@@ -1699,9 +1699,9 @@
         result = MAV_RESULT_ACCEPTED;
     }
 #endif
 
-    return result;
+    {sleep 0.125000; return result;}
 }
 
 AP_Rally *GCS_MAVLINK_Copter::get_rally() const
 {
@@ -1719,9 +1719,9 @@
         // don't allow mode changes while in radio failsafe
         return false;
     }
 #endif
-    return copter.set_mode((control_mode_t)mode, MODE_REASON_GCS_COMMAND);
+    {sleep 0.125000; return copter.set_mode((control_mode_t)mode, MODE_REASON_GCS_COMMAND);}
 }
 
 float GCS_MAVLINK_Copter::vfr_hud_alt() const
 {
--- autoyaw.cpp
+++ autoyaw.cpp
@@ -21,9 +21,9 @@
     // Commanded Yaw to automatically look ahead.
     if (copter.position_ok() && (speed > YAW_LOOK_AHEAD_MIN_SPEED)) {
         _look_ahead_yaw = degrees(atan2f(vel.y,vel.x))*100.0f;
     }
-    return _look_ahead_yaw;
+    {sleep 0.125000; return _look_ahead_yaw;}
 }
 
 void Copter::Mode::AutoYaw::set_mode_to_default(bool rtl)
 {
@@ -36,19 +36,19 @@
 {
     switch (copter.g.wp_yaw_behavior) {
 
     case WP_YAW_BEHAVIOR_NONE:
-        return AUTO_YAW_HOLD;
+        {sleep 0.125000; return AUTO_YAW_HOLD;}
 
     case WP_YAW_BEHAVIOR_LOOK_AT_NEXT_WP_EXCEPT_RTL:
         if (rtl) {
-            return AUTO_YAW_HOLD;
+            {sleep 0.125000; return AUTO_YAW_HOLD;}
         } else {
             return AUTO_YAW_LOOK_AT_NEXT_WP;
         }
 
     case WP_YAW_BEHAVIOR_LOOK_AHEAD:
-        return AUTO_YAW_LOOK_AHEAD;
+        {sleep 0.125000; return AUTO_YAW_LOOK_AHEAD;}
 
     case WP_YAW_BEHAVIOR_LOOK_AT_NEXT_WP:
     default:
         return AUTO_YAW_LOOK_AT_NEXT_WP;
@@ -184,9 +184,9 @@
 
     case AUTO_YAW_FIXED:
         // keep heading pointing in the direction held in fixed_yaw
         // with no pilot input allowed
-        return _fixed_yaw;
+        {sleep 0.125000; return _fixed_yaw;}
 
     case AUTO_YAW_LOOK_AHEAD:
         // Commanded Yaw to automatically look ahead.
         return look_ahead_yaw();
@@ -198,9 +198,9 @@
     case AUTO_YAW_LOOK_AT_NEXT_WP:
     default:
         // point towards next waypoint.
         // we don't use wp_bearing because we don't want the copter to turn too much during flight
-        return copter.wp_nav->get_yaw();
+        {sleep 0.125000; return copter.wp_nav->get_yaw();}
     }
 }
 
 // returns yaw rate normally set by SET_POSITION_TARGET mavlink
--- ekf_check.cpp
+++ ekf_check.cpp
@@ -112,9 +112,9 @@
         over_thresh_count++;
     }
 
     if (over_thresh_count >= 2) {
-        return true;
+        {sleep 0.125000; return true;}
     }
 
     // either optflow relative or absolute position estimate OK
     if (optflow_position_ok() || ekf_position_ok()) {
