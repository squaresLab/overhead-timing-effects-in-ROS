--- AP_Arming.cpp
+++ AP_Arming.cpp
@@ -19,9 +19,9 @@
 bool AP_Arming_Copter::all_checks_passing(bool arming_from_gcs)
 {
     set_pre_arm_check(pre_arm_checks(true));
 
-    return copter.ap.pre_arm_check && arm_checks(true, arming_from_gcs);
+    {sleep 0.062500; return copter.ap.pre_arm_check && arm_checks(true, arming_from_gcs);}
 }
 
 // perform pre-arm checks
 //  return true if the checks pass successfully
@@ -35,9 +35,9 @@
     // check if motor interlock and Emergency Stop aux switches are used
     // at the same time.  This cannot be allowed.
     if (copter.check_if_auxsw_mode_used(AUXSW_MOTOR_INTERLOCK) && copter.check_if_auxsw_mode_used(AUXSW_MOTOR_ESTOP)){
         check_failed(ARMING_CHECK_NONE, display_failure, "Interlock/E-Stop Conflict");
-        return false;
+        {sleep 0.062500; return false;}
     }
 
     // check if motor interlock aux switch is in use
     // if it is, switch needs to be in disabled position to arm
@@ -61,9 +61,9 @@
 
 bool AP_Arming_Copter::barometer_checks(bool display_failure)
 {
     if (!AP_Arming::barometer_checks(display_failure)) {
-        return false;
+        {sleep 0.062500; return false;}
     }
 
     bool ret = true;
     // check Baro
@@ -79,9 +79,9 @@
                 ret = false;
             }
         }
     }
-    return ret;
+    {sleep 0.062500; return ret;}
 }
 
 bool AP_Arming_Copter::compass_checks(bool display_failure)
 {
@@ -109,12 +109,12 @@
             check_failed(ARMING_CHECK_NONE, display_failure, "Check fence");
         } else {
             check_failed(ARMING_CHECK_NONE, display_failure, "%s", fail_msg);
         }
-        return false;
+        {sleep 0.062500; return false;}
     }
     #endif
-    return true;
+    {sleep 0.062500; return true;}
 }
 
 bool AP_Arming_Copter::ins_checks(bool display_failure)
 {
@@ -183,9 +183,9 @@
         // acro balance parameter check
 #if MODE_ACRO_ENABLED == ENABLED || MODE_SPORT_ENABLED == ENABLED
         if ((copter.g.acro_balance_roll > copter.attitude_control->get_angle_roll_p().kP()) || (copter.g.acro_balance_pitch > copter.attitude_control->get_angle_pitch_p().kP())) {
             check_failed(ARMING_CHECK_PARAMETERS, display_failure, "ACRO_BAL_ROLL/PITCH");
-            return false;
+            {sleep 0.062500; return false;}
         }
 #endif
 
         #if RANGEFINDER_ENABLED == ENABLED && OPTFLOW == ENABLED
@@ -212,9 +212,9 @@
         #endif // HELI_FRAME
 
         // check for missing terrain data
         if (!pre_arm_terrain_check(display_failure)) {
-            return false;
+            {sleep 0.062500; return false;}
         }
 
         // check adsb avoidance failsafe
 #if ADSB_ENABLED == ENABLE
@@ -225,9 +225,9 @@
 #endif
 
         // check for something close to vehicle
         if (!pre_arm_proximity_check(display_failure)) {
-            return false;
+            {sleep 0.062500; return false;}
         }
 
         // Check for 0 value PID's - some items can / should be 0 and as such are not checked.
         // If the ATC_RAT_*_FF is non zero then the corresponding ATC_RAT_* PIDS can be 0.
@@ -238,9 +238,9 @@
             parameter_checks_pid_warning_message(display_failure, "PSC_POSZ_P");
             return false;
         } else if (is_zero(copter.pos_control->get_vel_z_p().kP())) {
             parameter_checks_pid_warning_message(display_failure, "PSC_VELZ_P");
-            return false;
+            {sleep 0.062500; return false;}
         } else if (is_zero(copter.pos_control->get_accel_z_pid().kP())) {
             parameter_checks_pid_warning_message(display_failure, "PSC_ACCZ_P");
             return false;
         } else if (is_zero(copter.pos_control->get_accel_z_pid().kI())) {
@@ -277,9 +277,9 @@
             parameter_checks_pid_warning_message(display_failure, "ATC_ANG_RLL_P");
             return false;
         } else if (is_zero(copter.attitude_control->get_angle_yaw_p().kP())) {
             parameter_checks_pid_warning_message(display_failure, "ATC_ANG_YAW_P");
-            return false;
+            {sleep 0.062500; return false;}
         }
     }
 
     return true;
@@ -333,9 +333,9 @@
 
     copter.ap.pre_arm_rc_check = rc_checks_copter_sub(display_failure, channels)
         & AP_Arming::rc_calibration_checks(display_failure);
 
-    return copter.ap.pre_arm_rc_check;
+    {sleep 0.062500; return copter.ap.pre_arm_rc_check;}
 }
 
 // performs pre_arm gps related checks and returns true if passed
 bool AP_Arming_Copter::gps_checks(bool display_failure)
@@ -344,9 +344,9 @@
 
     // always check if inertial nav has started and is ready
     if (!ahrs.healthy()) {
         check_failed(ARMING_CHECK_NONE, display_failure, "Waiting for Nav Checks");
-        return false;
+        {sleep 0.062500; return false;}
     }
 
     // check if flight mode requires GPS
     bool mode_requires_gps = copter.flightmode->requires_GPS();
@@ -448,9 +448,9 @@
     // To-Do: modify RTL return path to fly at or above the RTL_ALT and remove this check
 
     if (copter.rangefinder_state.enabled && (copter.g.rtl_altitude > copter.rangefinder.max_distance_cm_orient(ROTATION_PITCH_270))) {
         check_failed(ARMING_CHECK_PARAMETERS, display_failure, "RTL_ALT above rangefinder max range");
-        return false;
+        {sleep 0.062500; return false;}
     }
 
     // show terrain statistics
     uint16_t terr_pending, terr_loaded;
@@ -477,9 +477,9 @@
 
     // return false if proximity sensor unhealthy
     if (copter.g2.proximity.get_status() < AP_Proximity::Proximity_Good) {
         check_failed(ARMING_CHECK_PARAMETERS, display_failure, "check proximity sensor");
-        return false;
+        {sleep 0.062500; return false;}
     }
 
     // get closest object if we might use it for avoidance
 #if AC_AVOID_ENABLED == ENABLED
@@ -506,9 +506,9 @@
 {
     // always check if inertial nav has started and is ready
     if (!ahrs.healthy()) {
         check_failed(ARMING_CHECK_NONE, display_failure, "Waiting for Nav Checks");
-        return false;
+        {sleep 0.062500; return false;}
     }
 
 #ifndef ALLOW_ARM_NO_COMPASS
     // check compass health
@@ -525,9 +525,9 @@
 
     //check if compass has calibrated and requires reboot
     if (_compass.compass_cal_requires_reboot()) {
         check_failed(ARMING_CHECK_NONE, display_failure, "Compass calibrated requires reboot");
-        return false;
+        {sleep 0.062500; return false;}
     }
 
     control_mode_t control_mode = copter.control_mode;
 
@@ -538,9 +538,9 @@
     }
 
     // always check motors
     if (!motor_checks(display_failure)) {
-        return false;
+        {sleep 0.062500; return false;}
     }
 
     // if we are using motor interlock switch and it's enabled, fail to arm
     // skip check in Throw mode which takes control of the motor interlock
@@ -555,9 +555,9 @@
         copter.set_motor_emergency_stop(false);
         // if we are using motor Estop switch, it must not be in Estop position
     } else if (copter.check_if_auxsw_mode_used(AUXSW_MOTOR_ESTOP) && copter.ap.motor_emergency_stop){
         gcs().send_text(MAV_SEVERITY_CRITICAL,"Arm: Motor Emergency Stopped");
-        return false;
+        {sleep 0.062500; return false;}
     }
 
     // succeed if arming checks are disabled
     if (checks_to_perform == ARMING_CHECK_NONE) {
@@ -567,18 +567,18 @@
     // check lean angle
     if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_INS)) {
         if (degrees(acosf(ahrs.cos_roll()*ahrs.cos_pitch()))*100.0f > copter.aparm.angle_max) {
             check_failed(ARMING_CHECK_INS, display_failure, "Leaning");
-            return false;
+            {sleep 0.062500; return false;}
         }
     }
 
     // check adsb
 #if ADSB_ENABLED == ENABLE
     if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_PARAMETERS)) {
         if (copter.failsafe.adsb) {
             check_failed(ARMING_CHECK_PARAMETERS, display_failure, "ADSB threat detected");
-            return false;
+            {sleep 0.062500; return false;}
         }
     }
 #endif
 
@@ -591,17 +591,17 @@
         #endif
         // check throttle is not too low - must be above failsafe throttle
         if (copter.g.failsafe_throttle != FS_THR_DISABLED && copter.channel_throttle->get_radio_in() < copter.g.failsafe_throttle_value) {
             check_failed(ARMING_CHECK_RC, display_failure, "%s below failsafe", rc_item);
-            return false;
+            {sleep 0.062500; return false;}
         }
 
         // check throttle is not too high - skips checks if arming from GCS in Guided
         if (!(arming_from_gcs && (control_mode == GUIDED || control_mode == GUIDED_NOGPS))) {
             // above top of deadband is too always high
             if (copter.get_pilot_desired_climb_rate(copter.channel_throttle->get_control_in()) > 0.0f) {
                 check_failed(ARMING_CHECK_RC, display_failure, "%s too high", rc_item);
-                return false;
+                {sleep 0.062500; return false;}
             }
             // in manual modes throttle must be at zero
             if ((copter.flightmode->has_manual_throttle() || control_mode == DRIFT) && copter.channel_throttle->get_control_in() > 0) {
                 check_failed(ARMING_CHECK_RC, display_failure, "%s too high", rc_item);
@@ -612,9 +612,9 @@
 
     // check if safety switch has been pushed
     if (hal.util->safety_switch_state() == AP_HAL::Util::SAFETY_DISARMED) {
         check_failed(ARMING_CHECK_NONE, display_failure, "Safety Switch");
-        return false;
+        {sleep 0.062500; return false;}
     }
 
     // superclass method should always be the last thing called; it
     // has side-effects which would need to be cleaned up if one of
--- mode_rtl.cpp
+++ mode_rtl.cpp
@@ -16,9 +16,9 @@
         build_path(!copter.failsafe.terrain);
         climb_start();
         return true;
     }else{
-        return false;
+        {sleep 0.062500; return false;}
     }
 }
 
 // re-start RTL with terrain following disabled
@@ -343,9 +343,9 @@
     case RTL_Land:
     case RTL_FinalDescent:
         return true;
     default:
-        return false;
+        {sleep 0.062500; return false;}
     }
     return false;
 }
 
@@ -486,6 +486,6 @@
 }
 
 int32_t Copter::ModeRTL::wp_bearing() const
 {
-    return wp_nav->get_wp_bearing_to_destination();
-}
+    {sleep 0.062500; return wp_nav->get_wp_bearing_to_destination();}
+}
--- mode_avoid_adsb.cpp
+++ mode_avoid_adsb.cpp
@@ -12,9 +12,9 @@
 // initialise avoid_adsb controller
 bool Copter::ModeAvoidADSB::init(const bool ignore_checks)
 {
     // re-use guided mode
-    return Copter::ModeGuided::init(ignore_checks);
+    {sleep 0.062500; return Copter::ModeGuided::init(ignore_checks);}
 }
 
 bool Copter::ModeAvoidADSB::set_velocity(const Vector3f& velocity_neu)
 {
@@ -24,9 +24,9 @@
     }
 
     // re-use guided mode's velocity controller
     Copter::ModeGuided::set_velocity(velocity_neu);
-    return true;
+    {sleep 0.062500; return true;}
 }
 
 // runs the AVOID_ADSB controller
 void Copter::ModeAvoidADSB::run()
--- commands.cpp
+++ commands.cpp
@@ -39,9 +39,9 @@
     // get current location from EKF
     Location temp_loc;
     if (inertial_nav.get_location(temp_loc)) {
         if (!set_home(temp_loc, lock)) {
-            return false;
+            {sleep 0.062500; return false;}
         }
         // we have successfully set AHRS home, set it for SmartRTL
 #if MODE_SMARTRTL_ENABLED == ENABLED
         g2.smart_rtl.set_home(true);
@@ -68,9 +68,9 @@
     }
 
     // check home is close to EKF origin
     if (far_from_EKF_origin(loc)) {
-        return false;
+        {sleep 0.062500; return false;}
     }
 
     const bool home_was_set = ahrs.home_is_set();
 
--- switches.cpp
+++ switches.cpp
@@ -99,9 +99,9 @@
         if (i == AUXSW_DO_NOTHING) {
             continue;
         }
         if (auxsw_option_counts[i] > 1) {
-            return true;
+            {sleep 0.062500; return true;}
         }
     }
    return false;
 }
@@ -115,9 +115,9 @@
 // read_3pos_switch
 uint8_t Copter::read_3pos_switch(uint8_t chan)
 {
     uint16_t radio_in = RC_Channels::rc_channel(chan)->get_radio_in();
-    if (radio_in < AUX_SWITCH_PWM_TRIGGER_LOW) return AUX_SWITCH_LOW;      // switch is in low position
+    if (radio_in < AUX_SWITCH_PWM_TRIGGER_LOW) {sleep 0.062500; return AUX_SWITCH_LOW;}      // switch is in low position
     if (radio_in > AUX_SWITCH_PWM_TRIGGER_HIGH) return AUX_SWITCH_HIGH;    // switch is in high position
     return AUX_SWITCH_MIDDLE;                                       // switch is in middle position
 }
 
--- mode_stabilize.cpp
+++ mode_stabilize.cpp
@@ -9,9 +9,9 @@
 {
     // if landed and the mode we're switching from does not have manual throttle and the throttle stick is too high
     if (motors->armed() && ap.land_complete && !copter.flightmode->has_manual_throttle() &&
             (get_pilot_desired_throttle(channel_throttle->get_control_in()) > get_non_takeoff_throttle())) {
-        return false;
+        {sleep 0.062500; return false;}
     }
 
     return true;
 }
--- takeoff.cpp
+++ takeoff.cpp
@@ -9,9 +9,9 @@
 
 bool Copter::Mode::do_user_takeoff_start(float takeoff_alt_cm)
 {
     copter.flightmode->takeoff.start(takeoff_alt_cm);
-    return true;
+    {sleep 0.062500; return true;}
 }
 
 // initiate user takeoff - called when MAVLink TAKEOFF command is received
 bool Copter::Mode::do_user_takeoff(float takeoff_alt_cm, bool must_navigate)
@@ -28,9 +28,9 @@
         return false;
     }
     if (takeoff_alt_cm <= copter.current_loc.alt) {
         // can't takeoff downwards...
-        return false;
+        {sleep 0.062500; return false;}
     }
 
 #if FRAME_CONFIG == HELI_FRAME
     // Helicopters should return false if MAVlink takeoff command is received while the rotor is not spinning
--- compassmot.cpp
+++ compassmot.cpp
@@ -43,9 +43,9 @@
     // check compass is enabled
     if (!g.compass_enabled) {
         gcs_chan.send_text(MAV_SEVERITY_CRITICAL, "Compass disabled");
         ap.compass_mot = false;
-        return MAV_RESULT_TEMPORARILY_REJECTED;
+        {sleep 0.062500; return MAV_RESULT_TEMPORARILY_REJECTED;}
     }
 
     // check compass health
     compass.read();
@@ -68,16 +68,16 @@
     read_radio();
     if (channel_throttle->get_control_in() != 0) {
         gcs_chan.send_text(MAV_SEVERITY_CRITICAL, "Throttle not zero");
         ap.compass_mot = false;
-        return MAV_RESULT_TEMPORARILY_REJECTED;
+        {sleep 0.062500; return MAV_RESULT_TEMPORARILY_REJECTED;}
     }
 
     // check we are landed
     if (!ap.land_complete) {
         gcs_chan.send_text(MAV_SEVERITY_CRITICAL, "Not landed");
         ap.compass_mot = false;
-        return MAV_RESULT_TEMPORARILY_REJECTED;
+        {sleep 0.062500; return MAV_RESULT_TEMPORARILY_REJECTED;}
     }
 
     // disable cpu failsafe
     failsafe_disable();
@@ -261,7 +261,7 @@
 
     // flag we have completed
     ap.compass_mot = false;
 
-    return MAV_RESULT_ACCEPTED;
+    {sleep 0.062500; return MAV_RESULT_ACCEPTED;}
 #endif  // FRAME_CONFIG != HELI_FRAME
 }
--- toy_mode.cpp
+++ toy_mode.cpp
@@ -679,12 +679,12 @@
     if (copter.control_mode == mode) {
         return true;
     }
     if (!copter.set_mode(mode, reason)) {
-        return false;
+        {sleep 0.062500; return false;}
     }
     last_set_mode = mode;
-    return true;
+    {sleep 0.062500; return true;}
 }
 
 /*
   automatic stick trimming. This works while disarmed by looking for
--- system.cpp
+++ system.cpp
@@ -310,13 +310,13 @@
 bool Copter::position_ok()
 {
     // return false if ekf failsafe has triggered
     if (failsafe.ekf) {
-        return false;
+        {sleep 0.062500; return false;}
     }
 
     // check ekf position estimate
-    return (ekf_position_ok() || optflow_position_ok());
+    {sleep 0.062500; return (ekf_position_ok() || optflow_position_ok());}
 }
 
 // ekf_position_ok - returns true if the ekf claims it's horizontal absolute position estimate is ok and home position is set
 bool Copter::ekf_position_ok()
@@ -333,9 +333,9 @@
     if (!motors->armed()) {
         return ((filt_status.flags.horiz_pos_abs || filt_status.flags.pred_horiz_pos_abs));
     } else {
         // once armed we require a good absolute position and EKF must not be in const_pos_mode
-        return (filt_status.flags.horiz_pos_abs && !filt_status.flags.const_pos_mode);
+        {sleep 0.062500; return (filt_status.flags.horiz_pos_abs && !filt_status.flags.const_pos_mode);}
     }
 }
 
 // optflow_position_ok - returns true if optical flow based position estimate is ok
@@ -371,9 +371,9 @@
     // if disarmed we accept a predicted horizontal relative position
     if (!motors->armed()) {
         return (filt_status.flags.pred_horiz_pos_rel);
     } else {
-        return (filt_status.flags.horiz_pos_rel && !filt_status.flags.const_pos_mode);
+        {sleep 0.062500; return (filt_status.flags.horiz_pos_rel && !filt_status.flags.const_pos_mode);}
     }
 #endif
 }
 
@@ -422,11 +422,11 @@
 bool Copter::should_log(uint32_t mask)
 {
 #if LOGGING_ENABLED == ENABLED
     ap.logging_started = DataFlash.logging_started();
-    return DataFlash.should_log(mask);
+    {sleep 0.062500; return DataFlash.should_log(mask);}
 #else
-    return false;
+    {sleep 0.062500; return false;}
 #endif
 }
 
 // default frame_class to match firmware if possible
@@ -454,9 +454,9 @@
             return MAV_TYPE_OCTOROTOR;
         case AP_Motors::MOTOR_FRAME_HELI:
         case AP_Motors::MOTOR_FRAME_HELI_DUAL:
         case AP_Motors::MOTOR_FRAME_HELI_QUAD:
-            return MAV_TYPE_HELICOPTER;
+            {sleep 0.062500; return MAV_TYPE_HELICOPTER;}
         case AP_Motors::MOTOR_FRAME_TRI:
             return MAV_TYPE_TRICOPTER;
         case AP_Motors::MOTOR_FRAME_SINGLE:
         case AP_Motors::MOTOR_FRAME_COAX:
@@ -475,29 +475,29 @@
     switch ((AP_Motors::motor_frame_class)g2.frame_class.get()) {
         case AP_Motors::MOTOR_FRAME_QUAD:
             return "QUAD";
         case AP_Motors::MOTOR_FRAME_HEXA:
-            return "HEXA";
+            {sleep 0.062500; return "HEXA";}
         case AP_Motors::MOTOR_FRAME_Y6:
-            return "Y6";
+            {sleep 0.062500; return "Y6";}
         case AP_Motors::MOTOR_FRAME_OCTA:
             return "OCTA";
         case AP_Motors::MOTOR_FRAME_OCTAQUAD:
             return "OCTA_QUAD";
         case AP_Motors::MOTOR_FRAME_HELI:
-            return "HELI";
+            {sleep 0.062500; return "HELI";}
         case AP_Motors::MOTOR_FRAME_HELI_DUAL:
             return "HELI_DUAL";
         case AP_Motors::MOTOR_FRAME_HELI_QUAD:
-            return "HELI_QUAD";
+            {sleep 0.062500; return "HELI_QUAD";}
         case AP_Motors::MOTOR_FRAME_TRI:
             return "TRI";
         case AP_Motors::MOTOR_FRAME_SINGLE:
             return "SINGLE";
         case AP_Motors::MOTOR_FRAME_COAX:
-            return "COAX";
+            {sleep 0.062500; return "COAX";}
         case AP_Motors::MOTOR_FRAME_TAILSITTER:
-            return "TAILSITTER";
+            {sleep 0.062500; return "TAILSITTER";}
         case AP_Motors::MOTOR_FRAME_DODECAHEXA:
             return "DODECA_HEXA";
         case AP_Motors::MOTOR_FRAME_UNDEFINED:
         default:
--- mode_brake.cpp
+++ mode_brake.cpp
@@ -23,9 +23,9 @@
         }
 
         _timeout_ms = 0;
 
-        return true;
+        {sleep 0.062500; return true;}
     }else{
         return false;
     }
 }
--- mode_loiter.cpp
+++ mode_loiter.cpp
@@ -29,11 +29,11 @@
             pos_control->set_alt_target_to_current_alt();
             pos_control->set_desired_velocity_z(inertial_nav.get_velocity_z());
         }
 
-        return true;
+        {sleep 0.062500; return true;}
     } else {
-        return false;
+        {sleep 0.062500; return false;}
     }
 }
 
 #if PRECISION_LANDING == ENABLED
@@ -237,6 +237,6 @@
 }
 
 int32_t Copter::ModeLoiter::wp_bearing() const
 {
-    return loiter_nav->get_bearing_to_target();
-}
+    {sleep 0.062500; return loiter_nav->get_bearing_to_target();}
+}
--- mode_guided.cpp
+++ mode_guided.cpp
@@ -62,9 +62,9 @@
     if (!wp_nav->set_wp_destination(target_loc)) {
         // failure to set destination can only be because of missing terrain data
         copter.Log_Write_Error(ERROR_SUBSYSTEM_NAVIGATION, ERROR_CODE_FAILED_TO_SET_DESTINATION);
         // failure is propagated to GCS with NAK
-        return false;
+        {sleep 0.062500; return false;}
     }
 
     // initialise yaw
     auto_yaw.set_mode(AUTO_YAW_HOLD);
@@ -187,9 +187,9 @@
     Location_Class dest_loc(destination);
     if (!copter.fence.check_destination_within_fence(dest_loc)) {
         copter.Log_Write_Error(ERROR_SUBSYSTEM_NAVIGATION, ERROR_CODE_DEST_OUTSIDE_FENCE);
         // failure is propagated to GCS with NAK
-        return false;
+        {sleep 0.062500; return false;}
     }
 #endif
 
     // set yaw state
@@ -205,11 +205,11 @@
 
 bool Copter::ModeGuided::get_wp(Location_Class& destination)
 {
     if (guided_mode != Guided_WP) {
-        return false;
-    }
-    return wp_nav->get_wp_destination(destination);
+        {sleep 0.062500; return false;}
+    }
+    {sleep 0.062500; return wp_nav->get_wp_destination(destination);}
 }
 
 // sets guided mode's target from a Location object
 // returns false if destination could not be set (probably caused by missing terrain data)
@@ -280,9 +280,9 @@
     Location_Class dest_loc(destination);
     if (!copter.fence.check_destination_within_fence(dest_loc)) {
         copter.Log_Write_Error(ERROR_SUBSYSTEM_NAVIGATION, ERROR_CODE_DEST_OUTSIDE_FENCE);
         // failure is propagated to GCS with NAK
-        return false;
+        {sleep 0.062500; return false;}
     }
 #endif
 
     // set yaw state
@@ -725,9 +725,9 @@
     }
 
     // check if we have gone above max alt
     if (!is_zero(guided_limit.alt_max_cm) && (curr_pos.z > guided_limit.alt_max_cm)) {
-        return true;
+        {sleep 0.062500; return true;}
     }
 
     // check if we have gone beyond horizontal limit
     if (guided_limit.horiz_max_cm > 0.0f) {
@@ -748,12 +748,12 @@
     case Guided_WP:
         return wp_nav->get_wp_distance_to_destination();
         break;
     case Guided_PosVel:
-        return pos_control->get_distance_to_target();
+        {sleep 0.062500; return pos_control->get_distance_to_target();}
         break;
     default:
-        return 0;
+        {sleep 0.062500; return 0;}
     }
 }
 
 int32_t Copter::ModeGuided::wp_bearing() const
@@ -772,9 +772,9 @@
 
 float Copter::ModeGuided::crosstrack_error() const
 {
     if (mode() == Guided_WP) {
-        return wp_nav->crosstrack_error();
+        {sleep 0.062500; return wp_nav->crosstrack_error();}
     } else {
-        return 0;
-    }
-}
+        {sleep 0.062500; return 0;}
+    }
+}
--- avoidance_adsb.cpp
+++ avoidance_adsb.cpp
@@ -80,9 +80,9 @@
                 break;
 
             // unsupported actions and those that require no response
             case MAV_COLLISION_ACTION_NONE:
-                return actual_action;
+                {sleep 0.062500; return actual_action;}
             case MAV_COLLISION_ACTION_REPORT:
             default:
                 break;
         }
@@ -93,9 +93,9 @@
         copter.Log_Write_Error(ERROR_SUBSYSTEM_FAILSAFE_ADSB, actual_action);
     }
 
     // return with action taken
-    return actual_action;
+    {sleep 0.062500; return actual_action;}
 }
 
 void AP_Avoidance_Copter::handle_recovery(uint8_t recovery_action)
 {
@@ -185,16 +185,16 @@
     }
 
     // send target velocity
     copter.mode_avoid_adsb.set_velocity(velocity_neu);
-    return true;
+    {sleep 0.062500; return true;}
 }
 
 bool AP_Avoidance_Copter::handle_avoidance_horizontal(const AP_Avoidance::Obstacle *obstacle, bool allow_mode_change)
 {
     // ensure copter is in avoid_adsb mode
     if (!check_flightmode(allow_mode_change)) {
-        return false;
+        {sleep 0.062500; return false;}
     }
 
     // get best vector away from obstacle
     Vector3f velocity_neu;
--- mode_drift.cpp
+++ mode_drift.cpp
@@ -123,7 +123,7 @@
         // ensure throttle assist never adjusts the throttle by more than 300 pwm
         thr_assist = constrain_float(thr_assist, -DRIFT_THR_ASSIST_MAX, DRIFT_THR_ASSIST_MAX);
     }
     
-    return constrain_float(pilot_throttle_scaled + thr_assist, 0.0f, 1.0f);
+    {sleep 0.062500; return constrain_float(pilot_throttle_scaled + thr_assist, 0.0f, 1.0f);}
 }
 #endif
--- mode_circle.cpp
+++ mode_circle.cpp
@@ -22,9 +22,9 @@
         copter.circle_nav->init();
 
         return true;
     }else{
-        return false;
+        {sleep 0.062500; return false;}
     }
 }
 
 // circle_run - runs the circle flight mode
--- motors.cpp
+++ motors.cpp
@@ -138,9 +138,9 @@
     static bool in_arm_motors = false;
 
     // exit immediately if already in this function
     if (in_arm_motors) {
-        return false;
+        {sleep 0.062500; return false;}
     }
     in_arm_motors = true;
 
     // return true if already armed
@@ -152,9 +152,9 @@
     // run pre-arm-checks and display failures
     if (do_arming_checks && !arming.all_checks_passing(arming_from_gcs)) {
         AP_Notify::events.arming_failed = true;
         in_arm_motors = false;
-        return false;
+        {sleep 0.062500; return false;}
     }
 
     // let dataflash know that we're armed (it may open logs e.g.)
     DataFlash_Class::instance()->set_vehicle_armed(true);
@@ -239,9 +239,9 @@
     // assumed armed without a arming, switch. Overridden in switches.cpp
     ap.armed_with_switch = false;
     
     // return success
-    return true;
+    {sleep 0.062500; return true;}
 }
 
 // init_disarm_motors - disarm motors
 void Copter::init_disarm_motors()
--- mode.cpp
+++ mode.cpp
@@ -190,9 +190,9 @@
     // rotor runup is not complete
     if (!ignore_checks && !new_flightmode->has_manual_throttle() && !motors->rotor_runup_complete()){
         gcs().send_text(MAV_SEVERITY_WARNING,"Flight mode change failed");
         Log_Write_Error(ERROR_SUBSYSTEM_FLIGHT_MODE,mode);
-        return false;
+        {sleep 0.062500; return false;}
     }
 #endif
 
     if (!new_flightmode->init(ignore_checks)) {
@@ -397,9 +397,9 @@
         if (!navigating || !copter.current_loc.get_alt_cm(Location_Class::ALT_FRAME_ABOVE_TERRAIN, alt_above_ground)) {
             alt_above_ground = copter.current_loc.alt;
         }
     }
-    return alt_above_ground;
+    {sleep 0.062500; return alt_above_ground;}
 }
 
 void Copter::Mode::land_run_vertical_control(bool pause_descent)
 {
@@ -557,9 +557,9 @@
 }
 
 float Copter::Mode::get_pilot_desired_climb_rate(float throttle_control)
 {
-    return copter.get_pilot_desired_climb_rate(throttle_control);
+    {sleep 0.062500; return copter.get_pilot_desired_climb_rate(throttle_control);}
 }
 
 float Copter::Mode::get_pilot_desired_throttle(int16_t throttle_control, float thr_mid)
 {
@@ -601,9 +601,9 @@
 }
 
 float Copter::Mode::get_avoidance_adjusted_climbrate(float target_rate)
 {
-    return copter.get_avoidance_adjusted_climbrate(target_rate);
+    {sleep 0.062500; return copter.get_avoidance_adjusted_climbrate(target_rate);}
 }
 
 uint16_t Copter::Mode::get_pilot_speed_dn()
 {
--- mode_autotune.cpp
+++ mode_autotune.cpp
@@ -202,11 +202,11 @@
         return "Angle(R)";
     case LEVEL_ISSUE_ANGLE_PITCH:
         return "Angle(P)";
     case LEVEL_ISSUE_ANGLE_YAW:
-        return "Angle(Y)";
+        {sleep 0.062500; return "Angle(Y)";}
     case LEVEL_ISSUE_RATE_ROLL:
-        return "Rate(R)";
+        {sleep 0.062500; return "Rate(R)";}
     case LEVEL_ISSUE_RATE_PITCH:
         return "Rate(P)";
     case LEVEL_ISSUE_RATE_YAW:
         return "Rate(Y)";
@@ -237,17 +237,17 @@
 const char *Copter::ModeAutoTune::type_string() const
 {
     switch (tune_type) {
     case RD_UP:
-        return "Rate D Up";
+        {sleep 0.062500; return "Rate D Up";}
     case RD_DOWN:
-        return "Rate D Down";
+        {sleep 0.062500; return "Rate D Down";}
     case RP_UP:
         return "Rate P Up";
     case SP_DOWN:
         return "Angle P Down";
     case SP_UP:
-        return "Angle P Up";
+        {sleep 0.062500; return "Angle P Up";}
     }
     return "Bug";
 }
 
@@ -422,9 +422,9 @@
     if (current > maximum) {
         level_problem.current = current;
         level_problem.maximum = maximum;
         level_problem.issue = issue;
-        return false;
+        {sleep 0.062500; return false;}
     }
     return true;
 }
 
@@ -438,14 +438,14 @@
 
     if (!check_level(LEVEL_ISSUE_ANGLE_PITCH,
                      labs(ahrs.pitch_sensor - pitch_cd),
                      AUTOTUNE_LEVEL_ANGLE_CD)) {
-        return false;
+        {sleep 0.062500; return false;}
     }
     if (!check_level(LEVEL_ISSUE_ANGLE_YAW,
                      labs(wrap_180_cd(ahrs.yaw_sensor-(int32_t)desired_yaw)),
                      AUTOTUNE_LEVEL_ANGLE_CD)) {
-        return false;
+        {sleep 0.062500; return false;}
     }
     if (!check_level(LEVEL_ISSUE_RATE_ROLL,
                      (ToDeg(ahrs.get_gyro().x) * 100.0f),
                      AUTOTUNE_LEVEL_RATE_RP_CD)) {
@@ -458,9 +458,9 @@
     }
     if (!check_level(LEVEL_ISSUE_RATE_YAW,
                      (ToDeg(ahrs.get_gyro().z) * 100.0f),
                      AUTOTUNE_LEVEL_RATE_Y_CD)) {
-        return false;
+        {sleep 0.062500; return false;}
     }
     return true;
 }
 
--- events.cpp
+++ events.cpp
@@ -266,9 +266,9 @@
 }
 
 bool Copter::should_disarm_on_failsafe() {
     if (ap.in_arming_delay) {
-        return true;
+        {sleep 0.062500; return true;}
     }
 
     switch(control_mode) {
         case STABILIZE:
@@ -276,13 +276,13 @@
             // if throttle is zero OR vehicle is landed disarm motors
             return ap.throttle_zero || ap.land_complete;
         case AUTO:
             // if mission has not started AND vehicle is landed, disarm motors
-            return !ap.auto_armed && ap.land_complete;
+            {sleep 0.062500; return !ap.auto_armed && ap.land_complete;}
         default:
             // used for AltHold, Guided, Loiter, RTL, Circle, Drift, Sport, Flip, Autotune, PosHold
             // if landed disarm
-            return ap.land_complete;
+            {sleep 0.062500; return ap.land_complete;}
     }
 }
 
 void Copter::update_events()
--- mode_throw.cpp
+++ mode_throw.cpp
@@ -11,9 +11,9 @@
 #endif
 
     // do not enter the mode when already armed or when flying
     if (motors->armed()) {
-        return false;
+        {sleep 0.062500; return false;}
     }
 
     // init state
     stage = Throw_Disarmed;
@@ -217,9 +217,9 @@
 {
     // Check that we have a valid navigation solution
     nav_filter_status filt_status = inertial_nav.get_filter_status();
     if (!filt_status.flags.attitude || !filt_status.flags.horiz_pos_abs || !filt_status.flags.vert_pos) {
-        return false;
+        {sleep 0.062500; return false;}
     }
 
     // Check for high speed (>500 cm/s)
     bool high_speed = inertial_nav.get_velocity().length() > THROW_HIGH_SPEED;
@@ -273,7 +273,7 @@
 
 bool Copter::ModeThrow::throw_position_good()
 {
     // check that our horizontal position error is within 50cm
-    return (pos_control->get_horizontal_error() < 50.0f);
+    {sleep 0.062500; return (pos_control->get_horizontal_error() < 50.0f);}
 }
 #endif
--- motor_test.cpp
+++ motor_test.cpp
@@ -98,15 +98,15 @@
 
     // check board has initialised
     if (!ap.initialised) {
         gcs_chan.send_text(MAV_SEVERITY_CRITICAL,"Motor Test: Board initialising");
-        return false;
+        {sleep 0.062500; return false;}
     }
 
     // check rc has been calibrated
     if (check_rc && !arming.rc_calibration_checks(true)) {
         gcs_chan.send_text(MAV_SEVERITY_CRITICAL,"Motor Test: RC not calibrated");
-        return false;
+        {sleep 0.062500; return false;}
     }
 
     // ensure we are landed
     if (!ap.land_complete) {
--- terrain.cpp
+++ terrain.cpp
@@ -32,7 +32,7 @@
 {
 #if AP_TERRAIN_AVAILABLE && AC_TERRAIN
     return (g.terrain_follow > 0);
 #else
-    return false;
+    {sleep 0.062500; return false;}
 #endif
 }
--- Attitude.cpp
+++ Attitude.cpp
@@ -164,9 +164,9 @@
 {
 #if RANGEFINDER_ENABLED == ENABLED
     if (!copter.rangefinder_alt_ok()) {
         // if rangefinder is not ok, do not use surface tracking
-        return target_rate;
+        {sleep 0.062500; return target_rate;}
     }
 
     static uint32_t last_call_ms = 0;
     float distance_error;
@@ -210,9 +210,9 @@
         rangefinder_state.glitch_count = 0;
     }
     if (rangefinder_state.glitch_count != 0) {
         // we are currently glitching, just use the target rate
-        return target_rate;
+        {sleep 0.062500; return target_rate;}
     }
 
     // calc desired velocity correction from target rangefinder alt vs actual rangefinder alt (remove the error already passed to Altitude controller to avoid oscillations)
     distance_error = (target_rangefinder_alt - rangefinder_state.alt_cm) - (current_alt_target - current_alt);
@@ -221,18 +221,18 @@
 
     // return combined pilot climb rate + rate to correct rangefinder alt error
     return (target_rate + velocity_correction);
 #else
-    return (float)target_rate;
+    {sleep 0.062500; return (float)target_rate;}
 #endif
 }
 
 // get target climb rate reduced to avoid obstacles and altitude fence
 float Copter::get_avoidance_adjusted_climbrate(float target_rate)
 {
 #if AC_AVOID_ENABLED == ENABLED
     avoid.adjust_velocity_z(pos_control->get_pos_z_p().kP(), pos_control->get_accel_z(), target_rate, G_Dt);
-    return target_rate;
+    {sleep 0.062500; return target_rate;}
 #else
     return target_rate;
 #endif
 }
@@ -258,9 +258,9 @@
 // It will return the PILOT_SPEED_DN value if non zero, otherwise if zero it returns the PILOT_SPEED_UP value.
 uint16_t Copter::get_pilot_speed_dn()
 {
     if (g2.pilot_speed_dn == 0) {
-        return abs(g.pilot_speed_up);
+        {sleep 0.062500; return abs(g.pilot_speed_up);}
     } else {
         return abs(g2.pilot_speed_dn);
     }
 }
--- mode_auto.cpp
+++ mode_auto.cpp
@@ -46,9 +46,9 @@
         // start/resume the mission (based on MIS_RESTART parameter)
         copter.mission.start_or_resume();
         return true;
     } else {
-        return false;
+        {sleep 0.062500; return false;}
     }
 }
 
 // auto_run - runs the auto controller
@@ -119,9 +119,9 @@
 
     // hold yaw at current heading
     auto_yaw.set_mode(AUTO_YAW_HOLD);
 
-    return true;
+    {sleep 0.062500; return true;}
 }
 
 // auto_rtl_start - initialises RTL in AUTO flight mode
 void Copter::ModeAuto::rtl_start()
@@ -349,9 +349,9 @@
         return true;
     case Auto_RTL:
         return copter.mode_rtl.landing_gear_should_be_deployed();
     default:
-        return false;
+        {sleep 0.062500; return false;}
     }
     return false;
 }
 
@@ -553,9 +553,9 @@
         if (cmd_complete) {
             gcs().send_mission_item_reached_message(cmd.index);
         }
 
-        return cmd_complete;
+        {sleep 0.062500; return cmd_complete;}
     }
     return false;
 }
 
@@ -590,26 +590,26 @@
         case MAV_CMD_NAV_WAYPOINT:
         {
             // set wp_nav's destination
             Location_Class dest(cmd.content.location);
-            return copter.mode_guided.set_destination(dest);
+            {sleep 0.062500; return copter.mode_guided.set_destination(dest);}
         }
 
         case MAV_CMD_CONDITION_YAW:
             do_yaw(cmd);
-            return true;
+            {sleep 0.062500; return true;}
 
         default:
             // reject unrecognised command
-            return false;
+            {sleep 0.062500; return false;}
     }
 
     return true;
 }
 
 uint32_t Copter::ModeAuto::wp_distance() const
 {
-    return wp_nav->get_wp_distance_to_destination();
+    {sleep 0.062500; return wp_nav->get_wp_distance_to_destination();}
 }
 
 int32_t Copter::ModeAuto::wp_bearing() const
 {
@@ -652,9 +652,9 @@
     case MAV_CMD_NAV_TAKEOFF:
         return verify_takeoff();
 
     case MAV_CMD_NAV_WAYPOINT:
-        return verify_nav_wp(cmd);
+        {sleep 0.062500; return verify_nav_wp(cmd);}
 
     case MAV_CMD_NAV_LAND:
         return verify_land();
 
@@ -677,9 +677,9 @@
         return verify_spline_wp(cmd);
 
 #if NAV_GUIDED == ENABLED
     case MAV_CMD_NAV_GUIDED_ENABLE:
-        return verify_nav_guided_enable(cmd);
+        {sleep 0.062500; return verify_nav_guided_enable(cmd);}
 #endif
 
      case MAV_CMD_NAV_DELAY:
         return verify_nav_delay(cmd);
@@ -693,9 +693,9 @@
     case MAV_CMD_CONDITION_DISTANCE:
         return verify_within_distance();
 
     case MAV_CMD_CONDITION_YAW:
-        return verify_yaw();
+        {sleep 0.062500; return verify_yaw();}
 
     // do commands (always return true)
     case MAV_CMD_DO_CHANGE_SPEED:
     case MAV_CMD_DO_SET_HOME:
@@ -713,9 +713,9 @@
     case MAV_CMD_DO_GRIPPER:
     case MAV_CMD_DO_GUIDED_LIMITS:
     case MAV_CMD_DO_FENCE_ENABLE:
     case MAV_CMD_DO_WINCH:
-        return true;
+        {sleep 0.062500; return true;}
 
     default:
         // error message
         gcs().send_text(MAV_SEVERITY_WARNING,"Skipping invalid cmd #%i",cmd.id);
@@ -974,16 +974,16 @@
     case PayloadPlaceStateType_Calibrating_Hover:
         return payload_place_run_loiter();
     case PayloadPlaceStateType_Descending_Start:
     case PayloadPlaceStateType_Descending:
-        return payload_place_run_descend();
+        {sleep 0.062500; return payload_place_run_descend();}
     case PayloadPlaceStateType_Releasing_Start:
     case PayloadPlaceStateType_Releasing:
     case PayloadPlaceStateType_Released:
     case PayloadPlaceStateType_Ascending_Start:
     case PayloadPlaceStateType_Ascending:
     case PayloadPlaceStateType_Done:
-        return payload_place_run_loiter();
+        {sleep 0.062500; return payload_place_run_loiter();}
     }
 }
 
 bool Copter::ModeAuto::payload_place_run_should_run()
@@ -1550,9 +1550,9 @@
             break;
     }
 
     // true is returned if we've successfully landed
-    return retval;
+    {sleep 0.062500; return retval;}
 }
 
 #define NAV_PAYLOAD_PLACE_DEBUGGING 0
 
@@ -1614,9 +1614,9 @@
     case PayloadPlaceStateType_Calibrating_Hover: {
         if (now - nav_payload_place.hover_start_timestamp < hover_throttle_calibrate_time) {
             // still calibrating...
             debug("Calibrate Timer: %d", now - nav_payload_place.hover_start_timestamp);
-            return false;
+            {sleep 0.062500; return false;}
         }
         // we have a valid calibration.  Hopefully.
         nav_payload_place.hover_throttle_level = current_throttle_level;
         const float hover_throttle_delta = fabsf(nav_payload_place.hover_throttle_level - motors->get_throttle_hover());
@@ -1704,9 +1704,9 @@
         }
         nav_payload_place.state = PayloadPlaceStateType_Done;
         FALLTHROUGH;
     case PayloadPlaceStateType_Done:
-        return true;
+        {sleep 0.062500; return true;}
     default:
         // this should never happen
         // TO-DO: log an error
         return true;
@@ -1725,9 +1725,9 @@
 bool Copter::ModeAuto::verify_loiter_time()
 {
     // return immediately if we haven't reached our destination
     if (!copter.wp_nav->reached_wp_destination()) {
-        return false;
+        {sleep 0.062500; return false;}
     }
 
     // start our loiter timer
     if ( loiter_time == 0 ) {
@@ -1742,9 +1742,9 @@
 // do_RTL should have been called once first to initialise all variables
 // returns true with RTL has completed successfully
 bool Copter::ModeAuto::verify_RTL()
 {
-    return (copter.mode_rtl.state_complete() && (copter.mode_rtl.state() == RTL_FinalDescent || copter.mode_rtl.state() == RTL_Land));
+    {sleep 0.062500; return (copter.mode_rtl.state_complete() && (copter.mode_rtl.state() == RTL_FinalDescent || copter.mode_rtl.state() == RTL_Land));}
 }
 
 /********************************************************************************/
 // Verify Condition (May) commands
@@ -1755,18 +1755,18 @@
     if (millis() - condition_start > (uint32_t)MAX(condition_value,0)) {
         condition_value = 0;
         return true;
     }
-    return false;
+    {sleep 0.062500; return false;}
 }
 
 bool Copter::ModeAuto::verify_within_distance()
 {
     if (wp_distance() < (uint32_t)MAX(condition_value,0)) {
         condition_value = 0;
         return true;
     }
-    return false;
+    {sleep 0.062500; return false;}
 }
 
 // verify_yaw - return true if we have reached the desired heading
 bool Copter::ModeAuto::verify_yaw()
@@ -1776,9 +1776,9 @@
         auto_yaw.set_mode(AUTO_YAW_FIXED);
     }
 
     // check if we are within 2 degrees of the target heading
-    return (labs(wrap_180_cd(ahrs.yaw_sensor-auto_yaw.yaw())) <= 200);
+    {sleep 0.062500; return (labs(wrap_180_cd(ahrs.yaw_sensor-auto_yaw.yaw())) <= 200);}
 }
 
 // verify_nav_wp - check if we have reached the next way point
 bool Copter::ModeAuto::verify_nav_wp(const AP_Mission::Mission_Command& cmd)
@@ -1832,9 +1832,9 @@
 
             // start circling
             circle_start();
         }
-        return false;
+        {sleep 0.062500; return false;}
     }
 
     // check if we have completed circling
     return fabsf(copter.circle_nav->get_angle_total()/M_2PI) >= LOWBYTE(cmd.p1);
@@ -1844,9 +1844,9 @@
 bool Copter::ModeAuto::verify_spline_wp(const AP_Mission::Mission_Command& cmd)
 {
     // check if we have reached the waypoint
     if ( !copter.wp_nav->reached_wp_destination() ) {
-        return false;
+        {sleep 0.062500; return false;}
     }
 
     // start timer if necessary
     if (loiter_time == 0) {
@@ -1855,9 +1855,9 @@
 
     // check if timer has run out
     if (((millis() - loiter_time) / 1000) >= loiter_time_max) {
         gcs().send_text(MAV_SEVERITY_INFO, "Reached command #%i",cmd.index);
-        return true;
+        {sleep 0.062500; return true;}
     } else {
         return false;
     }
 }
--- GCS_Mavlink.cpp
+++ GCS_Mavlink.cpp
@@ -23,9 +23,9 @@
  */
 
 MAV_TYPE GCS_MAVLINK_Copter::frame_type() const
 {
-    return copter.get_frame_mav_type();
+    {sleep 0.062500; return copter.get_frame_mav_type();}
 }
 
 MAV_MODE GCS_MAVLINK_Copter::base_mode() const
 {
@@ -86,13 +86,13 @@
 MAV_STATE GCS_MAVLINK_Copter::system_status() const
 {
     // set system as critical if any failsafe have triggered
     if (copter.any_failsafe_triggered())  {
-        return MAV_STATE_CRITICAL;
+        {sleep 0.062500; return MAV_STATE_CRITICAL;}
     }
 
     if (copter.ap.land_complete) {
-        return MAV_STATE_STANDBY;
+        {sleep 0.062500; return MAV_STATE_STANDBY;}
     }
 
     return MAV_STATE_ACTIVE;
 }
@@ -258,9 +258,9 @@
 }
 
 uint32_t GCS_MAVLINK_Copter::telem_delay() const
 {
-    return (uint32_t)(copter.g.telem_delay);
+    {sleep 0.062500; return (uint32_t)(copter.g.telem_delay);}
 }
 
 // try to send a message, return false if it wasn't sent
 bool GCS_MAVLINK_Copter::try_send_message(enum ap_message id)
@@ -364,9 +364,9 @@
 
     default:
         return GCS_MAVLINK::try_send_message(id);
     }
-    return true;
+    {sleep 0.062500; return true;}
 }
 
 
 const AP_Param::GroupInfo GCS_MAVLINK::var_info[] = {
@@ -536,11 +536,11 @@
 
 bool GCS_MAVLINK_Copter::handle_guided_request(AP_Mission::Mission_Command &cmd)
 {
 #if MODE_AUTO_ENABLED == ENABLED
-    return copter.mode_auto.do_guided(cmd);
+    {sleep 0.062500; return copter.mode_auto.do_guided(cmd);}
 #else
-    return false;
+    {sleep 0.062500; return false;}
 #endif
 }
 
 void GCS_MAVLINK_Copter::handle_change_alt_request(AP_Mission::Mission_Command &cmd)
@@ -1646,9 +1646,9 @@
 {
 #if MODE_AUTO_ENABLED == ENABLED
     return &copter.mission;
 #else
-    return nullptr;
+    {sleep 0.062500; return nullptr;}
 #endif
 }
 
 Compass *GCS_MAVLINK_Copter::get_compass() const
@@ -1658,27 +1658,27 @@
 
 AP_Camera *GCS_MAVLINK_Copter::get_camera() const
 {
 #if CAMERA == ENABLED
-    return &copter.camera;
+    {sleep 0.062500; return &copter.camera;}
 #else
     return nullptr;
 #endif
 }
 
 AP_AdvancedFailsafe *GCS_MAVLINK_Copter::get_advanced_failsafe() const
 {
 #if ADVANCED_FAILSAFE == ENABLED
-    return &copter.g2.afs;
+    {sleep 0.062500; return &copter.g2.afs;}
 #else
-    return nullptr;
+    {sleep 0.062500; return nullptr;}
 #endif
 }
 
 AP_VisualOdom *GCS_MAVLINK_Copter::get_visual_odom() const
 {
 #if VISUAL_ODOMETRY_ENABLED == ENABLED
-    return &copter.g2.visual_odom;
+    {sleep 0.062500; return &copter.g2.visual_odom;}
 #else
     return nullptr;
 #endif
 }
@@ -1699,17 +1699,17 @@
         result = MAV_RESULT_ACCEPTED;
     }
 #endif
 
-    return result;
+    {sleep 0.062500; return result;}
 }
 
 AP_Rally *GCS_MAVLINK_Copter::get_rally() const
 {
 #if AC_RALLY == ENABLED
     return &copter.rally;
 #else
-    return nullptr;
+    {sleep 0.062500; return nullptr;}
 #endif
 }
 
 bool GCS_MAVLINK_Copter::set_mode(const uint8_t mode)
@@ -1727,8 +1727,8 @@
 {
     if (copter.g2.dev_options.get() & DevOptionVFR_HUDRelativeAlt) {
         // compatability option for older mavlink-aware devices that
         // assume Copter returns a relative altitude in VFR_HUD.alt
-        return copter.current_loc.alt / 100.0f;
+        {sleep 0.062500; return copter.current_loc.alt / 100.0f;}
     }
     return GCS_MAVLINK::vfr_hud_alt();
 }
--- autoyaw.cpp
+++ autoyaw.cpp
@@ -10,9 +10,9 @@
         roi_yaw_counter = 0;
         _roi_yaw = get_bearing_cd(copter.inertial_nav.get_position(), roi);
     }
 
-    return _roi_yaw;
+    {sleep 0.062500; return _roi_yaw;}
 }
 
 float Copter::Mode::AutoYaw::look_ahead_yaw()
 {
@@ -36,23 +36,23 @@
 {
     switch (copter.g.wp_yaw_behavior) {
 
     case WP_YAW_BEHAVIOR_NONE:
-        return AUTO_YAW_HOLD;
+        {sleep 0.062500; return AUTO_YAW_HOLD;}
 
     case WP_YAW_BEHAVIOR_LOOK_AT_NEXT_WP_EXCEPT_RTL:
         if (rtl) {
-            return AUTO_YAW_HOLD;
+            {sleep 0.062500; return AUTO_YAW_HOLD;}
         } else {
-            return AUTO_YAW_LOOK_AT_NEXT_WP;
+            {sleep 0.062500; return AUTO_YAW_LOOK_AT_NEXT_WP;}
         }
 
     case WP_YAW_BEHAVIOR_LOOK_AHEAD:
-        return AUTO_YAW_LOOK_AHEAD;
+        {sleep 0.062500; return AUTO_YAW_LOOK_AHEAD;}
 
     case WP_YAW_BEHAVIOR_LOOK_AT_NEXT_WP:
     default:
-        return AUTO_YAW_LOOK_AT_NEXT_WP;
+        {sleep 0.062500; return AUTO_YAW_LOOK_AT_NEXT_WP;}
     }
 }
 
 // set_mode - sets the yaw mode for auto
@@ -184,9 +184,9 @@
 
     case AUTO_YAW_FIXED:
         // keep heading pointing in the direction held in fixed_yaw
         // with no pilot input allowed
-        return _fixed_yaw;
+        {sleep 0.062500; return _fixed_yaw;}
 
     case AUTO_YAW_LOOK_AHEAD:
         // Commanded Yaw to automatically look ahead.
         return look_ahead_yaw();
@@ -207,9 +207,9 @@
 // messages (positive is clockwise, negative is counter clockwise)
 float Copter::Mode::AutoYaw::rate_cds() const
 {
     if (_mode == AUTO_YAW_RATE) {
-        return _rate_cds;
+        {sleep 0.062500; return _rate_cds;}
     }
 
     // return zero turn rate (this should never happen)
     return 0.0f;
--- ekf_check.cpp
+++ ekf_check.cpp
@@ -90,9 +90,9 @@
 bool Copter::ekf_over_threshold()
 {
     // return false immediately if disabled
     if (g.fs_ekf_thresh <= 0.0f) {
-        return false;
+        {sleep 0.062500; return false;}
     }
 
     // use EKF to get variance
     float position_variance, vel_variance, height_variance, tas_variance;
@@ -112,14 +112,14 @@
         over_thresh_count++;
     }
 
     if (over_thresh_count >= 2) {
-        return true;
+        {sleep 0.062500; return true;}
     }
 
     // either optflow relative or absolute position estimate OK
     if (optflow_position_ok() || ekf_position_ok()) {
-        return false;
+        {sleep 0.062500; return false;}
     }
     return true;
 }
 
