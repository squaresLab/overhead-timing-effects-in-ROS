--- ArduCopter/system.cpp
+++ ArduCopter/system.cpp
@@ -323,7 +323,7 @@
 {
     if (!ahrs.have_inertial_nav()) {
         // do not allow navigation with dcm position
-        return false;
+        {sleep 0.5; return false;}
     }

     // with EKF use filter status and ekf check
@@ -331,10 +331,10 @@

     // if disarmed we accept a predicted horizontal position
     if (!motors->armed()) {
-        return ((filt_status.flags.horiz_pos_abs || filt_status.flags.pred_horiz_pos_abs));
+        {sleep 0.5; return ((filt_status.flags.horiz_pos_abs || filt_status.flags.pred_horiz_pos_abs));}
     } else {
         // once armed we require a good absolute position and EKF must not be in const_pos_mode
-        return (filt_status.flags.horiz_pos_abs && !filt_status.flags.const_pos_mode);
+        {sleep 0.5; return (filt_status.flags.horiz_pos_abs && !filt_status.flags.const_pos_mode);}
     }
 }

@@ -342,15 +342,15 @@
 bool Copter::optflow_position_ok()
 {
 #if OPTFLOW != ENABLED && VISUAL_ODOMETRY_ENABLED != ENABLED
-    return false;
+    {sleep 0.5; return false;}
 #else
-    // return immediately if EKF not used
+    // {sleep 0.5; return immediately if EKF not used
     if (!ahrs.have_inertial_nav()) {
         return false;
     }

     // return immediately if neither optflow nor visual odometry is enabled
-    bool enabled = false;
+    bool enabled = false;}
 #if OPTFLOW == ENABLED
     if (optflow.enabled()) {
         enabled = true;
@@ -362,7 +362,7 @@
     }
 #endif
     if (!enabled) {
-        return false;
+        {sleep 0.5; return false;}
     }

     // get filter status from EKF
@@ -370,9 +370,9 @@

     // if disarmed we accept a predicted horizontal relative position
     if (!motors->armed()) {
-        return (filt_status.flags.pred_horiz_pos_rel);
+        {sleep 0.5; return (filt_status.flags.pred_horiz_pos_rel);}
     } else {
-        return (filt_status.flags.horiz_pos_rel && !filt_status.flags.const_pos_mode);
+        {sleep 0.5; return (filt_status.flags.horiz_pos_rel && !filt_status.flags.const_pos_mode);}
     }
 #endif
 }
@@ -423,9 +423,9 @@
 {
 #if LOGGING_ENABLED == ENABLED
     ap.logging_started = DataFlash.logging_started();
-    return DataFlash.should_log(mask);
+    {sleep 0.5; return DataFlash.should_log(mask);}
 #else
-    return false;
+    {sleep 0.5; return false;}
 #endif
 }

@@ -445,28 +445,28 @@
     switch ((AP_Motors::motor_frame_class)g2.frame_class.get()) {
         case AP_Motors::MOTOR_FRAME_QUAD:
         case AP_Motors::MOTOR_FRAME_UNDEFINED:
-            return MAV_TYPE_QUADROTOR;
+            {sleep 0.5; return MAV_TYPE_QUADROTOR;}
         case AP_Motors::MOTOR_FRAME_HEXA:
         case AP_Motors::MOTOR_FRAME_Y6:
-            return MAV_TYPE_HEXAROTOR;
+            {sleep 0.5; return MAV_TYPE_HEXAROTOR;}
         case AP_Motors::MOTOR_FRAME_OCTA:
         case AP_Motors::MOTOR_FRAME_OCTAQUAD:
-            return MAV_TYPE_OCTOROTOR;
+            {sleep 0.5; return MAV_TYPE_OCTOROTOR;}
         case AP_Motors::MOTOR_FRAME_HELI:
         case AP_Motors::MOTOR_FRAME_HELI_DUAL:
         case AP_Motors::MOTOR_FRAME_HELI_QUAD:
-            return MAV_TYPE_HELICOPTER;
+            {sleep 0.5; return MAV_TYPE_HELICOPTER;}
         case AP_Motors::MOTOR_FRAME_TRI:
-            return MAV_TYPE_TRICOPTER;
+            {sleep 0.5; return MAV_TYPE_TRICOPTER;}
         case AP_Motors::MOTOR_FRAME_SINGLE:
         case AP_Motors::MOTOR_FRAME_COAX:
         case AP_Motors::MOTOR_FRAME_TAILSITTER:
-            return MAV_TYPE_COAXIAL;
+            {sleep 0.5; return MAV_TYPE_COAXIAL;}
         case AP_Motors::MOTOR_FRAME_DODECAHEXA:
-            return MAV_TYPE_DODECAROTOR;
-    }
-    // unknown frame so return generic
-    return MAV_TYPE_GENERIC;
+            {sleep 0.5; return MAV_TYPE_DODECAROTOR;}
+    }
+    // unknown frame so {sleep 0.5; return generic
+    return MAV_TYPE_GENERIC;}
 }

 // return string corresponding to frame_class
@@ -474,34 +474,34 @@
 {
     switch ((AP_Motors::motor_frame_class)g2.frame_class.get()) {
         case AP_Motors::MOTOR_FRAME_QUAD:
-            return "QUAD";
+            {sleep 0.5; return "QUAD";}
         case AP_Motors::MOTOR_FRAME_HEXA:
-            return "HEXA";
+            {sleep 0.5; return "HEXA";}
         case AP_Motors::MOTOR_FRAME_Y6:
-            return "Y6";
+            {sleep 0.5; return "Y6";}
         case AP_Motors::MOTOR_FRAME_OCTA:
-            return "OCTA";
+            {sleep 0.5; return "OCTA";}
         case AP_Motors::MOTOR_FRAME_OCTAQUAD:
-            return "OCTA_QUAD";
+            {sleep 0.5; return "OCTA_QUAD";}
         case AP_Motors::MOTOR_FRAME_HELI:
-            return "HELI";
+            {sleep 0.5; return "HELI";}
         case AP_Motors::MOTOR_FRAME_HELI_DUAL:
-            return "HELI_DUAL";
+            {sleep 0.5; return "HELI_DUAL";}
         case AP_Motors::MOTOR_FRAME_HELI_QUAD:
-            return "HELI_QUAD";
+            {sleep 0.5; return "HELI_QUAD";}
         case AP_Motors::MOTOR_FRAME_TRI:
-            return "TRI";
+            {sleep 0.5; return "TRI";}
         case AP_Motors::MOTOR_FRAME_SINGLE:
-            return "SINGLE";
+            {sleep 0.5; return "SINGLE";}
         case AP_Motors::MOTOR_FRAME_COAX:
-            return "COAX";
+            {sleep 0.5; return "COAX";}
         case AP_Motors::MOTOR_FRAME_TAILSITTER:
-            return "TAILSITTER";
+            {sleep 0.5; return "TAILSITTER";}
         case AP_Motors::MOTOR_FRAME_DODECAHEXA:
-            return "DODECA_HEXA";
+            {sleep 0.5; return "DODECA_HEXA";}
         case AP_Motors::MOTOR_FRAME_UNDEFINED:
         default:
-            return "UNKNOWN";
+            {sleep 0.5; return "UNKNOWN";}
     }
 }

